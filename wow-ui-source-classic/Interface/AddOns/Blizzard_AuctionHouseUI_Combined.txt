--- START OF FILE: Blizzard_AuctionHouseUI\Blizzard_AuctionHouseUI_Classic.toc ---

## Interface: 0
## Title: Blizzard Auction House UI
## Secure: 1
## LoadOnDemand: 1
## SavedVariables: g_auctionHouseSortsBySearchContext
## SavedVariablesPerCharacter: g_activeBidAuctionIDs
## Dependencies: Blizzard_HelpPlate
## AllowLoad: game
## AllowLoadGameType: tbc, wrath, cata, mists
## Dependencies: Blizzard_Colors
Shared\Blizzard_AuctionHouseUtil.lua
Classic\Blizzard_AuctionHouseUtil.lua
Shared\Blizzard_AuctionData.lua
Classic\Blizzard_AuctionData.lua
Shared\Blizzard_AuctionHouseSharedTemplates.lua
Classic\Blizzard_AuctionHouseSharedTemplates.lua
Shared\Blizzard_AuctionHouseSharedTemplates.xml
Classic\Blizzard_AuctionHouseSharedTemplates.xml
Shared\Blizzard_AuctionHouseTableBuilder.lua
Shared\Blizzard_AuctionHouseTableBuilder.xml
Shared\Blizzard_AuctionHouseTab.lua
Classic\Blizzard_AuctionHouseTab.xml
Shared\Blizzard_AuctionHouseItemList.lua
Classic\Blizzard_AuctionHouseItemList.xml
Shared\Blizzard_AuctionHouseCategoriesList.lua
Classic\Blizzard_AuctionHouseCategoriesList.lua
Classic\Blizzard_AuctionHouseCategoriesList.xml
Shared\Blizzard_AuctionHouseSearchBar.lua
Shared\Blizzard_AuctionHouseSearchBar.xml
Shared\Blizzard_AuctionHouseBrowseResultsFrame.lua
Shared\Blizzard_AuctionHouseBrowseResultsFrame.xml
Shared\Blizzard_AuctionHouseCommoditiesList.lua
Shared\Blizzard_AuctionHouseCommoditiesList.xml
Shared\Blizzard_AuctionHouseItemBuyFrame.lua
Shared\Blizzard_AuctionHouseItemBuyFrame.xml
Shared\Blizzard_AuctionHouseSellFrame.lua
Shared\Blizzard_AuctionHouseSellFrame.xml
Shared\Blizzard_AuctionHouseCommoditiesSellFrame.lua
Shared\Blizzard_AuctionHouseCommoditiesSellFrame.xml
Shared\Blizzard_AuctionHouseCommoditiesBuyFrame.lua
Shared\Blizzard_AuctionHouseCommoditiesBuyFrame.xml
Shared\Blizzard_AuctionHouseItemSellFrame.lua
Shared\Blizzard_AuctionHouseItemSellFrame.xml
Shared\Blizzard_AuctionHouseAuctionsFrame.lua
Classic\Blizzard_AuctionHouseAuctionsFrame.xml
Shared\Blizzard_AuctionHouseWoWTokenFrame.lua
Shared\Blizzard_AuctionHouseWoWTokenFrame.xml
Shared\Blizzard_AuctionHouseBuyDialog.lua
Shared\Blizzard_AuctionHouseBuyDialog.xml
Shared\Blizzard_AuctionHouseMultisell.lua
Classic\Blizzard_AuctionHouseMultisell.xml
Shared\Blizzard_AuctionHouseFrame.lua
Shared\Blizzard_AuctionHouseFrame.xml
Localization.lua

--- END OF FILE: Blizzard_AuctionHouseUI\Blizzard_AuctionHouseUI_Classic.toc ---

--- START OF FILE: Blizzard_AuctionHouseUI\Blizzard_AuctionHouseUI_Mainline.toc ---

## Interface: 0
## Title: Blizzard Auction House UI
## Secure: 1
## LoadOnDemand: 1
## SavedVariables: g_auctionHouseSortsBySearchContext
## SavedVariablesPerCharacter: g_activeBidAuctionIDs
## Dependencies: Blizzard_Colors, Blizzard_HelpPlate
## AllowLoad: game
## AllowLoadGameType: mainline
Shared\Blizzard_AuctionHouseUtil.lua
Mainline\Blizzard_AuctionHouseUtil.lua
Shared\Blizzard_AuctionData.lua
Mainline\Blizzard_AuctionData.lua
Shared\Blizzard_AuctionHouseSharedTemplates.lua
Mainline\Blizzard_AuctionHouseSharedTemplates.lua
Shared\Blizzard_AuctionHouseSharedTemplates.xml
Mainline\Blizzard_AuctionHouseSharedTemplates.xml
Shared\Blizzard_AuctionHouseTableBuilder.lua
Shared\Blizzard_AuctionHouseTableBuilder.xml
Shared\Blizzard_AuctionHouseTab.lua
Mainline\Blizzard_AuctionHouseTab.xml
Shared\Blizzard_AuctionHouseItemList.lua
Mainline\Blizzard_AuctionHouseItemList.xml
Shared\Blizzard_AuctionHouseCategoriesList.lua
Mainline\Blizzard_AuctionHouseCategoriesList.lua
Mainline\Blizzard_AuctionHouseCategoriesList.xml
Shared\Blizzard_AuctionHouseSearchBar.lua
Shared\Blizzard_AuctionHouseSearchBar.xml
Shared\Blizzard_AuctionHouseBrowseResultsFrame.lua
Shared\Blizzard_AuctionHouseBrowseResultsFrame.xml
Shared\Blizzard_AuctionHouseCommoditiesList.lua
Shared\Blizzard_AuctionHouseCommoditiesList.xml
Shared\Blizzard_AuctionHouseItemBuyFrame.lua
Shared\Blizzard_AuctionHouseItemBuyFrame.xml
Shared\Blizzard_AuctionHouseSellFrame.lua
Shared\Blizzard_AuctionHouseSellFrame.xml
Shared\Blizzard_AuctionHouseCommoditiesSellFrame.lua
Shared\Blizzard_AuctionHouseCommoditiesSellFrame.xml
Shared\Blizzard_AuctionHouseCommoditiesBuyFrame.lua
Shared\Blizzard_AuctionHouseCommoditiesBuyFrame.xml
Shared\Blizzard_AuctionHouseItemSellFrame.lua
Shared\Blizzard_AuctionHouseItemSellFrame.xml
Shared\Blizzard_AuctionHouseAuctionsFrame.lua
Mainline\Blizzard_AuctionHouseAuctionsFrame.xml
Shared\Blizzard_AuctionHouseWoWTokenFrame.lua
Shared\Blizzard_AuctionHouseWoWTokenFrame.xml
Shared\Blizzard_AuctionHouseBuyDialog.lua
Shared\Blizzard_AuctionHouseBuyDialog.xml
Shared\Blizzard_AuctionHouseMultisell.lua
Mainline\Blizzard_AuctionHouseMultisell.xml
Shared\Blizzard_AuctionHouseFrame.lua
Shared\Blizzard_AuctionHouseFrame.xml
Localization.lua

--- END OF FILE: Blizzard_AuctionHouseUI\Blizzard_AuctionHouseUI_Mainline.toc ---

--- START OF FILE: Blizzard_AuctionHouseUI\Localization.lua ---

local function AdjustWoWTokenDisplayFont()
	-- These existed but never seemed to be used because Blizzard_AuctionHouseUI.toc
	-- never loaded a Localization file, nor did it have a stub in its directory.
	-- These may need to be removed if the behavior is incorrect, but it was likely
	-- already incorrect and this fixes it.
	AuctionHouseFrame.WoWTokenResults.GameTimeTutorial.LeftDisplay.Label:SetFontObject("GameFontNormalHugeBlack");
	AuctionHouseFrame.WoWTokenResults.GameTimeTutorial.RightDisplay.Label:SetFontObject("GameFontNormalHugeBlack");
end

local l10nTable = {
	deDE = {},
	enGB = {},
	enUS = {},
	esES = {
		localize = AdjustWoWTokenDisplayFont,
	},
	esMX = {
		localize = AdjustWoWTokenDisplayFont,
	},
	frFR = {
		localize = AdjustWoWTokenDisplayFont,
	},
	itIT = {
		localize = function()
			AuctionHouseFrame.WoWTokenResults.GameTimeTutorial.LeftDisplay.Label:SetFontObject("Game18Font");
			AuctionHouseFrame.WoWTokenResults.GameTimeTutorial.RightDisplay.Label:SetFontObject("Game18Font");
		end,
	},
	koKR = {},
	ptBR = {
		localize = AdjustWoWTokenDisplayFont,
	},
	ptPT = {
		localize = AdjustWoWTokenDisplayFont,
	},
	ruRU = {
		localize = AdjustWoWTokenDisplayFont,
	},
	zhCN = {},
	zhTW = {},
};

SetupLocalization(l10nTable);

--- END OF FILE: Blizzard_AuctionHouseUI\Localization.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionData.lua ---

PRICE_DISPLAY_WIDTH = 145;
PRICE_DISPLAY_WITH_CHECKMARK_WIDTH = 150;

function AuctionCategoryMixin:AddBulkInventoryTypeCategories(classID, subClassID, inventoryTypes)
	local inventoryTypeNone = nil;
	local useParentFilters = true;
	self:CreateSubCategoryAndFilter(classID, subClassID, inventoryTypeNone, nil, useParentFilters);

	for _, inventoryType in ipairs(inventoryTypes) do
		self:CreateSubCategoryAndFilter(classID, subClassID, inventoryType);
	end
end

do -- Weapons
	local weaponsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_WEAPONS);

	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Axe1H);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Axe2H);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Bows);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Guns);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Mace1H);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Mace2H);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Polearm);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Sword1H);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Sword2H);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Staff);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Unarmed);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Generic);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Dagger);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Thrown);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Crossbow);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Wand);
	weaponsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Fishingpole);
end

do -- Armor
	local MiscArmorInventoryTypes = {
		Enum.InventoryType.IndexHeadType,
		Enum.InventoryType.IndexNeckType,
		Enum.InventoryType.IndexBodyType,
		Enum.InventoryType.IndexFingerType,
		Enum.InventoryType.IndexTrinketType,
		Enum.InventoryType.IndexHoldableType,
	};

	local ClothArmorInventoryTypes = {
		Enum.InventoryType.IndexHeadType,
		Enum.InventoryType.IndexShoulderType,
		Enum.InventoryType.IndexChestType,
		Enum.InventoryType.IndexWaistType,
		Enum.InventoryType.IndexLegsType,
		Enum.InventoryType.IndexFeetType,
		Enum.InventoryType.IndexWristType,
		Enum.InventoryType.IndexHandType,
		Enum.InventoryType.IndexCloakType, -- Only for Cloth.
	};

	local ArmorInventoryTypes = {
		Enum.InventoryType.IndexHeadType,
		Enum.InventoryType.IndexShoulderType,
		Enum.InventoryType.IndexChestType,
		Enum.InventoryType.IndexWaistType,
		Enum.InventoryType.IndexLegsType,
		Enum.InventoryType.IndexFeetType,
		Enum.InventoryType.IndexWristType,
		Enum.InventoryType.IndexHandType,
	};

	local armorCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_ARMOR);

	local miscCategory = armorCategory:CreateSubCategory(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic);
	miscCategory:AddBulkInventoryTypeCategories(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic, MiscArmorInventoryTypes);

	local clothCategory = armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Cloth);
	clothCategory:AddBulkInventoryTypeCategories(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Cloth, ClothArmorInventoryTypes);

	local clothChestCategory = clothCategory:FindSubCategoryByName(C_Item.GetItemInventorySlotInfo(Enum.InventoryType.IndexChestType));
	clothChestCategory:AddFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Cloth, Enum.InventoryType.IndexRobeType);

	local leatherCategory = armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Leather);
	leatherCategory:AddBulkInventoryTypeCategories(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Leather, ArmorInventoryTypes);

	local leatherChestCategory = leatherCategory:FindSubCategoryByName(C_Item.GetItemInventorySlotInfo(Enum.InventoryType.IndexChestType));
	leatherChestCategory:AddFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Leather, Enum.InventoryType.IndexRobeType);

	local mailCategory = armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Mail);
	mailCategory:AddBulkInventoryTypeCategories(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Mail, ArmorInventoryTypes);

	local mailChestCategory = mailCategory:FindSubCategoryByName(C_Item.GetItemInventorySlotInfo(Enum.InventoryType.IndexChestType));
	mailChestCategory:AddFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Mail, Enum.InventoryType.IndexRobeType);

	local plateCategory = armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Plate);
	plateCategory:AddBulkInventoryTypeCategories(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Plate, ArmorInventoryTypes);

	local plateChestCategory = plateCategory:FindSubCategoryByName(C_Item.GetItemInventorySlotInfo(Enum.InventoryType.IndexChestType));
	plateChestCategory:AddFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Plate, Enum.InventoryType.IndexRobeType);

	armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Shield);
	if ClassicExpansionAtLeast(LE_EXPANSION_CATACLYSM) then
		armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Relic);
	else
		armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Libram);
		armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Idol);
		armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Totem);
	end
end

do -- Containers
	local containersCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_CONTAINERS);
	--containersCategory:SetDetailColumnString(SLOT_ABBR);
	containersCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Container);
end

do -- Consumables (SubClasses Added in TBC)
	local consumablesCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_CONSUMABLES);
	if ClassicExpansionAtLeast(LE_EXPANSION_BURNING_CRUSADE) then
		consumablesCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Consumable);
	else
		consumablesCategory:AddFilter(Enum.ItemClass.Consumable);
	end
end

do -- Glyphs (Added in Wrath)
	if ClassicExpansionAtLeast(LE_EXPANSION_WRATH_OF_THE_LICH_KING) then
		local glyphsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_GLYPHS);
		glyphsCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Glyph);
	end
end

do -- Trade Goods (SubClasses Added in TBC)
	local tradeGoodsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_TRADE_GOODS);
	if ClassicExpansionAtLeast(LE_EXPANSION_BURNING_CRUSADE) then
		tradeGoodsCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Tradegoods);
	else
		tradeGoodsCategory:AddFilter(Enum.ItemClass.Tradegoods);
	end
end

do -- Projectile
	if ClassicExpansionAtMost(LE_EXPANSION_WRATH_OF_THE_LICH_KING) then
		local projectileCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_PROJECTILE);
		projectileCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Projectile);
	end
end

do -- Quiver
	if ClassicExpansionAtMost(LE_EXPANSION_WRATH_OF_THE_LICH_KING) then
		local quiverCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_QUIVER);
		quiverCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Quiver);
	end
end

do -- Recipes
	local recipesCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_RECIPES);
	recipesCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Recipe);
end

do -- Reagent (Changed to a ItemClass.Miscellaneous and other ClassIDs in TBC)
	if GetClassicExpansionLevel() == LE_EXPANSION_CLASSIC then
		local reagentCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_REAGENT);
		reagentCategory:AddFilter(Enum.ItemClass.Reagent);
	end
end

do -- Gems (Added in TBC)
	if ClassicExpansionAtLeast(LE_EXPANSION_BURNING_CRUSADE) then
		local gemsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_GEMS);
		gemsCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Gem);
	end
end

do -- Miscellaneous (SubClasses Added in TBC)
	local miscellaneousCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_MISCELLANEOUS);
	miscellaneousCategory:AddFilter(Enum.ItemClass.Miscellaneous);
	if ClassicExpansionAtLeast(LE_EXPANSION_BURNING_CRUSADE) then
		miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Junk);
		miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Reagent);
		if not ClassicExpansionAtLeast(LE_EXPANSION_MISTS_OF_PANDARIA) then
			miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.CompanionPet);
		end
		miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Holiday);
		miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Other);
		miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Mount);
	end
end

do -- Quest Items (Added in TBC)
	if ClassicExpansionAtLeast(LE_EXPANSION_BURNING_CRUSADE) then
		local questItemsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_QUEST_ITEMS);
		questItemsCategory:AddFilter(Enum.ItemClass.Questitem);
	end
end

do -- Battle Pets (Added in MoP)
	if ClassicExpansionAtLeast(LE_EXPANSION_MISTS_OF_PANDARIA) then
		local battlePetsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_BATTLE_PETS);
		battlePetsCategory:AddFilter(Enum.ItemClass.Battlepet);
		battlePetsCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Battlepet);
		battlePetsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.CompanionPet);
	end
end

do -- WoW Token
	local wowTokenCategory = AuctionFrame_CreateCategory(TOKEN_FILTER_LABEL);
	wowTokenCategory:AddFilter(ITEM_CLASS_WOW_TOKEN);
	wowTokenCategory:SetFlag("WOW_TOKEN_FLAG");
end


--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionData.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseAuctionsFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Button name="AuctionHouseAuctionsFrameTabTemplate" mixin="AuctionHouseAuctionsFrameTabMixin" inherits="AuctionHouseFrameTopTabTemplate" virtual="true">
		<Scripts>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>

	<Button name="AuctionHouseAuctionsSummaryLineTemplate" mixin="AuctionHouseAuctionsSummaryLineMixin" inherits="TruncatedTooltipScriptTemplate" virtual="true">
		<Size x="0" y="21"/>
		<Layers>
			<Layer level="BACKGROUND">
				<FontString parentKey="Text" inherits="GameFontNormal" justifyH="LEFT" wordwrap="false">
					<Anchors>
						<Anchor point="LEFT" x="4" y="0"/>
						<Anchor point="RIGHT" x="-4" y="0"/>
					</Anchors>
				</FontString>
			</Layer>
			<Layer level="BORDER">
				<Texture parentKey="Icon">
					<Size x="14" y="14"/>
					<Anchors>
						<Anchor point="LEFT" x="4" y="0"/>
					</Anchors>
				</Texture>
			</Layer>
			<Layer level="ARTWORK">
				<Texture parentKey="IconBorder" atlas="auctionhouse-itemicon-small-border" useAtlasSize="false">
					<Size x="16" y="16"/>
					<Anchors>
						<Anchor point="CENTER" relativeKey="$parent.Icon"/>
					</Anchors>
				</Texture>
			</Layer>
			<Layer level="OVERLAY">
				<Texture parentKey="SelectedHighlight" atlas="auctionhouse-ui-row-select" alpha=".8" hidden="true" alphaMode="ADD"/>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnEvent method="OnEvent"/>
			<OnHide method="OnHide"/>
		</Scripts>
		<HighlightTexture parentKey="HighlightTexture" atlas="auctionhouse-ui-row-highlight" useAtlasSize="false" alphaMode="ADD">
			<Anchors>
				<Anchor point="TOPLEFT" relativePoint="TOPLEFT" x="0" y="0"/>
				<Anchor point="BOTTOMRIGHT" relativePoint="BOTTOMRIGHT" x="0" y="0"/>
			</Anchors>
		</HighlightTexture>
	</Button>

	<Frame name="AuctionHouseAuctionsFrameTemplate" mixin="AuctionHouseAuctionsFrameMixin" virtual="true">
		<Frames>
			<Button name="$parentAuctionsTab" parentKey="AuctionsTab" id="1" inherits="AuctionHouseAuctionsFrameTabTemplate" parentArray="Tabs" frameLevel="300" text="AUCTION_HOUSE_AUCTIONS_SUB_TAB">
				<Anchors>
					<Anchor point="TOPLEFT" x="47" y="1"/>
				</Anchors>
			</Button>

			<Button name="$parentBidsTab" parentKey="BidsTab" id="2" inherits="AuctionHouseAuctionsFrameTabTemplate" parentArray="Tabs" useParentLevel="true" text="AUCTION_HOUSE_BIDS_SUB_TAB">
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.AuctionsTab" relativePoint="RIGHT" x="-3" y="0"/>
				</Anchors>
			</Button>

			<Button parentKey="CancelAuctionButton" mixin="CancelAuctionButtonMixin" inherits="UIPanelButtonTemplate" useParentLevel="true" text="AUCTION_HOUSE_CANCEL_AUCTION_BUTTON">
				<Size x="158" y="22"/>
				<Anchors>
					<Anchor point="BOTTOMRIGHT" x="-3" y="-22"/>
				</Anchors>
				<Scripts>
					<OnClick method="OnClick"/>
				</Scripts>
			</Button>

			<Frame parentKey="BuyoutFrame" inherits="AuctionHouseBuyoutFrameTemplate">
				<Anchors>
					<Anchor point="RIGHT" relativeKey="$parent.CancelAuctionButton" relativePoint="RIGHT"/>
				</Anchors>
			</Frame>

			<Frame parentKey="BidFrame" inherits="AuctionHouseBidFrameTemplate">
				<Anchors>
					<Anchor point="RIGHT" relativeKey="$parent.BuyoutFrame" relativePoint="LEFT" x="-58" y="0"/>
				</Anchors>
			</Frame>

			<Frame parentKey="SummaryList" inherits="AuctionHouseBackgroundTemplate" mixin="AuctionHouseAuctionsSummaryListMixin" useParentLevel="true">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-summarylist" type="string"/>
					<KeyValue key="backgroundTextureClassic" value="Interface\QuestFrame\UI-TextBackground-BackdropBackground" type="string"/>
					<KeyValue key="textureWidthClassic" value="138" type="number"/>
					<KeyValue key="textureHeightClassic" value="434" type="number"/>
					<KeyValue key="textureXOffsetClassic" value="3" type="number"/>
					<KeyValue key="textureYOffsetClassic" value="-2" type="number"/>
				</KeyValues>
				<Size x="168" y="0"/>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.AuctionsTab" relativePoint="BOTTOM" x="0" y="0"/>
					<Anchor point="BOTTOM" relativeKey="$parent.CancelAuctionButton" relativePoint="TOP"/>
					<Anchor point="LEFT" x="-1"/>
				</Anchors>
				<Frames>
					<Frame parentKey="ScrollBox" inherits="WowScrollBoxList">
						<Size x="148" y="0"/>
						<Anchors>
							<Anchor point="TOPLEFT" x="3" y="-3"/>
							<Anchor point="BOTTOMRIGHT" x="-27" y="3"/>
						</Anchors>
					</Frame>
					<EventFrame parentKey="ScrollBar" inherits="WowClassicScrollBar">
						<Anchors>
							<Anchor point="TOPLEFT" relativeKey="$parent.ScrollBox" relativePoint="TOPRIGHT" x="0" y="2"/>
							<Anchor point="BOTTOMLEFT" relativeKey="$parent.ScrollBox" relativePoint="BOTTOMRIGHT" x="7" y="-5"/>
						</Anchors>
					</EventFrame>
				</Frames>
				<Scripts>
					<OnLoad method="OnLoad"/>
				</Scripts>
			</Frame>

			<Button parentKey="ItemDisplay" inherits="AuctionHouseItemDisplayTemplate" hidden="true">
				<KeyValues>
					<KeyValue key="itemButtonXOffset" value="22" type="number"/>
					<KeyValue key="itemButtonYOffset" value="-2" type="number"/>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-buy-noncommodities-header" type="string"/>
					<KeyValue key="backgroundTextureClassic" value="Interface\QuestFrame\UI-TextBackground-BackdropBackground" type="string"/>
					<KeyValue key="textureWidthClassic" value="617" type="number"/>
					<KeyValue key="textureHeightClassic" value="82" type="number"/>
					<KeyValue key="textureYOffsetClassic" value="-2" type="number"/>
					<KeyValue key="textureXOffsetClassic" value="3" type="number"/>
					
				</KeyValues>
				<Size x="623" y="86"/>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.AuctionsTab" relativePoint="BOTTOM" y="0"/>
					<Anchor point="LEFT" relativeKey="$parent.SummaryList" relativePoint="RIGHT" x="0"/>
				</Anchors>
			</Button>

			<Frame parentKey="AllAuctionsList" inherits="AuctionHouseItemListTemplate">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-index" type="string"/>
					<KeyValue key="textureWidthClassic" value="595" type="number"/>
					<KeyValue key="textureHeightClassic" value="414" type="number"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="34" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.SummaryList" relativePoint="TOP" x="0" y="-1"/> <Anchor point="LEFT" relativeKey="$parent.SummaryList" relativePoint="RIGHT" x="0" y="0"/>
					<Anchor point="RIGHT" x="-5" y="0"/>
					<Anchor point="BOTTOM" relativeKey="$parent.SummaryList" relativePoint="BOTTOM"/>
				</Anchors>
			</Frame>

			<Frame parentKey="BidsList" inherits="AuctionHouseItemListTemplate">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-index" type="string"/>
					<KeyValue key="textureWidthClassic" value="595" type="number"/>
					<KeyValue key="textureHeightClassic" value="414" type="number"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="34" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.AllAuctionsList" relativePoint="TOPLEFT"/>
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.AllAuctionsList" relativePoint="BOTTOMRIGHT"/>
				</Anchors>
			</Frame>

			<Frame parentKey="ItemList" inherits="AuctionHouseItemListTemplate" hidden="true">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-auctions" type="string"/>
					<KeyValue key="textureWidthClassic" value="595" type="number"/>
					<KeyValue key="textureHeightClassic" value="315" type="number"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="133" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.ItemDisplay" relativePoint="BOTTOM" x="0" y="-14"/>
					<Anchor point="LEFT" relativeKey="$parent.ItemDisplay" relativePoint="LEFT" x="0" y="0"/>
					<Anchor point="RIGHT" relativeKey="$parent.AllAuctionsList" relativePoint="RIGHT"/>
					<Anchor point="BOTTOM" relativeKey="$parent.SummaryList" relativePoint="BOTTOM"/>
				</Anchors>
			</Frame>

			<Frame parentKey="CommoditiesList" inherits="AuctionHouseCommoditiesListTemplate" hidden="true">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-auctions" type="string"/>
					<KeyValue key="textureWidthClassic" value="595" type="number"/>
					<KeyValue key="textureHeightClassic" value="315" type="number"/>
					<KeyValue key="searchContext" value="AuctionHouseSearchContext.AuctionsCommodities" type="global"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="133" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ItemList" relativePoint="TOPLEFT"/>
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.ItemList" relativePoint="BOTTOMRIGHT"/>
				</Anchors>
			</Frame>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseAuctionsFrame.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseCategoriesList.lua ---

function AuctionHouseFilterButton_SetUp(button, info)
	local normalText = button.Text;
	local normalTexture = button.NormalTexture;
	local line = button.Lines;

	if ( info.type == "category" ) then
		if (info.isToken) then
			button:SetNormalFontObject(GameFontNormalSmallBattleNetBlueLeft);
		else
			button:SetNormalFontObject(GameFontNormalSmall);
		end

		button.NormalTexture:SetTexture("Interface\\AuctionFrame\\UI-AuctionFrame-FilterBg");
		button.NormalTexture:SetTexCoord(0, 0.53125, 0, 0.625);
		button.NormalTexture:SetSize(136,20);
		button.NormalTexture:ClearAllPoints();
		button.NormalTexture:SetPoint("TOPLEFT", -2, 0);
		button.NormalTexture:SetAlpha(1.0);
		button.SelectedTexture:SetAtlas("auctionhouse-nav-button-select", false);
		button.SelectedTexture:SetSize(134,20);
		button.SelectedTexture:ClearAllPoints();
		button.SelectedTexture:SetPoint("LEFT");
		button.HighlightTexture:SetTexture("Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight");
		button.HighlightTexture:SetSize(132,21);
		button.HighlightTexture:ClearAllPoints();
		button.HighlightTexture:SetPoint("LEFT");
		button:SetText(info.name);
		normalText:SetPoint("LEFT", button, "LEFT", 8, 0);
		normalTexture:SetAlpha(1.0);	
		line:Hide();
	elseif ( info.type == "subCategory" ) then
		button:SetNormalFontObject(GameFontHighlightSmall);
		button.NormalTexture:SetTexture("Interface\\AuctionFrame\\UI-AuctionFrame-FilterBg");
		button.NormalTexture:SetTexCoord(0, 0.53125, 0, 0.625);
		button.NormalTexture:SetSize(128,20);
		button.NormalTexture:ClearAllPoints();
		button.NormalTexture:SetPoint("TOPLEFT", 6, 0);
		button.SelectedTexture:SetAtlas("auctionhouse-nav-button-secondary-select", false);
		button.SelectedTexture:SetSize(128,20);
		button.SelectedTexture:ClearAllPoints();
		button.SelectedTexture:SetPoint("TOPLEFT", 6, 0);
		button.HighlightTexture:SetTexture("Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight");
		button.HighlightTexture:SetSize(122,21);
		button.HighlightTexture:ClearAllPoints();
		button.HighlightTexture:SetPoint("TOPLEFT", 10, 0);
		button:SetText(info.name);
		normalText:SetPoint("LEFT", button, "LEFT", 18, 0);
		normalTexture:SetAlpha(1.0);
		line:Hide();
	elseif ( info.type == "subSubCategory" ) then
		button:SetNormalFontObject(GameFontHighlightSmall);
		button.NormalTexture:ClearAllPoints();
		button.NormalTexture:SetPoint("TOPLEFT", 14, 0);
		button.SelectedTexture:SetAtlas("auctionhouse-ui-row-select", false);
		button.SelectedTexture:SetSize(116,18);
		button.SelectedTexture:ClearAllPoints();
		button.SelectedTexture:SetPoint("TOPRIGHT",0,-2);
		button.HighlightTexture:SetAtlas("auctionhouse-ui-row-highlight", false);
		button.HighlightTexture:SetTexture("Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight");
		button.HighlightTexture:SetSize(116,18);
		button.HighlightTexture:ClearAllPoints();
		button.HighlightTexture:SetPoint("TOPRIGHT",0,-2);
		button:SetText(info.name);
		normalText:SetPoint("LEFT", button, "LEFT", 26, 0);
		normalTexture:SetAlpha(0.0);	
		line:Show();
	end
	button.type = info.type; 

	if ( info.type == "category" ) then
		button.categoryIndex = info.categoryIndex;
	elseif ( info.type == "subCategory" ) then
		button.subCategoryIndex = info.subCategoryIndex;
	elseif ( info.type == "subSubCategory" ) then
		button.subSubCategoryIndex = info.subSubCategoryIndex;
	end
	
	button.SelectedTexture:SetShown(info.selected);
end

--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseCategoriesList.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseCategoriesList.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Button name="AuctionCategoryButtonTemplate" parentArray="FilterButtons" inherits="TruncatedTooltipScriptTemplate" virtual="true">
		<Size x="132" y="21"/>
		<Layers>
			<Layer level="BACKGROUND">
				<Texture parentKey="Lines" atlas="auctionhouse-nav-button-tertiary-filterline" useAtlasSize="true">
					<Anchors>
						<Anchor point="LEFT" x="18" y="3"/>
					</Anchors>
				</Texture>
				<Texture parentKey="NormalTexture" file="Interface\AuctionFrame\UI-AuctionFrame-FilterBg">
					<Size x="136" y="20"/>
					<Anchors>
						<Anchor point="TOPLEFT" x="-2" y="0"/>
					</Anchors>
				</Texture>
			</Layer>
			<Layer level="BORDER">
				<Texture parentKey="HighlightTexture" file="Interface\PaperDollInfoFrame\UI-Character-Tab-Highlight" hidden="true" alphaMode="ADD">
					<Anchors>
						<Anchor point="CENTER"/>
					</Anchors>
				</Texture>
			</Layer>
			<Layer level="ARTWORK">
				<Texture parentKey="SelectedTexture" atlas="auctionhouse-nav-button-select" alphaMode="ADD" hidden="true">
					<Anchors>
						<Anchor point="TOPLEFT" relativeKey="$parent.NormalTexture" relativePoint="TOPLEFT"/>
						<Anchor point="BOTTOMRIGHT" relativeKey="$parent.NormalTexture" relativePoint="BOTTOMRIGHT"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad function="AuctionFrameFilter_OnLoad"/>
			<OnEnter function="AuctionFrameFilter_OnEnter"/>
			<OnLeave function="AuctionFrameFilter_OnLeave"/>
			<OnMouseDown function="AuctionFrameFilter_OnMouseDown"/>
			<OnMouseUp function="AuctionFrameFilter_OnMouseUp"/>
		</Scripts>
		<ButtonText parentKey="Text" justifyH="LEFT">
			<Size x="0" y="8"/>
			<Anchors>
				<Anchor point="LEFT" x="4" y="0"/>
				<Anchor point="RIGHT" x="-4" y="0"/>
			</Anchors>
			<Shadow>
				<Offset>
					<AbsDimension x="1" y="-1"/>
				</Offset>
				<Color r="0" g="0" b="0"/>
			</Shadow>
		</ButtonText>
		<NormalFont style="GameFontNormalSmall"/>
		<HighlightFont style="GameFontHighlightSmall"/>
	</Button>

	<Frame name="AuctionHouseCategoriesListTemplate" mixin="AuctionHouseCategoriesListMixin" virtual="true">
		<Size x="168" y="438"/>
		<KeyValues>
			<KeyValue key="layoutType" value="InsetFrameTemplate" type="string"/>
			<KeyValue key="backgroundAtlas" value="auctionhouse-background-categories" type="string"/>
			<KeyValue key="textureWidthClassic" value="138" type="number"/>
			<KeyValue key="textureHeightClassic" value="434" type="number"/>
		</KeyValues>
		<Frames>
			<Frame parentKey="NineSlice" useParentLevel="true" inherits="NineSlicePanelTemplate"/>

			<Frame parentKey="ScrollBox" inherits="WowScrollBoxList">
				<Anchors>
					<Anchor point="TOPLEFT" x="3" y="-6"/>
					<Anchor point="BOTTOMRIGHT" x="-25" y="2"/>
				</Anchors>
			</Frame>
			<EventFrame parentKey="ScrollBar" inherits="WowClassicScrollBar">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ScrollBox" relativePoint="TOPRIGHT" x="-2" y="5"/>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent.ScrollBox" relativePoint="BOTTOMRIGHT" x="7" y="-4"/>
				</Anchors>
			</EventFrame>
		</Frames>
		<Layers>
			<Layer level="BACKGROUND">
				<Texture parentKey="Background" file="Interface\QuestFrame\UI-TextBackground-BackdropBackground">
					<Anchors>
						<Anchor point="TOPLEFT" x="3" y="-2"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
			<Scripts>
				<OnLoad method="OnLoad"/>
				<OnShow method="OnShow"/>
			</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseCategoriesList.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseItemList.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	
	<Button name="AuctionHouseItemListLineTemplate" mixin="AuctionHouseItemListLineMixin" virtual="true">
		<Size x="0" y="20"/>
		<Anchors>
			<Anchor point="LEFT"/>
			<Anchor point="RIGHT"/>
		</Anchors>
		<Layers>
			<Layer level="OVERLAY">
				<Texture parentKey="SelectedHighlight" atlas="auctionhouse-ui-row-select" alphaMode="ADD" hidden="true"/>

				<!-- Using a normal texture for highlight to control the behavior. -->
				<Texture parentKey="HighlightTexture" atlas="auctionhouse-ui-row-highlight" alphaMode="ADD" setAllPoints="true" hidden="true"/>
			</Layer>
		</Layers>
		<Scripts>
			<OnClick method="OnClick"/>
			<OnEnter method="OnEnter"/>
			<OnLeave method="OnLeave"/>
		</Scripts>
		<NormalTexture parentKey="NormalTexture" atlas="auctionhouse-rowstripe-1" setAllPoints="true"/>
	</Button>

	<Button name="AuctionHouseFavoritableLineTemplate" mixin="AuctionHouseFavoritableLineMixin" inherits="AuctionHouseItemListLineTemplate" registerForClicks="LeftButtonUp, RightButtonUp" virtual="true"/>

	<Frame name="AuctionHouseItemListHeadersTemplate" virtual="true">
		<Size x="0" y="19"/>
	</Frame>

	<Frame name="AuctionHouseItemListTemplate" mixin="AuctionHouseItemListMixin" inherits="AuctionHouseBackgroundTemplate" virtual="true">
		<KeyValues>
			<!--
			hideStripes: Hides the normal texture that usually alternates each line, making all lines invisible.
			hideRefreshFrame: Hide the refresh frame.
			refreshFrameXOffset: The x offset (from the topright of the item list) for the refresh frame.
			refreshFrameYOffset: The y offset (from the topright of the item list) for the refresh frame.
			<KeyValue key="hideStripes" value="true" type="boolean"/>
			<KeyValue key="hideRefreshFrame" value="false" type="boolean"/>
			<KeyValue key="refreshFrameXOffset" value="0" type="number"/>
			<KeyValue key="refreshFrameYOffset" value="0" type="number"/>
			-->

			<KeyValue key="layoutType" value="InsetFrameTemplate" type="string"/>
			<KeyValue key="backgroundYOffset" value="-19" type="number"/>
			<KeyValue key="backgroundTextureClassic" value="Interface\FrameGeneral\UI-Background-Marble" type="string"/>
			<KeyValue key="textureXOffsetClassic" value="2" type="number"/>
			<KeyValue key="textureYOffsetClassic" value="-2" type="number"/>
		</KeyValues>
		<Frames>
			<Frame parentKey="RefreshFrame" inherits="AuctionHouseRefreshFrameTemplate">
				<Anchors>
					<Anchor point="TOPRIGHT"/>
				</Anchors>
			</Frame>

			<Frame parentKey="HeaderContainer" inherits="AuctionHouseItemListHeadersTemplate">
				<Anchors>
					<Anchor point="TOPLEFT" x="4" y="-1"/>
					<Anchor point="TOPRIGHT" x="-26" y="-1"/>
				</Anchors>
			</Frame>
			<Frame parentKey="ScrollBox" inherits="WowScrollBoxList">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.HeaderContainer" relativePoint="BOTTOMLEFT" x="0" y="-6"/>
					<Anchor point="RIGHT" relativeKey="$parent.HeaderContainer" relativePoint="RIGHT"/>
					<Anchor point="BOTTOM" x="0" y="3"/>
				</Anchors>
			</Frame>
			<EventFrame parentKey="ScrollBar" inherits="WowClassicScrollBar">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ScrollBox" relativePoint="TOPRIGHT" x="-3" y="25"/>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent.ScrollBox" relativePoint="BOTTOMRIGHT" x="7" y="-5"/>
				</Anchors>
			</EventFrame>
			<Frame parentKey="LoadingSpinner" inherits="SpinnerTemplate" hidden="true">
				<Size x="90" y="90"/>
				<Anchors>
					<Anchor point="CENTER" x="-12" y="-15"/>
				</Anchors>
				<Layers>
					<Layer level="OVERLAY">
						<FontString parentKey="SearchingText" inherits="GameFontNormalHuge4" text="SEARCHING">
							<Anchors>
								<Anchor point="BOTTOM" relativePoint="TOP" x="0" y="10"/>
							</Anchors>
						</FontString>
					</Layer>
				</Layers>
			</Frame>
		</Frames>
		<Layers>
			<Layer level="OVERLAY">
				<FontString parentKey="ResultsText" inherits="GameFontNormal" hidden="true">
					<Anchors>
						<Anchor point="TOP" relativeKey="$parent.ScrollBox" relativePoint="TOP" x="0" y="-45"/>
						<Anchor point="LEFT" x="45"/>
						<Anchor point="RIGHT" x="-67"/>
					</Anchors>
					<Color color="NORMAL_FONT_COLOR"/>
					<Shadow>
						<Offset>
							<AbsDimension x="1" y="-1"/>
						</Offset>
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnUpdate method="OnUpdate"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseItemList.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseMultisell.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Frame name="AuctionHouseMultisellProgressFrame" mixin="MultisellProgressFrameMixin" inherits="UIParentBottomManagedFrameTemplate" toplevel="true" parent="UIParent" enableMouse="true" hidden="true">
		<Size x="300" y="64"/>
		<KeyValues>
			<KeyValue key="layoutIndex" value="61" type="number"/>
		</KeyValues>
		<Layers>
			<Layer level="BACKGROUND">
				<Texture parentKey="Fill" file="Interface\AuctionFrame\UI-AuctionPost-Background">							
					<Anchors>
						<Anchor point="TOPLEFT" relativeKey="$parent" relativePoint="TOPLEFT" x="12" y="-8"/>
						<Anchor point="BOTTOMRIGHT" relativeKey="$parent" relativePoint="BOTTOMRIGHT" x="-12" y="8"/>
					</Anchors>
					<TexCoords left="0" right="1" top="0.25" bottom="0.75" />
					<Color r="0.55" g="0.55" b="0.55" />
				</Texture>
			</Layer>
			<Layer level="ARTWORK">
				<Texture parentKey="Left" file="Interface\AuctionFrame\UI-AuctionPost-Endcaps">
					<Size x="32" y="64"/>
					<Anchors>
						<Anchor point="LEFT"/>
					</Anchors>
					<TexCoords left="0.5" right="1" top="0" bottom="1" />
					<Color r="0.75" g="0.75" b="0.75" />
				</Texture>
				<Texture parentKey="Right" file="Interface\AuctionFrame\UI-AuctionPost-Endcaps">
					<Size x="32" y="64"/>
					<Anchors>
						<Anchor point="RIGHT"/>
					</Anchors>
					<TexCoords left="0" right="0.5" top="0" bottom="1" />
					<Color r="0.75" g="0.75" b="0.75" />
				</Texture>
				<Texture parentKey="Middle" file="Interface\AuctionFrame\UI-AuctionPost-Middle">
					<Anchors>
						<Anchor point="RIGHT" relativeKey="$parent.Right" relativePoint="LEFT" />
						<Anchor point="LEFT" relativeKey="$parent.Left" relativePoint="RIGHT" />
					</Anchors>
					<Color r="0.75" g="0.75" b="0.75" />
				</Texture>
			</Layer>
		</Layers>
		<Frames>
			<StatusBar parentKey="ProgressBar" inherits="CastingBarFrameTemplate">
				<Size x="195" y="11"/>
				<Anchors>
					<Anchor point="CENTER" relativeKey="$parent" x="3" y="5"/>
				</Anchors>
				<Scripts>
					<OnLoad>
						self.holdTime = 0;
						self.Spark:Hide();
						self.Flash:Hide();
						self.Icon:Show();
						self.Icon:SetWidth(24);
						self.Icon:SetHeight(24);
						self.Icon:SetPoint("RIGHT", self, "LEFT", -10, -6);
					</OnLoad>

					<!-- Override the scripts from the template, as this behavior is not desired. >
					<OnEvent></OnEvent>
					<OnShow></OnShow>
					<OnUpdate></OnUpdate>
					< Override the scripts from the template, as this behavior is not desired. -->
				</Scripts>
			</StatusBar>
			<Button parentKey="CancelButton">
				<Size x="32" y="32"/>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.ProgressBar" relativePoint="RIGHT" x="2" y="-7"/>
				</Anchors>
				<HitRectInsets left="9" right="7" top="-7" bottom="10"/>
				<Scripts>
					<OnClick>
						C_AuctionHouse.CancelSell();
					</OnClick>
				</Scripts>
				<NormalTexture file="Interface\Buttons\CancelButton-Up"/>
				<PushedTexture file="Interface\Buttons\CancelButton-Down"/>
				<HighlightTexture file="Interface\Buttons\CancelButton-Highlight" alphaMode="ADD"/>
			</Button>
		</Frames>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseMultisell.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseSharedTemplates.lua ---

AuctionHouseBackgroundMixin = {};

function AuctionHouseBackgroundMixin:OnLoad()
	local xOffset = self.backgroundXOffset or 0;
	local yOffset = self.backgroundYOffset or 0;

	AuctionHouseUtil.ApplyClassicBackgroundOffset(self);
	AuctionHouseUtil.ApplyClassicBackgroundTexture(self);

	self.NineSlice:ClearAllPoints();
	self.NineSlice:SetPoint("TOPLEFT", xOffset, yOffset);
	self.NineSlice:SetPoint("BOTTOMRIGHT");
end

function AuctionHouseItemDisplayMixin:OnEnter()
	self:SetScript("OnUpdate", AuctionHouseItemDisplayMixin.OnUpdate);

	if IsModifiedClick("DRESSUP") then
		ShowInspectCursor();
	end

	if self:IsPet() then
		if self.itemKey then
			local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(self.itemKey);
			if itemKeyInfo and itemKeyInfo.battlePetLink then
				GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
				BattlePetToolTip_ShowLink(itemKeyInfo.battlePetLink);
				AuctionHouseUtil.AppendBattlePetVariationLines(BattlePetTooltip);
			else
				if(BattlePetTooltip) then
					BattlePetTooltip:Hide();
				end
				GameTooltip:Hide();
			end
		else
			local itemLocation = self:GetItemLocation();
			if itemLocation then
				local bagID, slotIndex = itemLocation:GetBagAndSlot();
				if bagID and slotIndex then
					GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
					GameTooltip:SetBagItem(bagID, slotIndex);
				end
			end
		end
	else
		if(BattlePetTooltip) then
			BattlePetTooltip:Hide();
		end

		local itemLocation = self:GetItemLocation();
		if itemLocation then
			GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
			GameTooltip:SetHyperlink(C_Item.GetItemLink(itemLocation));
			GameTooltip:Show();
		else
			local itemKey = self:GetItemKey();
			if itemKey then
				GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
				GameTooltip:SetItemKey(itemKey.itemID, itemKey.itemLevel, itemKey.itemSuffix, C_AuctionHouse.GetItemKeyRequiredLevel(itemKey));
				GameTooltip:Show();
			else
				local itemLink = self:GetItemLink();
				if itemLink then
					GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
					GameTooltip:SetHyperlink(itemLink);
					GameTooltip:Show();
				end
			end
		end

		self.ItemButton.UpdateTooltip = self.ItemButton:GetScript("OnEnter");
	end
end


--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseSharedTemplates.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseSharedTemplates.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	<Button name="AuctionHouseItemDisplayTemplate" inherits="AuctionHouseItemDisplayBaseTemplate" virtual="true">
		<Frames>
			<Button parentKey="ItemButton" mixin="AuctionHouseItemDisplayItemButtonMixin" inherits="GiantItemButtonTemplate">
				<Scripts>
					<OnLoad method="OnLoad"/>
					<OnClick method="OnClick"/>
					<OnEnter method="OnEnter"/>
					<OnLeave method="OnLeave"/>
				</Scripts>
			</Button>
			<Button parentKey="FavoriteButton" inherits="AuctionHouseFavoriteButtonBaseTemplate">
				<Anchors>
					<Anchor point="TOPRIGHT" relativePoint="TOPRIGHT" x="-6" y="-6"/>
				</Anchors>
			</Button>
		</Frames>
		<Layers>
			<Layer level="ARTWORK">
				<FontString parentKey="Name" inherits="SystemFont_Shadow_Large2" justifyH="LEFT">
					<Size x="0" y="64"/>
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.ItemButton" relativePoint="RIGHT" x="11" y="1"/>
						<Anchor point="RIGHT" relativeKey="$parent" relativePoint="RIGHT" x="-31" y="1"/>
					</Anchors>
					<Shadow x="1" y="-1">
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
			</Layer>
		</Layers>
	</Button>

	<EventFrame name="DummyAuctionHouseScrollBarTemplate" inherits="WowClassicScrollBar" virtual="true">
		<Anchors>
			<Anchor point="TOPLEFT" relativePoint="TOPRIGHT" x="-7" y="0"/>
			<Anchor point="BOTTOMLEFT" relativePoint="BOTTOMRIGHT" x="0" y="-2"/>
		</Anchors>
	</EventFrame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseSharedTemplates.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseTab.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Button name="AuctionHouseFrameTabTemplate" inherits="CharacterFrameTabButtonTemplate" parentArray="Tabs" mixin="AuctionHouseFrameTabMixin" virtual="true">
		<Scripts>
			<OnShow method="OnShow"/>
		</Scripts>
	</Button>

	<Button name="AuctionHouseFrameTopTabTemplate" inherits="PanelTopTabButtonTemplate" mixin="AuctionHouseFrameTopTabMixin" virtual="true">
		<Scripts>
			<OnShow method="OnShow"/>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>

	<Button name="AuctionHouseFrameDisplayModeTabTemplate" mixin="AuctionHouseFrameDisplayModeTabMixin" inherits="AuctionHouseFrameTabTemplate" virtual="true">
		<!--
		displayMode: The display mode to set on the auction house frame on click.
		<KeyValues>
			<KeyValue key="displayMode" value="AuctionHouseFrameDisplayMode.Sell" type="global"/>
		</KeyValues>
		-->
		<Scripts>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseTab.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseUtil.lua ---

local function GetQualityFilterString(itemQuality)
	local hex = select(4, C_Item.GetItemQualityColor(itemQuality));
	local text = _G["ITEM_QUALITY"..itemQuality.."_DESC"];
	return "|c"..hex..text.."|r";
end

AUCTION_HOUSE_FILTER_STRINGS = {
	[Enum.AuctionHouseFilter.UncollectedOnly] = AUCTION_HOUSE_FILTER_UNCOLLECTED_ONLY,
	[Enum.AuctionHouseFilter.UsableOnly] = AUCTION_HOUSE_FILTER_USABLE_ONLY,
	[Enum.AuctionHouseFilter.PoorQuality] = GetQualityFilterString(Enum.ItemQuality.Poor),
	[Enum.AuctionHouseFilter.CommonQuality] = GetQualityFilterString(Enum.ItemQuality.Standard),
	[Enum.AuctionHouseFilter.UncommonQuality] = GetQualityFilterString(Enum.ItemQuality.Good),
	[Enum.AuctionHouseFilter.RareQuality] = GetQualityFilterString(Enum.ItemQuality.Rare),
	[Enum.AuctionHouseFilter.EpicQuality] = GetQualityFilterString(Enum.ItemQuality.Epic),
	[Enum.AuctionHouseFilter.LegendaryQuality] = GetQualityFilterString(Enum.ItemQuality.Legendary),
};

AUCTION_HOUSE_DEFAULT_FILTERS = {
	[Enum.AuctionHouseFilter.UncollectedOnly] = false,
	[Enum.AuctionHouseFilter.UsableOnly] = false,
	[Enum.AuctionHouseFilter.PoorQuality] = true,
	[Enum.AuctionHouseFilter.CommonQuality] = true,
	[Enum.AuctionHouseFilter.UncommonQuality] = true,
	[Enum.AuctionHouseFilter.RareQuality] = true,
	[Enum.AuctionHouseFilter.EpicQuality] = true,
	[Enum.AuctionHouseFilter.LegendaryQuality] = true,
};

local AUCTION_HOUSE_FILTER_CATEGORY_STRINGS = {
	[Enum.AuctionHouseFilterCategory.Uncategorized] = "",
	[Enum.AuctionHouseFilterCategory.Rarity] = AUCTION_HOUSE_FILTER_CATEGORY_RARITY,
};

function GetAHFilterCategoryName(category)
	return AUCTION_HOUSE_FILTER_CATEGORY_STRINGS[category] or "";
end

function AuctionHouseUtil.GetItemDisplayCraftingQualityIconFromItemKey(itemKey)
	--Classic does not have this concept
	return nil;
end

local AuctionHouseTooltipType = {
	BucketPetLink = 1,
	ItemLink = 2,
	ItemKey = 3,
	SpecificPetLink = 4,
};

local function GetAuctionHouseTooltipType(rowData)
	if rowData.itemLink then
		local linkType = LinkUtil.ExtractLink(rowData.itemLink);
		if linkType == "battlepet" then
			return AuctionHouseTooltipType.SpecificPetLink, rowData.itemLink;
		elseif linkType == "item" then
			return AuctionHouseTooltipType.ItemLink, rowData.itemLink;
		end
	elseif rowData.itemKey then
		local restrictQualityToFilter = true;
		local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(rowData.itemKey, restrictQualityToFilter);
		if itemKeyInfo and itemKeyInfo.battlePetLink then
			return AuctionHouseTooltipType.BucketPetLink, itemKeyInfo.battlePetLink;
		end

		return AuctionHouseTooltipType.ItemKey, rowData.itemKey;
	end

	return nil;
end

function AuctionHouseUtil.SetAuctionHouseTooltip(owner, rowData)
	GameTooltip_Hide();

	local tooltip = nil;

	local tooltipType, data = GetAuctionHouseTooltipType(rowData);
	if not tooltipType then
		return;
	end

	GameTooltip:SetOwner(owner, "ANCHOR_RIGHT");
	
	if tooltipType == AuctionHouseTooltipType.BucketPetLink or tooltipType == AuctionHouseTooltipType.SpecificPetLink then
		BattlePetToolTip_ShowLink(data);
		tooltip = BattlePetTooltip;
	else
		tooltip = GameTooltip;
		if tooltipType == AuctionHouseTooltipType.ItemLink then
			local hideVendorPrice = true;
			GameTooltip:SetHyperlink(rowData.itemLink, nil, nil, hideVendorPrice);
		elseif tooltipType == AuctionHouseTooltipType.ItemKey then
			GameTooltip:SetItemKey(data.itemID, data.itemLevel, data.itemSuffix, C_AuctionHouse.GetItemKeyRequiredLevel(data));
		end
	end

	if rowData.owners then
		local methodFound, auctionHouseFrame = CallMethodOnNearestAncestor(owner, "GetAuctionHouseFrame");
		local bidStatus = auctionHouseFrame and auctionHouseFrame:GetBidStatus(rowData) or nil;
		AuctionHouseUtil.AddAuctionHouseTooltipInfo(tooltip, rowData, bidStatus);
	end

	if tooltipType == AuctionHouseTooltipType.BucketPetLink then
		AuctionHouseUtil.AppendBattlePetVariationLines(tooltip);
	end

	if tooltip == GameTooltip then
		GameTooltip:Show();
	end
end

function AuctionHouseUtil.ApplyClassicBackgroundTexture(frame)
	local textureWidth = frame.textureWidthClassic or 0;
	local textureHeight = frame.textureHeightClassic or 0;
	frame.Background:SetSize(textureWidth, textureHeight);

	if (frame.backgroundTextureClassic) then
		frame.Background:SetTexture(frame.backgroundTextureClassic);
	end
end

function AuctionHouseUtil.ApplyClassicBackgroundOffset(frame)
	local textureXOffset = frame.textureXOffsetClassic or 0;
	local textureYOffset = frame.textureYOffsetClassic or 0;
	local xOffset = frame.backgroundXOffset or 0;
	local yOffset = frame.backgroundYOffset or 0;

	frame.Background:SetPoint("TOPLEFT", textureXOffset + xOffset, textureYOffset + yOffset );
end

function AuctionHouseUtil.ApplyClassicScrollbarOffset(frame)
	if(frame.scrollbarYOffsetClassic) then
		local point, relativeFrame, relativePoint, offsetX, offsetY = frame.ScrollBar:GetPoint();
		frame.ScrollBar:SetPoint(point, relativeFrame, relativePoint, offsetX, offsetY + frame.scrollbarYOffsetClassic);
	end
end

--- END OF FILE: Blizzard_AuctionHouseUI\Classic\Blizzard_AuctionHouseUtil.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionData.lua ---

PRICE_DISPLAY_WIDTH = 120;
PRICE_DISPLAY_WITH_CHECKMARK_WIDTH = 140;

function AuctionCategoryMixin:AddBulkInventoryTypeCategories(classID, subClassID, inventoryTypes)
	local inventoryTypeNone = nil;
	local useParentFilters = true;
	self:CreateSubCategoryAndFilter(classID, subClassID, inventoryTypeNone, Enum.AuctionHouseFilter.LegendaryCraftedItemOnly, useParentFilters);

	for _, inventoryType in ipairs(inventoryTypes) do
		self:CreateSubCategoryAndFilter(classID, subClassID, inventoryType);
	end
end

do -- Weapons
	local weaponsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_WEAPONS);
	weaponsCategory:SetDetailColumnString(ITEM_LEVEL_ABBR);

	local oneHandedCategory = weaponsCategory:CreateNamedSubCategory(AUCTION_SUBCATEGORY_ONE_HANDED);
	oneHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Axe1H);
	oneHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Mace1H);
	oneHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Sword1H);

	oneHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Warglaive);
	oneHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Dagger);
	oneHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Unarmed);
	oneHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Wand);

	local twoHandedCategory = weaponsCategory:CreateNamedSubCategory(AUCTION_SUBCATEGORY_TWO_HANDED);
	twoHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Axe2H);
	twoHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Mace2H);
	twoHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Sword2H);

	twoHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Polearm);
	twoHandedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Staff);

	local rangedCategory = weaponsCategory:CreateNamedSubCategory(AUCTION_SUBCATEGORY_RANGED);
	rangedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Bows);
	rangedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Crossbow);
	rangedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Guns);
	rangedCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Thrown);
	
	local miscCategory = weaponsCategory:CreateNamedSubCategory(AUCTION_SUBCATEGORY_MISCELLANEOUS);
	miscCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Fishingpole);

	local otherCategory = miscCategory:CreateNamedSubCategory(AUCTION_SUBCATEGORY_OTHER);
	otherCategory:AddFilter(Enum.ItemClass.Weapon, Enum.ItemWeaponSubclass.Generic);
end

do -- Armor
	local ArmorInventoryTypes = {
		Enum.InventoryType.IndexHeadType,
		Enum.InventoryType.IndexShoulderType,
		Enum.InventoryType.IndexChestType,
		Enum.InventoryType.IndexWaistType,
		Enum.InventoryType.IndexLegsType,
		Enum.InventoryType.IndexFeetType,
		Enum.InventoryType.IndexWristType,
		Enum.InventoryType.IndexHandType,
	};

	local armorCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_ARMOR);
	armorCategory:SetDetailColumnString(ITEM_LEVEL_ABBR);

	local plateCategory = armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Plate);
	plateCategory:AddBulkInventoryTypeCategories(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Plate, ArmorInventoryTypes);

	local plateChestCategory = plateCategory:FindSubCategoryByName(C_Item.GetItemInventorySlotInfo(Enum.InventoryType.IndexChestType));
	plateChestCategory:AddFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Plate, Enum.InventoryType.IndexRobeType);

	local mailCategory = armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Mail);
	mailCategory:AddBulkInventoryTypeCategories(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Mail, ArmorInventoryTypes);
	
	local mailChestCategory = mailCategory:FindSubCategoryByName(C_Item.GetItemInventorySlotInfo(Enum.InventoryType.IndexChestType));
	mailChestCategory:AddFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Mail, Enum.InventoryType.IndexRobeType);

	local leatherCategory = armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Leather);
	leatherCategory:AddBulkInventoryTypeCategories(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Leather, ArmorInventoryTypes);

	local leatherChestCategory = leatherCategory:FindSubCategoryByName(C_Item.GetItemInventorySlotInfo(Enum.InventoryType.IndexChestType));
	leatherChestCategory:AddFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Leather, Enum.InventoryType.IndexRobeType);

	local clothCategory = armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Cloth);
	clothCategory:AddBulkInventoryTypeCategories(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Cloth, ArmorInventoryTypes);

	local clothChestCategory = clothCategory:FindSubCategoryByName(C_Item.GetItemInventorySlotInfo(Enum.InventoryType.IndexChestType));
	clothChestCategory:AddFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Cloth, Enum.InventoryType.IndexRobeType);

	local miscCategory = armorCategory:CreateSubCategory(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic);

	local useParentFilters = true;
	miscCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic, nil, Enum.AuctionHouseFilter.LegendaryCraftedItemOnly, useParentFilters);

	miscCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic, Enum.InventoryType.IndexNeckType);

	miscCategory:CreateNamedSubCategoryAndFilter(AUCTION_SUBCATEGORY_CLOAK, Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Cloth, Enum.InventoryType.IndexCloakType);
	miscCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic, Enum.InventoryType.IndexFingerType);
	miscCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic, Enum.InventoryType.IndexTrinketType);
	miscCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic, Enum.InventoryType.IndexHoldableType);
	miscCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Shield);
	miscCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic, Enum.InventoryType.IndexBodyType);
	miscCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Generic, Enum.InventoryType.IndexHeadType);

	local cosmeticCategory = armorCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Armor, Enum.ItemArmorSubclass.Cosmetic);
end

do -- Containers
	local containersCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_CONTAINERS);
	containersCategory:SetDetailColumnString(AUCTION_HOUSE_BROWSE_HEADER_CONTAINER_SLOTS);
	containersCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Container);
end

do -- Gems
	local gemsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_GEMS);
	gemsCategory:SetDetailColumnString(ITEM_LEVEL_ABBR);
	gemsCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Gem);
end

do -- Item Enhancement
	local itemEnhancementCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_ITEM_ENHANCEMENT);
	itemEnhancementCategory:SetDetailColumnString(ITEM_LEVEL_ABBR);
	itemEnhancementCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.ItemEnhancement);
end

do -- Consumables
	local consumablesCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_CONSUMABLES);
	consumablesCategory:SetDetailColumnString(AUCTION_HOUSE_BROWSE_HEADER_REQUIRED_LEVEL);
	consumablesCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Consumable);
end

do -- Glyphs
	local glyphsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_GLYPHS);
	glyphsCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Glyph);
end

do -- Trade Goods
	local tradeGoodsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_TRADE_GOODS);
	tradeGoodsCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Tradegoods);
end

do -- Recipes
	local recipesCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_RECIPES);
	recipesCategory:SetDetailColumnString(AUCTION_HOUSE_BROWSE_HEADER_RECIPE_SKILL);

	recipesCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Recipe);

	local bookCategory = recipesCategory:FindSubCategoryByName(C_Item.GetItemSubClassInfo(Enum.ItemClass.Recipe, Enum.ItemRecipeSubclass.Book));
	if bookCategory then
		bookCategory:SetSortIndex(100);
	end

	recipesCategory:SortSubCategories();
end

do -- Profession Equipment
	local professionEquipmentCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_PROFESSION_EQUIPMENT);
	professionEquipmentCategory:SetDetailColumnString(ITEM_LEVEL_ABBR);

	local ProfessionGearSubclasses = {
		Enum.ItemProfessionSubclass.Inscription,
		Enum.ItemProfessionSubclass.Tailoring,
		Enum.ItemProfessionSubclass.Leatherworking,
		Enum.ItemProfessionSubclass.Jewelcrafting,
		Enum.ItemProfessionSubclass.Alchemy,
		Enum.ItemProfessionSubclass.Blacksmithing,
		Enum.ItemProfessionSubclass.Engineering,
		Enum.ItemProfessionSubclass.Enchanting,
		Enum.ItemProfessionSubclass.Mining,
		Enum.ItemProfessionSubclass.Herbalism,
		Enum.ItemProfessionSubclass.Skinning,
		Enum.ItemProfessionSubclass.Cooking,
		Enum.ItemProfessionSubclass.Fishing,
	};

	for _, subclass in ipairs(ProfessionGearSubclasses) do
		local newCategory = professionEquipmentCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Profession, subclass);
		newCategory:CreateNamedSubCategoryAndFilter(AUCTION_SUBCATEGORY_PROFESSION_TOOLS, Enum.ItemClass.Profession, subclass, Enum.InventoryType.IndexProfessionToolType);
		newCategory:CreateNamedSubCategoryAndFilter(AUCTION_SUBCATEGORY_PROFESSION_ACCESSORIES, Enum.ItemClass.Profession, subclass, Enum.InventoryType.IndexProfessionGearType);
	end
end

do -- Battle Pets
	local battlePetsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_BATTLE_PETS);
	battlePetsCategory:SetDetailColumnString(AUCTION_HOUSE_BROWSE_HEADER_PET_LEVEL);

	battlePetsCategory:GenerateSubCategoriesAndFiltersFromSubClass(Enum.ItemClass.Battlepet);
	battlePetsCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.CompanionPet);
end

do -- Quest Items
	local questItemsCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_QUEST_ITEMS);
	questItemsCategory:AddFilter(Enum.ItemClass.Questitem);
end

do -- Miscellaneous
	local miscellaneousCategory = AuctionFrame_CreateCategory(AUCTION_CATEGORY_MISCELLANEOUS);
	miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Junk);
	miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Reagent);
	miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Holiday);
	miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Other);
	miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.Mount);
	miscellaneousCategory:CreateSubCategoryAndFilter(Enum.ItemClass.Miscellaneous, Enum.ItemMiscellaneousSubclass.MountEquipment);
end

do -- WoW Token
	local wowTokenCategory = AuctionFrame_CreateCategory(TOKEN_FILTER_LABEL);
	wowTokenCategory:AddFilter(ITEM_CLASS_WOW_TOKEN);
	wowTokenCategory:SetFlag("WOW_TOKEN_FLAG");
end


--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionData.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseAuctionsFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Button name="AuctionHouseAuctionsFrameTabTemplate" mixin="AuctionHouseAuctionsFrameTabMixin" inherits="AuctionHouseFrameTopTabTemplate" virtual="true">
		<Scripts>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>

	<Button name="AuctionHouseAuctionsSummaryLineTemplate" mixin="AuctionHouseAuctionsSummaryLineMixin" inherits="TruncatedTooltipScriptTemplate" virtual="true">
		<Size x="0" y="21"/>
		<Layers>
			<Layer level="BACKGROUND">
				<FontString parentKey="Text" inherits="GameFontNormal" justifyH="LEFT" wordwrap="false">
					<Anchors>
						<Anchor point="LEFT" x="4" y="0"/>
						<Anchor point="RIGHT" x="-4" y="0"/>
					</Anchors>
				</FontString>
			</Layer>
			<Layer level="BORDER">
				<Texture parentKey="Icon">
					<Size x="14" y="14"/>
					<Anchors>
						<Anchor point="LEFT" x="4" y="0"/>
					</Anchors>
				</Texture>
			</Layer>
			<Layer level="ARTWORK">
				<Texture parentKey="IconBorder" atlas="auctionhouse-itemicon-small-border" useAtlasSize="false">
					<Size x="16" y="16"/>
					<Anchors>
						<Anchor point="CENTER" relativeKey="$parent.Icon"/>
					</Anchors>
				</Texture>
			</Layer>
			<Layer level="OVERLAY">
				<Texture parentKey="SelectedHighlight" atlas="auctionhouse-ui-row-select" alpha=".8" hidden="true" alphaMode="ADD"/>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnEvent method="OnEvent"/>
			<OnHide method="OnHide"/>
		</Scripts>
		<HighlightTexture parentKey="HighlightTexture" atlas="auctionhouse-ui-row-highlight" useAtlasSize="false" alphaMode="ADD">
			<Anchors>
				<Anchor point="TOPLEFT" relativePoint="TOPLEFT" x="0" y="0"/>
				<Anchor point="BOTTOMRIGHT" relativePoint="BOTTOMRIGHT" x="0" y="0"/>
			</Anchors>
		</HighlightTexture>
	</Button>

	<Frame name="AuctionHouseAuctionsFrameTemplate" mixin="AuctionHouseAuctionsFrameMixin" virtual="true">
		<Frames>
			<Button name="$parentAuctionsTab" parentKey="AuctionsTab" id="1" inherits="AuctionHouseAuctionsFrameTabTemplate" frameLevel="300" text="AUCTION_HOUSE_AUCTIONS_SUB_TAB">
				<Anchors>
					<Anchor point="TOPLEFT" x="47" y="-1"/>
				</Anchors>
			</Button>

			<Button name="$parentBidsTab" parentKey="BidsTab" id="2" inherits="AuctionHouseAuctionsFrameTabTemplate" useParentLevel="true" text="AUCTION_HOUSE_BIDS_SUB_TAB"/>

			<Button parentKey="CancelAuctionButton" mixin="CancelAuctionButtonMixin" inherits="UIPanelButtonTemplate" text="AUCTION_HOUSE_CANCEL_AUCTION_BUTTON">
				<Size x="158" y="22"/>
				<Anchors>
					<Anchor point="BOTTOMRIGHT" x="-3" y="-22"/>
				</Anchors>
				<Scripts>
					<OnClick method="OnClick"/>
				</Scripts>
			</Button>

			<Frame parentKey="BuyoutFrame" inherits="AuctionHouseBuyoutFrameTemplate">
				<Anchors>
					<Anchor point="RIGHT" relativeKey="$parent.CancelAuctionButton" relativePoint="RIGHT"/>
				</Anchors>
			</Frame>

			<Frame parentKey="BidFrame" inherits="AuctionHouseBidFrameTemplate">
				<Anchors>
					<Anchor point="RIGHT" relativeKey="$parent.BuyoutFrame" relativePoint="LEFT" x="-60" y="0"/>
				</Anchors>
			</Frame>

			<Frame parentKey="SummaryList" inherits="AuctionHouseBackgroundTemplate" mixin="AuctionHouseAuctionsSummaryListMixin" useParentLevel="true">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-summarylist" type="string"/>
				</KeyValues>
				<Size x="168" y="0"/>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.AuctionsTab" relativePoint="BOTTOM" x="0" y="2"/>
					<Anchor point="BOTTOM" relativeKey="$parent.CancelAuctionButton" relativePoint="TOP"/>
					<Anchor point="LEFT" x="-1"/>
				</Anchors>
				<Frames>
					<Frame parentKey="ScrollBox" inherits="WowScrollBoxList">
						<Size x="148" y="0"/>
						<Anchors>
							<Anchor point="TOPLEFT" x="3" y="-3"/>
							<Anchor point="BOTTOMRIGHT" x="-27" y="3"/>
						</Anchors>
					</Frame>
					<EventFrame parentKey="ScrollBar" inherits="MinimalScrollBar">
						<Anchors>
							<Anchor point="TOPLEFT" relativeKey="$parent.ScrollBox" relativePoint="TOPRIGHT" x="8" y="-3"/>
							<Anchor point="BOTTOMLEFT" relativeKey="$parent.ScrollBox" relativePoint="BOTTOMRIGHT" x="8" y="3"/>
						</Anchors>
					</EventFrame>
				</Frames>
				<Scripts>
					<OnLoad method="OnLoad"/>
				</Scripts>
			</Frame>

			<Button parentKey="ItemDisplay" inherits="AuctionHouseItemDisplayTemplate" hidden="true">
				<KeyValues>
					<KeyValue key="itemButtonXOffset" value="22" type="number"/>
					<KeyValue key="itemButtonYOffset" value="-2" type="number"/>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-buy-noncommodities-header" type="string"/>
				</KeyValues>
				<Size x="623" y="86"/>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.AuctionsTab" relativePoint="BOTTOM" y="2"/>
					<Anchor point="LEFT" relativeKey="$parent.SummaryList" relativePoint="RIGHT" x="0"/>
				</Anchors>
			</Button>

			<Frame parentKey="AllAuctionsList" inherits="AuctionHouseItemListTemplate">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-index" type="string"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="34" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.SummaryList" relativePoint="TOP" x="0" y="-1"/>
					<Anchor point="LEFT" relativeKey="$parent.SummaryList" relativePoint="RIGHT" x="0" y="0"/>
					<Anchor point="RIGHT" x="-5" y="0"/>
					<Anchor point="BOTTOM" relativeKey="$parent.SummaryList" relativePoint="BOTTOM"/>
				</Anchors>
			</Frame>

			<Frame parentKey="BidsList" inherits="AuctionHouseItemListTemplate">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-index" type="string"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="34" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.AllAuctionsList" relativePoint="TOPLEFT"/>
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.AllAuctionsList" relativePoint="BOTTOMRIGHT"/>
				</Anchors>
			</Frame>

			<Frame parentKey="ItemList" inherits="AuctionHouseItemListTemplate" hidden="true">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-auctions" type="string"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="133" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.ItemDisplay" relativePoint="BOTTOM" x="0" y="-14"/>
					<Anchor point="LEFT" relativeKey="$parent.ItemDisplay" relativePoint="LEFT" x="0" y="0"/>
					<Anchor point="RIGHT" relativeKey="$parent.AllAuctionsList" relativePoint="RIGHT"/>
					<Anchor point="BOTTOM" relativeKey="$parent.SummaryList" relativePoint="BOTTOM"/>
				</Anchors>
			</Frame>

			<Frame parentKey="CommoditiesList" inherits="AuctionHouseCommoditiesListTemplate" hidden="true">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-auctions" type="string"/>
					<KeyValue key="searchContext" value="AuctionHouseSearchContext.AuctionsCommodities" type="global"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="133" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ItemList" relativePoint="TOPLEFT"/>
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.ItemList" relativePoint="BOTTOMRIGHT"/>
				</Anchors>
			</Frame>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseAuctionsFrame.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseCategoriesList.lua ---

function AuctionHouseFilterButton_SetUp(button, info)
	local normalText = button.Text;
	local normalTexture = button.NormalTexture;
	local line = button.Lines;

	if ( info.type == "category" ) then
		if (info.isToken) then
			button:SetNormalFontObject(GameFontNormalSmallBattleNetBlueLeft);
		else
			button:SetNormalFontObject(GameFontNormalSmall);
		end

		button.NormalTexture:SetAtlas("auctionhouse-nav-button", false);
		button.NormalTexture:SetSize(136,32);
		button.NormalTexture:ClearAllPoints();
		button.NormalTexture:SetPoint("TOPLEFT", -2, 0);
		button.SelectedTexture:SetAtlas("auctionhouse-nav-button-select", false);
		button.SelectedTexture:SetSize(132,21);
		button.SelectedTexture:ClearAllPoints();
		button.SelectedTexture:SetPoint("LEFT");
		button.HighlightTexture:SetAtlas("auctionhouse-nav-button-highlight", false);
		button.HighlightTexture:SetSize(132,21);
		button.HighlightTexture:ClearAllPoints();
		button.HighlightTexture:SetPoint("LEFT");
		button.HighlightTexture:SetBlendMode("BLEND");
		button:SetText(info.name);
		normalText:SetPoint("LEFT", button, "LEFT", 8, 0);
		normalTexture:SetAlpha(1.0);	
		line:Hide();
	elseif ( info.type == "subCategory" ) then
		button:SetNormalFontObject(GameFontHighlightSmall);
		button.NormalTexture:SetAtlas("auctionhouse-nav-button-secondary", false);
		button.NormalTexture:SetSize(133,32);
		button.NormalTexture:ClearAllPoints();
		button.NormalTexture:SetPoint("TOPLEFT", 1, 0);
		button.SelectedTexture:SetAtlas("auctionhouse-nav-button-secondary-select", false);
		button.SelectedTexture:SetSize(122,21);
		button.SelectedTexture:ClearAllPoints();
		button.SelectedTexture:SetPoint("TOPLEFT", 10, 0);
		button.HighlightTexture:SetAtlas("auctionhouse-nav-button-secondary-highlight", false);
		button.HighlightTexture:SetSize(122,21);
		button.HighlightTexture:ClearAllPoints();
		button.HighlightTexture:SetPoint("TOPLEFT", 10, 0);
		button.HighlightTexture:SetBlendMode("BLEND");
		button:SetText(info.name);
		normalText:SetPoint("LEFT", button, "LEFT", 18, 0);
		normalTexture:SetAlpha(1.0);
		line:Hide();
	elseif ( info.type == "subSubCategory" ) then
		button:SetNormalFontObject(GameFontHighlightSmall);
		button.NormalTexture:ClearAllPoints();
		button.NormalTexture:SetPoint("TOPLEFT", 10, 0);
		button.SelectedTexture:SetAtlas("auctionhouse-ui-row-select", false);
		button.SelectedTexture:SetSize(116,18);
		button.SelectedTexture:ClearAllPoints();
		button.SelectedTexture:SetPoint("TOPRIGHT",0,-2);		
		button.HighlightTexture:SetAtlas("auctionhouse-ui-row-highlight", false);
		button.HighlightTexture:SetSize(116,18);
		button.HighlightTexture:ClearAllPoints();
		button.HighlightTexture:SetPoint("TOPRIGHT",0,-2);
		button.HighlightTexture:SetBlendMode("ADD");
		button:SetText(info.name);
		normalText:SetPoint("LEFT", button, "LEFT", 26, 0);
		normalTexture:SetAlpha(0.0);	
		line:Show();
	end
	button.type = info.type; 

	if ( info.type == "category" ) then
		button.categoryIndex = info.categoryIndex;
	elseif ( info.type == "subCategory" ) then
		button.subCategoryIndex = info.subCategoryIndex;
	elseif ( info.type == "subSubCategory" ) then
		button.subSubCategoryIndex = info.subSubCategoryIndex;
	end
	
	button.SelectedTexture:SetShown(info.selected);
end




--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseCategoriesList.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseCategoriesList.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	
	<Button name="AuctionCategoryButtonTemplate" parentArray="FilterButtons" inherits="TruncatedTooltipScriptTemplate" virtual="true">
		<Size x="132" y="21"/>
		<Layers>
			<Layer level="BACKGROUND">
				<Texture parentKey="Lines" atlas="auctionhouse-nav-button-tertiary-filterline" useAtlasSize="true">
					<Anchors>
						<Anchor point="LEFT" x="18" y="3"/>
					</Anchors>
				</Texture>
				<Texture parentKey="NormalTexture" atlas="auctionhouse-nav-button" useAtlasSize="false">
					<Size x="136" y="32"/>
					<Anchors>
						<Anchor point="TOPLEFT" x="-2" y="0"/>
					</Anchors>
				</Texture>
			</Layer>
			<Layer level="BORDER">
				<Texture parentKey="HighlightTexture" atlas="auctionhouse-nav-button-highlight" hidden="true">
					<Anchors>
						<Anchor point="CENTER"/>
					</Anchors>
				</Texture>
			</Layer>
			<Layer level="ARTWORK">
				<Texture parentKey="SelectedTexture" atlas="auctionhouse-nav-button-select" alphaMode="ADD" hidden="true">
					<Anchors>
						<Anchor point="TOPLEFT" relativeKey="$parent.NormalTexture" relativePoint="TOPLEFT"/>
						<Anchor point="BOTTOMRIGHT" relativeKey="$parent.NormalTexture" relativePoint="BOTTOMRIGHT"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad function="AuctionFrameFilter_OnLoad"/>
			<OnEnter function="AuctionFrameFilter_OnEnter"/>
			<OnLeave function="AuctionFrameFilter_OnLeave"/>
			<OnMouseDown function="AuctionFrameFilter_OnMouseDown"/>
			<OnMouseUp function="AuctionFrameFilter_OnMouseUp"/>
		</Scripts>
		<ButtonText parentKey="Text" justifyH="LEFT">
			<Size x="0" y="8"/>
			<Anchors>
				<Anchor point="LEFT" x="4" y="0"/>
				<Anchor point="RIGHT" x="-4" y="0"/>
			</Anchors>
			<Shadow>
				<Offset>
					<AbsDimension x="1" y="-1"/>
				</Offset>
				<Color r="0" g="0" b="0"/>
			</Shadow>
		</ButtonText>
		<NormalFont style="GameFontNormalSmall"/>
		<HighlightFont style="GameFontHighlightSmall"/>
	</Button>

	<Frame name="AuctionHouseCategoriesListTemplate" mixin="AuctionHouseCategoriesListMixin" virtual="true">
		<Size x="168" y="438"/>
		<KeyValues>
			<KeyValue key="layoutType" value="InsetFrameTemplate" type="string"/>
		</KeyValues>
		<Frames>
			<Frame parentKey="NineSlice" useParentLevel="true" inherits="NineSlicePanelTemplate"/>

			<Frame parentKey="ScrollBox" inherits="WowScrollBoxList">
				<Anchors>
					<Anchor point="TOPLEFT" x="3" y="-6"/>
					<Anchor point="BOTTOMRIGHT" x="-25" y="2"/>
				</Anchors>
			</Frame>
			<EventFrame parentKey="ScrollBar" inherits="MinimalScrollBar">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ScrollBox" relativePoint="TOPRIGHT" x="6" y="0"/>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent.ScrollBox" relativePoint="BOTTOMRIGHT" x="6" y="4"/>
				</Anchors>
			</EventFrame>
		</Frames>
		<Layers>
			<Layer level="BACKGROUND">
				<Texture parentKey="Background" atlas="auctionhouse-background-categories" useAtlasSize="true">
					<Anchors>
						<Anchor point="TOPLEFT" x="3" y="-3"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
			<Scripts>
				<OnLoad method="OnLoad"/>
				<OnShow method="OnShow"/>
			</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseCategoriesList.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseItemList.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	
	<Button name="AuctionHouseItemListLineTemplate" mixin="AuctionHouseItemListLineMixin" virtual="true">
		<Size x="0" y="20"/>
		<Anchors>
			<Anchor point="LEFT"/>
			<Anchor point="RIGHT"/>
		</Anchors>
		<Layers>
			<Layer level="OVERLAY">
				<Texture parentKey="SelectedHighlight" atlas="auctionhouse-ui-row-select" alphaMode="ADD" hidden="true"/>

				<!-- Using a normal texture for highlight to control the behavior. -->
				<Texture parentKey="HighlightTexture" atlas="auctionhouse-ui-row-highlight" alphaMode="ADD" setAllPoints="true" hidden="true"/>
			</Layer>
		</Layers>
		<Scripts>
			<OnClick method="OnClick"/>
			<OnEnter method="OnEnter"/>
			<OnLeave method="OnLeave"/>
		</Scripts>
		<NormalTexture parentKey="NormalTexture" atlas="auctionhouse-rowstripe-1" setAllPoints="true"/>
	</Button>

	<Button name="AuctionHouseFavoritableLineTemplate" mixin="AuctionHouseFavoritableLineMixin" inherits="AuctionHouseItemListLineTemplate" registerForClicks="LeftButtonUp, RightButtonUp" virtual="true"/>

	<Frame name="AuctionHouseItemListHeadersTemplate" virtual="true">
		<Size x="0" y="19"/>
	</Frame>

	<Frame name="AuctionHouseItemListTemplate" mixin="AuctionHouseItemListMixin" inherits="AuctionHouseBackgroundTemplate" virtual="true">
		<KeyValues>
			<!--
			hideStripes: Hides the normal texture that usually alternates each line, making all lines invisible.
			hideRefreshFrame: Hide the refresh frame.
			refreshFrameXOffset: The x offset (from the topright of the item list) for the refresh frame.
			refreshFrameYOffset: The y offset (from the topright of the item list) for the refresh frame.
			<KeyValue key="hideStripes" value="true" type="boolean"/>
			<KeyValue key="hideRefreshFrame" value="false" type="boolean"/>
			<KeyValue key="refreshFrameXOffset" value="0" type="number"/>
			<KeyValue key="refreshFrameYOffset" value="0" type="number"/>
			-->

			<KeyValue key="layoutType" value="InsetFrameTemplate" type="string"/>
			<KeyValue key="backgroundYOffset" value="-19" type="number"/>
		</KeyValues>
		<Frames>
			<Frame parentKey="RefreshFrame" inherits="AuctionHouseRefreshFrameTemplate">
				<Anchors>
					<Anchor point="TOPRIGHT"/>
				</Anchors>
			</Frame>

			<Frame parentKey="HeaderContainer" inherits="AuctionHouseItemListHeadersTemplate">
				<Anchors>
					<Anchor point="TOPLEFT" x="4" y="-1"/>
					<Anchor point="TOPRIGHT" x="-26" y="-1"/>
				</Anchors>
			</Frame>
			<Frame parentKey="ScrollBox" inherits="WowScrollBoxList">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.HeaderContainer" relativePoint="BOTTOMLEFT" x="0" y="-6"/>
					<Anchor point="RIGHT" relativeKey="$parent.HeaderContainer" relativePoint="RIGHT"/>
					<Anchor point="BOTTOM" x="0" y="3"/>
				</Anchors>
			</Frame>
			<EventFrame parentKey="ScrollBar" inherits="MinimalScrollBar">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ScrollBox" relativePoint="TOPRIGHT" x="9" y="0"/>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent.ScrollBox" relativePoint="BOTTOMRIGHT" x="9" y="4"/>
				</Anchors>
			</EventFrame>
			<Frame parentKey="LoadingSpinner" inherits="SpinnerTemplate" hidden="true">
				<Size x="90" y="90"/>
				<Anchors>
					<Anchor point="CENTER" x="-12" y="-15"/>
				</Anchors>
				<Layers>
					<Layer level="OVERLAY">
						<FontString parentKey="SearchingText" inherits="GameFontNormalHuge4" text="SEARCHING">
							<Anchors>
								<Anchor point="BOTTOM" relativePoint="TOP" x="0" y="10"/>
							</Anchors>
						</FontString>
					</Layer>
				</Layers>
			</Frame>
		</Frames>
		<Layers>
			<Layer level="OVERLAY">
				<FontString parentKey="ResultsText" inherits="GameFontNormal" hidden="true">
					<Anchors>
						<Anchor point="TOP" relativeKey="$parent.ScrollBox" relativePoint="TOP" x="0" y="-45"/>
						<Anchor point="LEFT" x="45"/>
						<Anchor point="RIGHT" x="-67"/>
					</Anchors>
					<Color color="NORMAL_FONT_COLOR"/>
					<Shadow>
						<Offset>
							<AbsDimension x="1" y="-1"/>
						</Offset>
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnUpdate method="OnUpdate"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseItemList.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseMultisell.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Frame name="AuctionHouseMultisellProgressFrame" mixin="MultisellProgressFrameMixin" inherits="UIParentBottomManagedFrameTemplate" toplevel="true" parent="UIParent" enableMouse="true" hidden="true">
		<Size x="300" y="64"/>
		<KeyValues>
			<KeyValue key="layoutIndex" value="61" type="number"/>
		</KeyValues>
		<Layers>
			<Layer level="BACKGROUND">
				<Texture parentKey="Fill" file="Interface\AuctionFrame\UI-AuctionPost-Background">							
					<Anchors>
						<Anchor point="TOPLEFT" relativeKey="$parent" relativePoint="TOPLEFT" x="12" y="-8"/>
						<Anchor point="BOTTOMRIGHT" relativeKey="$parent" relativePoint="BOTTOMRIGHT" x="-12" y="8"/>
					</Anchors>
					<TexCoords left="0" right="1" top="0.25" bottom="0.75" />
					<Color r="0.55" g="0.55" b="0.55" />
				</Texture>
			</Layer>
			<Layer level="ARTWORK">
				<Texture parentKey="Left" file="Interface\AuctionFrame\UI-AuctionPost-Endcaps">
					<Size x="32" y="64"/>
					<Anchors>
						<Anchor point="LEFT"/>
					</Anchors>
					<TexCoords left="0.5" right="1" top="0" bottom="1" />
					<Color r="0.75" g="0.75" b="0.75" />
				</Texture>
				<Texture parentKey="Right" file="Interface\AuctionFrame\UI-AuctionPost-Endcaps">
					<Size x="32" y="64"/>
					<Anchors>
						<Anchor point="RIGHT"/>
					</Anchors>
					<TexCoords left="0" right="0.5" top="0" bottom="1" />
					<Color r="0.75" g="0.75" b="0.75" />
				</Texture>
				<Texture parentKey="Middle" file="Interface\AuctionFrame\UI-AuctionPost-Middle">
					<Anchors>
						<Anchor point="RIGHT" relativeKey="$parent.Right" relativePoint="LEFT" />
						<Anchor point="LEFT" relativeKey="$parent.Left" relativePoint="RIGHT" />
					</Anchors>
					<Color r="0.75" g="0.75" b="0.75" />
				</Texture>
			</Layer>
		</Layers>
		<Frames>
			<StatusBar parentKey="ProgressBar" inherits="CastingBarFrameBaseTemplate">
				<Size x="195" y="11"/>
				<Anchors>
					<Anchor point="CENTER" relativeKey="$parent" x="3" y="5"/>
				</Anchors>
				<Scripts>
					<OnLoad>
						self.Spark:Hide();
						self.Flash:Hide();
						self.Icon:Show();
						self.Icon:SetWidth(24);
						self.Icon:SetHeight(24);
						self.Icon:SetPoint("RIGHT", self, "LEFT", -10, -6);
					</OnLoad>

					<!-- Override the scripts from the template, as this behavior is not desired. -->
					<OnEvent></OnEvent>
					<OnShow></OnShow>
					<OnUpdate></OnUpdate>
					<!-- Override the scripts from the template, as this behavior is not desired. -->
				</Scripts>
			</StatusBar>
			<Button parentKey="CancelButton">
				<Size x="32" y="32"/>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.ProgressBar" relativePoint="RIGHT" x="2" y="-7"/>
				</Anchors>
				<HitRectInsets left="9" right="7" top="-7" bottom="10"/>
				<Scripts>
					<OnClick>
						C_AuctionHouse.CancelSell();
					</OnClick>
				</Scripts>
				<NormalTexture file="Interface\Buttons\CancelButton-Up"/>
				<PushedTexture file="Interface\Buttons\CancelButton-Down"/>
				<HighlightTexture file="Interface\Buttons\CancelButton-Highlight" alphaMode="ADD"/>
			</Button>
		</Frames>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseMultisell.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseSharedTemplates.lua ---

AuctionHouseBackgroundMixin = {};

function AuctionHouseBackgroundMixin:OnLoad()
	local xOffset = self.backgroundXOffset or 0;
	local yOffset = self.backgroundYOffset or 0;
	self.Background:SetAtlas(self.backgroundAtlas, true);
	self.Background:SetPoint("TOPLEFT", xOffset + 3, yOffset - 3);

	self.NineSlice:ClearAllPoints();
	self.NineSlice:SetPoint("TOPLEFT", xOffset, yOffset);
	self.NineSlice:SetPoint("BOTTOMRIGHT");
end

function AuctionHouseItemDisplayMixin:OnEnter()
	self:SetScript("OnUpdate", AuctionHouseItemDisplayMixin.OnUpdate);

	if IsModifiedClick("DRESSUP") then
		ShowInspectCursor();
	end

	if self:IsPet() then
		if self.itemKey then
			local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(self.itemKey);
			if itemKeyInfo and itemKeyInfo.battlePetLink then
				GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
				BattlePetToolTip_ShowLink(itemKeyInfo.battlePetLink);
				AuctionHouseUtil.AppendBattlePetVariationLines(BattlePetTooltip);
			else
				BattlePetTooltip:Hide();
				GameTooltip:Hide();
			end
		else
			local itemLocation = self:GetItemLocation();
			if itemLocation then
				local bagID, slotIndex = itemLocation:GetBagAndSlot();
				if bagID and slotIndex then
					GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
					GameTooltip:SetBagItem(bagID, slotIndex);
				end
			end
		end
	else
		BattlePetTooltip:Hide();

		local itemLocation = self:GetItemLocation();
		if itemLocation then
			GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
			GameTooltip:SetHyperlink(C_Item.GetItemLink(itemLocation));
			GameTooltip:Show();
		else
			local itemKey = self:GetItemKey();
			if itemKey then
				GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
				GameTooltip:SetItemKey(itemKey.itemID, itemKey.itemLevel, itemKey.itemSuffix, C_AuctionHouse.GetItemKeyRequiredLevel(itemKey));
				GameTooltip:Show();
			else
				local itemLink = self:GetItemLink();
				if itemLink then
					GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
					GameTooltip:SetHyperlink(itemLink);
					GameTooltip:Show();
				end
			end
		end

		self.ItemButton.UpdateTooltip = self.ItemButton:GetScript("OnEnter");
	end
end

--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseSharedTemplates.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseSharedTemplates.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	<Button name="AuctionHouseItemDisplayTemplate" inherits="AuctionHouseItemDisplayBaseTemplate" virtual="true">
		<Frames>
			<Button parentKey="ItemButton" mixin="AuctionHouseItemDisplayItemButtonMixin" inherits="CircularGiantItemButtonTemplate">
				<Scripts>
					<OnLoad method="OnLoad"/>
					<OnClick method="OnClick"/>
					<OnEnter method="OnEnter"/>
					<OnLeave method="OnLeave"/>
				</Scripts>
			</Button>
			<Button parentKey="FavoriteButton" inherits="AuctionHouseFavoriteButtonBaseTemplate">
				<Anchors>
					<Anchor point="TOPRIGHT" relativePoint="TOPRIGHT" x="-6" y="-6"/>
				</Anchors>
			</Button>
		</Frames>
		<Layers>
			<Layer level="ARTWORK">
				<FontString parentKey="Name" inherits="SystemFont_Shadow_Large2" justifyH="LEFT">
					<Size x="0" y="64"/>
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.ItemButton" relativePoint="RIGHT" x="11" y="1"/>
						<Anchor point="RIGHT" relativeKey="$parent" relativePoint="RIGHT" x="-31" y="1"/>
					</Anchors>
					<Shadow x="1" y="-1">
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
			</Layer>
		</Layers>
	</Button>

	<EventFrame name="DummyAuctionHouseScrollBarTemplate" inherits="MinimalScrollBar" virtual="true">
		<Anchors>
			<Anchor point="TOPLEFT" relativePoint="TOPRIGHT" x="5" y="-2"/>
			<Anchor point="BOTTOMLEFT" relativePoint="BOTTOMRIGHT" x="5" y="7"/>
		</Anchors>
	</EventFrame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseSharedTemplates.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseTab.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Button name="AuctionHouseFrameTabTemplate" inherits="PanelTabButtonTemplate" mixin="AuctionHouseFrameTabMixin" virtual="true">
		<Scripts>
			<OnShow method="OnShow"/>
		</Scripts>
	</Button>

	<Button name="AuctionHouseFrameTopTabTemplate" inherits="PanelTopTabButtonTemplate" mixin="AuctionHouseFrameTopTabMixin" virtual="true">
		<Scripts>
			<OnShow method="OnShow"/>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>

	<Button name="AuctionHouseFrameDisplayModeTabTemplate" mixin="AuctionHouseFrameDisplayModeTabMixin" inherits="AuctionHouseFrameTabTemplate" virtual="true">
		<!--
		displayMode: The display mode to set on the auction house frame on click.
		<KeyValues>
			<KeyValue key="displayMode" value="AuctionHouseFrameDisplayMode.Sell" type="global"/>
		</KeyValues>
		-->
		<Scripts>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseTab.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseUtil.lua ---

local function GetQualityFilterString(itemQuality)
	local text = _G["ITEM_QUALITY"..itemQuality.."_DESC"];
	return ColorManager.GetFormattedStringForItemQuality(text, itemQuality);
end

AUCTION_HOUSE_FILTER_STRINGS = {
	[Enum.AuctionHouseFilter.UncollectedOnly] = AUCTION_HOUSE_FILTER_UNCOLLECTED_ONLY,
	[Enum.AuctionHouseFilter.UsableOnly] = AUCTION_HOUSE_FILTER_USABLE_ONLY,
	[Enum.AuctionHouseFilter.CurrentExpansionOnly] = AUCTION_HOUSE_FILTER_CURRENTEXPANSION_ONLY,
	[Enum.AuctionHouseFilter.UpgradesOnly] = AUCTION_HOUSE_FILTER_UPGRADES_ONLY,
	[Enum.AuctionHouseFilter.PoorQuality] = GetQualityFilterString(Enum.ItemQuality.Poor),
	[Enum.AuctionHouseFilter.CommonQuality] = GetQualityFilterString(Enum.ItemQuality.Common),
	[Enum.AuctionHouseFilter.UncommonQuality] = GetQualityFilterString(Enum.ItemQuality.Uncommon),
	[Enum.AuctionHouseFilter.RareQuality] = GetQualityFilterString(Enum.ItemQuality.Rare),
	[Enum.AuctionHouseFilter.EpicQuality] = GetQualityFilterString(Enum.ItemQuality.Epic),
	[Enum.AuctionHouseFilter.LegendaryQuality] = GetQualityFilterString(Enum.ItemQuality.Legendary),
	[Enum.AuctionHouseFilter.ArtifactQuality] = GetQualityFilterString(Enum.ItemQuality.Artifact),
	[Enum.AuctionHouseFilter.LegendaryCraftedItemOnly] = AUCTION_HOUSE_FILTER_RUNECARVING,
};

AUCTION_HOUSE_DEFAULT_FILTERS = {
	[Enum.AuctionHouseFilter.UncollectedOnly] = false,
	[Enum.AuctionHouseFilter.UsableOnly] = false,
	[Enum.AuctionHouseFilter.CurrentExpansionOnly] = false,
	[Enum.AuctionHouseFilter.UpgradesOnly] = false,
	[Enum.AuctionHouseFilter.PoorQuality] = true,
	[Enum.AuctionHouseFilter.CommonQuality] = true,
	[Enum.AuctionHouseFilter.UncommonQuality] = true,
	[Enum.AuctionHouseFilter.RareQuality] = true,
	[Enum.AuctionHouseFilter.EpicQuality] = true,
	[Enum.AuctionHouseFilter.LegendaryQuality] = true,
	[Enum.AuctionHouseFilter.ArtifactQuality] = true,
};

local AUCTION_HOUSE_FILTER_CATEGORY_STRINGS = {
	[Enum.AuctionHouseFilterCategory.Uncategorized] = "",
	[Enum.AuctionHouseFilterCategory.Equipment] = AUCTION_HOUSE_FILTER_CATEGORY_EQUIPMENT,
	[Enum.AuctionHouseFilterCategory.Rarity] = AUCTION_HOUSE_FILTER_CATEGORY_RARITY,
};

function GetAHFilterCategoryName(category)
	return AUCTION_HOUSE_FILTER_CATEGORY_STRINGS[category] or "";
end

local AuctionHouseTooltipType = {
	BucketPetLink = 1,
	ItemLink = 2,
	ItemKey = 3,
	SpecificPetLink = 4,
};

function AuctionHouseUtil.GetItemDisplayCraftingQualityIconFromItemKey(itemKey)
	local itemDisplayCraftingQuality = nil;
	local craftingQuality = C_TradeSkillUI.GetItemReagentQualityByItemInfo(itemKey.itemID);

	if craftingQuality then
		itemDisplayCraftingQuality = C_Texture.GetCraftingReagentQualityChatIcon(craftingQuality);
	end

	return itemDisplayCraftingQuality;
end

local function GetAuctionHouseTooltipType(rowData)
	if rowData.itemLink then
		local linkType = LinkUtil.ExtractLink(rowData.itemLink);
		if linkType == "battlepet" then
			return AuctionHouseTooltipType.SpecificPetLink, rowData.itemLink;
		elseif linkType == "item" then
			return AuctionHouseTooltipType.ItemLink, rowData.itemLink;
		end
	elseif rowData.itemKey then
		local restrictQualityToFilter = true;
		local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(rowData.itemKey, restrictQualityToFilter);
		if itemKeyInfo and itemKeyInfo.battlePetLink then
			return AuctionHouseTooltipType.BucketPetLink, itemKeyInfo.battlePetLink;
		end

		return AuctionHouseTooltipType.ItemKey, rowData.itemKey;
	end

	return nil;
end

function AuctionHouseUtil.SetAuctionHouseTooltip(owner, rowData)
	GameTooltip_Hide();

	local tooltip = nil;

	local tooltipType, data = GetAuctionHouseTooltipType(rowData);
	if not tooltipType then
		return;
	end

	GameTooltip:SetOwner(owner, "ANCHOR_RIGHT");
	
	if tooltipType == AuctionHouseTooltipType.BucketPetLink or tooltipType == AuctionHouseTooltipType.SpecificPetLink then
		BattlePetToolTip_ShowLink(data);
		tooltip = BattlePetTooltip;
	else
		tooltip = GameTooltip;
		if tooltipType == AuctionHouseTooltipType.ItemLink then
			local hideVendorPrice = true;
			GameTooltip:SetHyperlink(rowData.itemLink, nil, nil, hideVendorPrice);
		elseif tooltipType == AuctionHouseTooltipType.ItemKey then
			GameTooltip:SetItemKey(data.itemID, data.itemLevel, data.itemSuffix, C_AuctionHouse.GetItemKeyRequiredLevel(data));
		end
	end

	if rowData.owners then
		local methodFound, auctionHouseFrame = CallMethodOnNearestAncestor(owner, "GetAuctionHouseFrame");
		local bidStatus = auctionHouseFrame and auctionHouseFrame:GetBidStatus(rowData) or nil;
		AuctionHouseUtil.AddAuctionHouseTooltipInfo(tooltip, rowData, bidStatus);
	end

	if tooltipType == AuctionHouseTooltipType.BucketPetLink then
		AuctionHouseUtil.AppendBattlePetVariationLines(tooltip);
	end

	if tooltip == GameTooltip then
		GameTooltip:Show();
	end
end


--- END OF FILE: Blizzard_AuctionHouseUI\Mainline\Blizzard_AuctionHouseUtil.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionData.lua ---

NUM_BROWSE_TO_DISPLAY = 8;
NUM_AUCTION_ITEMS_PER_PAGE = 50;
NUM_FILTERS_TO_DISPLAY = 20;
BROWSE_FILTER_HEIGHT = 20;
NUM_BIDS_TO_DISPLAY = 9;
NUM_AUCTIONS_TO_DISPLAY = 9;
AUCTIONS_BUTTON_HEIGHT = 37;
CLASS_FILTERS = {};
AUCTION_TIMER_UPDATE_DELAY = 0.3;
MAXIMUM_BID_PRICE = 99999999999;
AUCTION_CANCEL_COST =  5;	--5% of the current bid
NUM_TOKEN_LOGS_TO_DISPLAY = 14;


AuctionCategories = {};

local function FindDeepestCategory(categoryIndex, ...)
	local categoryInfo = AuctionCategories[categoryIndex];
	for i = 1, select("#", ...) do
		local subCategoryIndex = select(i, ...);
		if categoryInfo and categoryInfo.subCategories and categoryInfo.subCategories[subCategoryIndex] then
			categoryInfo = categoryInfo.subCategories[subCategoryIndex];
		else
			break;
		end
	end
	return categoryInfo;
end

function AuctionFrame_GetDetailColumnString(categoryIndex, subCategoryIndex)
	local categoryInfo = FindDeepestCategory(categoryIndex, subCategoryIndex);
	return categoryInfo and categoryInfo:GetDetailColumnString() or REQ_LEVEL_ABBR;
end

function AuctionFrame_GetDetailColumnStringUnsafe(categoryIndex, subCategoryIndex)
	local categoryInfo = FindDeepestCategory(categoryIndex, subCategoryIndex);
	return categoryInfo and categoryInfo:GetDetailColumnStringUnsafe() or nil;
end

function AuctionFrame_DoesCategoryHaveFlag(flag, categoryIndex, subCategoryIndex, subSubCategoryIndex)
	local categoryInfo = FindDeepestCategory(categoryIndex, subCategoryIndex, subSubCategoryIndex);
	if categoryInfo then
		return categoryInfo:HasFlag(flag);
	end
	return false;
end

function AuctionFrame_CreateCategory(name)
	local category = CreateFromMixins(AuctionCategoryMixin);
	category.name = name;
	AuctionCategories[#AuctionCategories + 1] = category;
	return category;
end

AuctionCategoryMixin = {};

function AuctionCategoryMixin:SetDetailColumnString(detailColumnString)
	self.detailColumnString = detailColumnString;
end

function AuctionCategoryMixin:GetDetailColumnString()
	if self.detailColumnString then
		return self.detailColumnString;
	end
	if self.parent then
		return self.parent:GetDetailColumnString();
	end
	return REQ_LEVEL_ABBR;
end

function AuctionCategoryMixin:GetDetailColumnStringUnsafe()
	if self.detailColumnString then
		return self.detailColumnString;
	end
	if self.parent then
		return self.parent:GetDetailColumnStringUnsafe();
	end
	return nil;
end

function AuctionCategoryMixin:CreateSubCategory(classID, subClassID, inventoryType, implicitFilter)
	local name = "";
	if implicitFilter then
		name = AUCTION_HOUSE_FILTER_STRINGS[implicitFilter];
	elseif inventoryType then
		name = C_Item.GetItemInventorySlotInfo(inventoryType);
	elseif classID and subClassID then
		name = C_Item.GetItemSubClassInfo(classID, subClassID);
	elseif classID then
		name = C_Item.GetItemClassInfo(classID);
	end
	return self:CreateNamedSubCategory(name);
end

function AuctionCategoryMixin:CreateNamedSubCategory(name)
	self.subCategories = self.subCategories or {};

	local subCategory = CreateFromMixins(AuctionCategoryMixin);
	self.subCategories[#self.subCategories + 1] = subCategory;

	assert(name and #name > 0);
	subCategory.name = name;
	subCategory.parent = self;
	subCategory.sortIndex = #self.subCategories;
	return subCategory;
end

function AuctionCategoryMixin:CreateNamedSubCategoryAndFilter(name, classID, subClassID, inventoryType, implicitFilter, useParentFilters)
	local category = self:CreateNamedSubCategory(name);

	if useParentFilters then
		self.filters = self.filters or {};
		category:SetFilters(self.filters);
	else
		category:AddFilter(classID, subClassID, inventoryType, implicitFilter);
	end

	return category;
end

function AuctionCategoryMixin:CreateSubCategoryAndFilter(classID, subClassID, inventoryType, implicitFilter, useParentFilters)
	local category = self:CreateSubCategory(classID, subClassID, inventoryType, implicitFilter);

	if useParentFilters then
		self.filters = self.filters or {};
		category:SetFilters(self.filters);
		category.implicitFilter = implicitFilter;
	else
		category:AddFilter(classID, subClassID, inventoryType, implicitFilter);
	end

	return category;
end

function AuctionCategoryMixin:AddFilter(classID, subClassID, inventoryType, implicitFilter)
	if not classID and not subClassID and not inventoryType and not implicitFilter then
		return;
	end

	self.filters = self.filters or {};
	self.filters[#self.filters + 1] = { classID = classID, subClassID = subClassID, inventoryType = inventoryType, };

	self.implicitFilter = implicitFilter;

	if self.parent then
		self.parent:AddFilter(classID, subClassID, inventoryType, implicitFilter);
	end
end

function AuctionCategoryMixin:SetFilters(filters)
	self.filters = filters;
end

do
	local function GenerateSubClassesHelper(self, classID, subClasses)
		for i = 1, #subClasses do
			local subClassID = subClasses[i];
			self:CreateSubCategoryAndFilter(classID, subClassID);
		end
	end

	function AuctionCategoryMixin:GenerateSubCategoriesAndFiltersFromSubClass(classID)
		GenerateSubClassesHelper(self, classID, C_AuctionHouse.GetAuctionItemSubClasses(classID));
	end
end

function AuctionCategoryMixin:FindSubCategoryByName(name)
	if self.subCategories then
		for i, subCategory in ipairs(self.subCategories) do
			if subCategory.name == name then
				return subCategory;
			end
		end
	end
end

function AuctionCategoryMixin:SortSubCategories()
	if self.subCategories then
		table.sort(self.subCategories, function(left, right)
			return left.sortIndex < right.sortIndex;
		end)
	end
end

function AuctionCategoryMixin:SetSortIndex(sortIndex)
	self.sortIndex = sortIndex
end

function AuctionCategoryMixin:SetFlag(flag)
	self.flags = self.flags or {};
	self.flags[flag] = true;
end

function AuctionCategoryMixin:ClearFlag(flag)
	if self.flags then
		self.flags[flag] = nil;
	end
end

function AuctionCategoryMixin:HasFlag(flag)
	return not not (self.flags and self.flags[flag]);
end

function AuctionHouseCategory_FindDeepest(categoryIndex, ...)
	local categoryInfo = AuctionCategories[categoryIndex];
	for i = 1, select("#", ...) do
		local subCategoryIndex = select(i, ...);
		if categoryInfo and categoryInfo.subCategories and categoryInfo.subCategories[subCategoryIndex] then
			categoryInfo = categoryInfo.subCategories[subCategoryIndex];
		else
			break;
		end
	end
	return categoryInfo;
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionData.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseAuctionsFrame.lua ---


local BIDS_TAB_ID = 2;
local ALL_INDEX = 1;

AuctionHouseAuctionsFrameTabMixin = {};

function AuctionHouseAuctionsFrameTabMixin:OnClick()
	AuctionHouseFrameTopTabMixin.OnClick(self);

	self:GetParent():SetTab(self:GetID());
end

AuctionHouseAuctionsSummaryListMixin = {};

function AuctionHouseAuctionsSummaryListMixin:OnLoad()
	AuctionHouseBackgroundMixin.OnLoad(self);

	local view = CreateScrollBoxListLinearView();
	view:SetElementInitializer("AuctionHouseAuctionsSummaryLineTemplate", function(button, elementData)
		button:Init(elementData);
		button:SetSelected(elementData == self.selectedListIndex);
		button:SetScript("OnClick", function(button, buttonName)
			self:SetSelectedIndex(button:GetElementData());
		end);
	end);

	ScrollUtil.InitScrollBoxListWithScrollBar(self.ScrollBox, self.ScrollBar, view);
end

function AuctionHouseAuctionsSummaryListMixin:RefreshListDisplay()
	local auctionsFrame = AuctionHouseFrame.AuctionsFrame;
	if auctionsFrame:IsDisplayingBids() then
		auctionsFrame:SetDataProviderIndexRange(C_AuctionHouse.GetNumBidTypes(), ScrollBoxConstants.RetainScrollPosition);
	else
		auctionsFrame:SetDataProviderIndexRange(C_AuctionHouse.GetNumOwnedAuctionTypes(), ScrollBoxConstants.RetainScrollPosition);
	end
end

function AuctionHouseAuctionsSummaryListMixin:SetSelectedIndex(index)
	local oldSelectedIndex = self.selectedListIndex;
	self.selectedListIndex = index;

	local function SetSelected(index, selected)
		local found = self.ScrollBox:FindFrame(index);
		if found then
			found:SetSelected(selected);
		end
	end;

	SetSelected(oldSelectedIndex, false);
	SetSelected(index, true);

	AuctionHouseFrame.AuctionsFrame:OnSummaryLineSelected(index);
end

AuctionHouseAuctionsSummaryLineMixin = {};

function AuctionHouseAuctionsSummaryLineMixin:Init(listIndex)
	self:SetIconShown(false);

	local isDisplayingBids = AuctionHouseFrame.AuctionsFrame:IsDisplayingBids();
	if listIndex == ALL_INDEX then
		self.Text:SetText(isDisplayingBids and AUCTION_HOUSE_ALL_BIDS or AUCTION_HOUSE_ALL_AUCTIONS);
		self.Text:SetPoint("LEFT", 4, 0);
	else
		self.Text:SetPoint("LEFT", self.Icon, "RIGHT", 4, 0);

		local typeIndex = listIndex - ALL_INDEX;
		local itemKey = isDisplayingBids and C_AuctionHouse.GetBidType(typeIndex) or C_AuctionHouse.GetOwnedAuctionType(typeIndex);
		local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(itemKey);
		if not itemKeyInfo then
			self.pendingItemID = itemKey.itemID;
			self:RegisterEvent("ITEM_KEY_ITEM_INFO_RECEIVED");
			self.Text:SetText("");
			return;
		end

		self:SetIconShown(true);
		self.Icon:SetTexture(itemKeyInfo.iconFileID);
		self.Text:SetText(AuctionHouseUtil.GetItemDisplayTextFromItemKey(itemKey, itemKeyInfo));
	end

	if self.pendingItemID ~= nil then
		self:UnregisterEvent("ITEM_KEY_ITEM_INFO_RECEIVED");
		self.pendingItemID = nil;
	end
end

function AuctionHouseAuctionsSummaryLineMixin:SetSelected(selected)
	self.SelectedHighlight:SetShown(selected);
end

function AuctionHouseAuctionsSummaryLineMixin:OnLoad()
	self:ClearNormalTexture();
	self.Text:ClearAllPoints();
	self.Text:SetPoint("LEFT", self.Icon, "RIGHT", 4, 0);
	self.Text:SetPoint("RIGHT", -4, 0);
	self.Text:SetFontObject(Number13FontYellow);
end

function AuctionHouseAuctionsSummaryLineMixin:OnEvent(event, ...)
	if event == "ITEM_KEY_ITEM_INFO_RECEIVED" then
		local itemID = ...;
		if itemID == self.pendingItemID then
			self:Init(self:GetElementData());
		end
	end
end

function AuctionHouseAuctionsSummaryLineMixin:OnHide()
	self:UnregisterEvent("ITEM_KEY_ITEM_INFO_RECEIVED");
end

function AuctionHouseAuctionsSummaryLineMixin:SetIconShown(shown)
	self.Icon:SetShown(shown);
	self.IconBorder:SetShown(shown);
end

CancelAuctionButtonMixin = {};

function CancelAuctionButtonMixin:OnClick()
	local auctionsFrame = self:GetParent();
	auctionsFrame:CancelSelectedAuction();
	PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
end


AuctionHouseAuctionsFrameMixin = CreateFromMixins(AuctionHouseBuySystemMixin, AuctionHouseSortOrderSystemMixin);

local AUCTIONS_FRAME_EVENTS = {
	"OWNED_AUCTIONS_UPDATED",
	"ITEM_SEARCH_RESULTS_UPDATED",
	"ITEM_SEARCH_RESULTS_ADDED",
	"BIDS_UPDATED",
	"BID_ADDED",
	"AUCTION_CANCELED",
	"AUCTION_HOUSE_NEW_BID_RECEIVED",
};

local AuctionsFrameDisplayMode = {
	AllAuctions = 1,
	BidsList = 2,
	Item = 3,
	Commodity = 4,
};

function AuctionHouseAuctionsFrameMixin:OnLoad()
	AuctionHouseBuySystemMixin.OnLoad(self);
	AuctionHouseSortOrderSystemMixin.OnLoad(self);

	PanelTemplates_SetNumTabs(self, 2);
	self:SetTab(1);

	self.ItemDisplay:SetAuctionHouseFrame(self:GetAuctionHouseFrame());

	self:InitializeAllAuctionsList();
	self:InitializeBidsList();
	self:InitializeItemList();
	self:InitializeCommoditiesList();

	self:SetDisplayMode(AuctionsFrameDisplayMode.AllAuctions);
end

function AuctionHouseAuctionsFrameMixin:OnShow()
	FrameUtil.RegisterFrameForEvents(self, AUCTIONS_FRAME_EVENTS);

	-- AllBids and AllAuctions will update the entire list. Other views require
	-- and explicit update.
	local displayMode = self:GetDisplayMode();
	if displayMode ~= AuctionsFrameDisplayMode.BidsList and displayMode ~= AuctionsFrameDisplayMode.AllAuctions then
		self:RefreshSearchResults();
	end
end

function AuctionHouseAuctionsFrameMixin:RefreshSearchResults()
	local displayMode = self:GetDisplayMode();
	if self:IsDisplayingBids() then
		self:GetAuctionHouseFrame():QueryAll(AuctionHouseSearchContext.AllBids);
	else
		self:GetAuctionHouseFrame():QueryAll(AuctionHouseSearchContext.AllAuctions);
	end

	self:UpdateCancelAuctionButton();
end

function AuctionHouseAuctionsFrameMixin:OnHide()
	FrameUtil.UnregisterFrameForEvents(self, AUCTIONS_FRAME_EVENTS);
end

function AuctionHouseAuctionsFrameMixin:OnEvent(event, ...)
	if event == "OWNED_AUCTIONS_UPDATED" then
		self.AllAuctionsList:SetSelectedEntry(nil);
		self.AllAuctionsList:Reset();
		self.SummaryList:RefreshListDisplay();
		self:ValidateDisplayMode();
	elseif event == "ITEM_SEARCH_RESULTS_UPDATED" then
		self.ItemList:DirtyScrollFrame();
	elseif event == "ITEM_SEARCH_RESULTS_ADDED" then
		self.ItemList:DirtyScrollFrame();
	elseif event == "BIDS_UPDATED" then
		self.BidsList:DirtyScrollFrame();

		if self:IsDisplayingBids() then
			self.SummaryList:RefreshListDisplay();
			self:ValidateDisplayMode();
		end

	elseif event == "BID_ADDED" then
		self.BidsList:DirtyScrollFrame();

		if self:IsDisplayingBids() then
			self.SummaryList:RefreshListDisplay();
		end
	elseif event == "AUCTION_CANCELED" then
		self:RefreshSearchResults();
	elseif event == "AUCTION_HOUSE_NEW_BID_RECEIVED" then
		self:RefreshSearchResults();
	end
end

function AuctionHouseAuctionsFrameMixin:InitializeAllAuctionsList()
	self.AllAuctionsList:SetSelectionCallback(AuctionHouseUtil.GenerateRowSelectedCallbackWithInspect(self, self.OnAllAuctionsSearchResultSelected));
	self.AllAuctionsList:SetLineOnEnterCallback(AuctionHouseUtil.LineOnEnterCallback);
	self.AllAuctionsList:SetLineOnLeaveCallback(AuctionHouseUtil.LineOnLeaveCallback);

	self.AllAuctionsList:SetHighlightCallback(function(currentRowData, selectedRowData)
		return selectedRowData and currentRowData.auctionID == selectedRowData.auctionID;
	end);

	self.AllAuctionsList:SetTableBuilderLayout(AuctionHouseTableBuilder.GetAllAuctionsLayout(self, self.AllAuctionsList));

	local function AuctionsSearchStarted()
		return true;
	end

	self.AllAuctionsList:SetDataProvider(AuctionsSearchStarted, C_AuctionHouse.GetOwnedAuctionInfo, C_AuctionHouse.GetNumOwnedAuctions, C_AuctionHouse.HasFullOwnedAuctionResults);


	local function AllAuctionsRefreshResults()
		self:GetAuctionHouseFrame():QueryAll(AuctionHouseSearchContext.AllAuctions);
		self.AllAuctionsList:DirtyScrollFrame();
	end

	local AllAuctionsGetTotalQuantity = nil;

	self.AllAuctionsList:SetRefreshFrameFunctions(AllAuctionsGetTotalQuantity, AllAuctionsRefreshResults);
end

function AuctionHouseAuctionsFrameMixin:InitializeBidsList()
	self.BidsList:SetSelectionCallback(AuctionHouseUtil.GenerateRowSelectedCallbackWithInspect(self, self.OnBidsListSearchResultSelected));
	self.BidsList:SetLineOnEnterCallback(AuctionHouseUtil.LineOnEnterCallback);
	self.BidsList:SetLineOnLeaveCallback(AuctionHouseUtil.LineOnLeaveCallback);

	self.BidsList:SetHighlightCallback(function(currentRowData, selectedRowData)
		return selectedRowData and currentRowData.auctionID == selectedRowData.auctionID;
	end);

	self.BidsList:SetTableBuilderLayout(AuctionHouseTableBuilder.GetBidsListLayout(self, self.BidsList));

	local function BidsSearchStarted()
		return true;
	end

	self.BidsList:SetDataProvider(BidsSearchStarted, C_AuctionHouse.GetBidInfo, C_AuctionHouse.GetNumBids, C_AuctionHouse.HasFullBidResults);


	local function BidsListRefreshResults()
		self:GetAuctionHouseFrame():QueryAll(AuctionHouseSearchContext.AllBids);
		self.BidsList:DirtyScrollFrame();
	end

	local BidsListGetTotalQuantity = nil;

	self.BidsList:SetRefreshFrameFunctions(BidsListGetTotalQuantity, BidsListRefreshResults);
end

function AuctionHouseAuctionsFrameMixin:InitializeItemList()
	self.ItemList:SetTableBuilderLayout(AuctionHouseTableBuilder.GetAuctionsItemListLayout(self, self.ItemList));


	self.ItemList:SetHighlightCallback(function(currentRowData, selectedRowData)
		return selectedRowData and currentRowData.auctionID == selectedRowData.auctionID;
	end);

	self.ItemList:SetSelectionCallback(AuctionHouseUtil.GenerateRowSelectedCallbackWithInspect(self, self.OnItemSearchResultSelected));
	self.ItemList:SetLineOnEnterCallback(AuctionHouseUtil.LineOnEnterCallback);
	self.ItemList:SetLineOnLeaveCallback(AuctionHouseUtil.LineOnLeaveCallback);

	local function AuctionsItemListSearchStarted()
		return self.itemKey ~= nil;
	end

	local function AuctionsItemListGetEntry(index)
		return self.itemKey and C_AuctionHouse.GetItemSearchResultInfo(self.itemKey, index);
	end

	local function AuctionsItemListGetNumEntries()
		return self.itemKey and C_AuctionHouse.GetNumItemSearchResults(self.itemKey) or 0;
	end

	local function AuctionsItemListHasFullResults()
		return self.itemKey == nil or C_AuctionHouse.HasFullItemSearchResults(self.itemKey);
	end

	self.ItemList:SetDataProvider(AuctionsItemListSearchStarted, AuctionsItemListGetEntry, AuctionsItemListGetNumEntries, AuctionsItemListHasFullResults);


	local function AuctionsItemListGetTotalQuantity()
		return self.itemKey and C_AuctionHouse.GetItemSearchResultsQuantity(self.itemKey) or 0;
	end

	local function AuctionsItemListRefreshResults()
		if self.itemKey ~= nil then
			self:GetAuctionHouseFrame():RefreshSearchResults(self:GetSearchContext(), self.itemKey);
		end
	end

	self.ItemList:SetRefreshFrameFunctions(AuctionsItemListGetTotalQuantity, AuctionsItemListRefreshResults);
end

function AuctionHouseAuctionsFrameMixin:InitializeCommoditiesList()
	self.CommoditiesList:SetTableBuilderLayout(AuctionHouseTableBuilder.GetCommoditiesAuctionsListLayout(self, self.CommoditiesList));

	self.CommoditiesList:SetHighlightCallback(function(currentRowData, selectedRowData)
		return selectedRowData and currentRowData.auctionID == selectedRowData.auctionID;
	end);

	self.CommoditiesList:SetSelectionCallback(AuctionHouseUtil.GenerateRowSelectedCallbackWithLink(self, self.OnCommoditySearchResultSelected));

	local function AuctionsCommoditiesList_GetAuctionHouseFrame(commoditiesList)
		return commoditiesList:GetParent():GetAuctionHouseFrame();
	end

	self.CommoditiesList.GetAuctionHouseFrame = AuctionsCommoditiesList_GetAuctionHouseFrame;
end

function AuctionHouseAuctionsFrameMixin:SetItemKey(itemKey)
	self.itemKey = itemKey;
	self.ItemDisplay:SetItemKey(itemKey);
end

function AuctionHouseAuctionsFrameMixin:GetItemKey()
	return self.itemKey;
end

function AuctionHouseAuctionsFrameMixin:SetDisplayMode(displayMode)
	self.displayMode = displayMode;

	local isAllAuctions = displayMode == AuctionsFrameDisplayMode.AllAuctions;
	self.AllAuctionsList:SetShown(isAllAuctions);
	self.AllAuctionsList:SetSelectedEntry(nil);

	local isBidsList = displayMode == AuctionsFrameDisplayMode.BidsList;
	self.BidsList:SetShown(isBidsList);
	self.BidsList:SetSelectedEntry(nil);

	local isItem = displayMode == AuctionsFrameDisplayMode.Item;
	self.ItemList:SetShown(isItem);
	self.ItemList:SetSelectedEntry(nil);

	local isCommodity = displayMode == AuctionsFrameDisplayMode.Commodity;
	self.CommoditiesList:SetShown(isCommodity);
	self.CommoditiesList:SetSelectedEntry(nil);

	self.ItemDisplay:SetShown(not isAllAuctions and not isBidsList);
end

function AuctionHouseAuctionsFrameMixin:ValidateDisplayMode()
	local displayMode = self.displayMode;

	if displayMode == AuctionsFrameDisplayMode.Item or displayMode == AuctionsFrameDisplayMode.Commodity then
		local itemKey = self:GetItemKey();
		if self:IsDisplayingBids() then
			local hasType, typeIndex = AuctionHouseUtil.HasBidType(itemKey);
			self.SummaryList:SetSelectedIndex(hasType and (typeIndex + 1) or 1);
		else
			local hasType, typeIndex = AuctionHouseUtil.HasOwnedAuctionType(itemKey);
			self.SummaryList:SetSelectedIndex(hasType and (typeIndex + 1) or 1);
		end
	end
end

function AuctionHouseAuctionsFrameMixin:GetDisplayMode()
	return self.displayMode;
end

function AuctionHouseAuctionsFrameMixin:OnSummaryLineSelected(...)
	if self:IsDisplayingBids() then
		self:OnBidSummaryLineSelected(...);
	else
		self:OnAuctionSummaryLineSelected(...);
	end
end

function AuctionHouseAuctionsFrameMixin:OnAuctionSummaryLineSelected(listIndex)
	if listIndex == ALL_INDEX then
		self:SetItemKey(nil);
		self:SetDisplayMode(AuctionsFrameDisplayMode.AllAuctions);
	else
		local typeIndex = listIndex - ALL_INDEX;
		local itemKey = C_AuctionHouse.GetOwnedAuctionType(typeIndex);
		self:SelectItemKey(itemKey);
	end
end

function AuctionHouseAuctionsFrameMixin:OnBidSummaryLineSelected(listIndex)
	if listIndex == ALL_INDEX then
		self:SetItemKey(nil);
		self:SetDisplayMode(AuctionsFrameDisplayMode.BidsList);
	else
		local typeIndex = listIndex - ALL_INDEX;
		local itemKey = C_AuctionHouse.GetBidType(typeIndex);
		self:SelectItemKey(itemKey);
	end
end

function AuctionHouseAuctionsFrameMixin:GetSearchContext(displayMode)
	displayMode = displayMode or self:GetDisplayMode();
	if displayMode == AuctionsFrameDisplayMode.Item then
		if self:IsDisplayingBids() then
			return AuctionHouseSearchContext.BidItems;
		else
			return AuctionHouseSearchContext.AuctionsItems;
		end
	elseif displayMode == AuctionsFrameDisplayMode.Commodity then
		return AuctionHouseSearchContext.AuctionsCommodities;
	elseif displayMode == AuctionsFrameDisplayMode.AllAuctions then
		return AuctionHouseSearchContext.AllAuctions;
	elseif displayMode == AuctionsFrameDisplayMode.BidsList then
		return AuctionHouseSearchContext.AllBids;
	end
end

function AuctionHouseAuctionsFrameMixin:SelectItemKey(itemKey)
	local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(itemKey);
	if not itemKeyInfo then
		return;
	end

	self:SetItemKey(itemKey);

	if itemKeyInfo.isCommodity then
		self.CommoditiesList:SetItemID(itemKey.itemID);
	end

	local newDisplayMode = itemKeyInfo.isCommodity and AuctionsFrameDisplayMode.Commodity or AuctionsFrameDisplayMode.Item;
	local displayMode = self:GetDisplayMode();
	if newDisplayMode == displayMode then
		-- If we're switching display modes, the OnShow will automatically force a refresh. If not, we need to do it manually here.
		self:GetAuctionHouseFrame():QueryItem(self:GetSearchContext(newDisplayMode), itemKey);
	end

	self:SetDisplayMode(newDisplayMode);
end

function AuctionHouseAuctionsFrameMixin:SelectAuction(searchResult)
	self.selectedAuctionID = searchResult and searchResult.auctionID or nil;
	self:UpdateCancelAuctionButton(searchResult);
end

function AuctionHouseAuctionsFrameMixin:UpdateCancelAuctionButton(searchResult)
	self.CancelAuctionButton:SetEnabled(self.selectedAuctionID ~= nil and (self.selectedAuctionID > 0) and (searchResult and searchResult.status ~= Enum.AuctionStatus.Sold));
end

function AuctionHouseAuctionsFrameMixin:OnAllAuctionsSearchResultSelected(ownedAuctionInfo)
	self:SelectAuction(ownedAuctionInfo);
end

function AuctionHouseAuctionsFrameMixin:OnBidsListSearchResultSelected(bidInfo)
	if bidInfo then
		local isOwnerItem = false;
		self:SetAuction(bidInfo.auctionID, bidInfo.minBid, bidInfo.buyoutAmount, isOwnerItem, bidInfo.bidder);
	else
		self:SetAuction(nil);
	end
end

function AuctionHouseAuctionsFrameMixin:OnItemSearchResultSelected(itemSearchResultInfo)
	if itemSearchResultInfo then
		if itemSearchResultInfo.containsOwnerItem then
			self:SelectAuction(itemSearchResultInfo);
			self:SetAuction(nil);
		else
			self:SetAuction(itemSearchResultInfo.auctionID, itemSearchResultInfo.minBid, itemSearchResultInfo.buyoutAmount, AuctionHouseUtil.IsOwnedAuction(itemSearchResultInfo), itemSearchResultInfo.bidder);
		end
	else
		self:SelectAuction(nil);
		self:SetAuction(nil);
	end
end

function AuctionHouseAuctionsFrameMixin:OnCommoditySearchResultSelected(commoditySearchResultInfo)
	if commoditySearchResultInfo and commoditySearchResultInfo.containsOwnerItem then
		self:SelectAuction(commoditySearchResultInfo);
	else
		self:SelectAuction(nil);
	end
end

function AuctionHouseAuctionsFrameMixin:CancelSelectedAuction()
	StaticPopup_Show("CANCEL_AUCTION", nil, nil, { auctionID = self.selectedAuctionID });
end

function AuctionHouseAuctionsFrameMixin:GetTab()
	return PanelTemplates_GetSelectedTab(self);
end

function AuctionHouseAuctionsFrameMixin:SetTab(tabID)
	if self:GetTab() == tabID then
		return;
	end

	PanelTemplates_SetTab(self, tabID);

	local isDisplayingBids = self:IsDisplayingBids();

	self.CancelAuctionButton:SetShown(not isDisplayingBids);
	self.BidFrame:SetShown(isDisplayingBids);
	self.BuyoutFrame:SetShown(isDisplayingBids);

	local retainScrollPosition = false;
	if isDisplayingBids then
		self:SetDisplayMode(AuctionsFrameDisplayMode.BidsList);
		self:SetDataProviderIndexRange(C_AuctionHouse.GetNumBidTypes(), retainScrollPosition);
	else
		self:SetDisplayMode(AuctionsFrameDisplayMode.AllAuctions);
		self:SetDataProviderIndexRange(C_AuctionHouse.GetNumOwnedAuctionTypes(), retainScrollPosition);
	end
end

function AuctionHouseAuctionsFrameMixin:SetDataProviderIndexRange(range, retainScrollPosition)
	local dataProvider = CreateIndexRangeDataProvider(range + ALL_INDEX);
	self.SummaryList.ScrollBox:SetDataProvider(dataProvider, retainScrollPosition);
	self.SummaryList:SetSelectedIndex(1);
end

function AuctionHouseAuctionsFrameMixin:IsDisplayingBids()
	return self:GetTab() == BIDS_TAB_ID;
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseAuctionsFrame.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseBrowseResultsFrame.lua ---


local BROWSE_SCROLL_OFFSET_REFRESH_THRESHOLD = 30;


AuctionHouseBrowseResultsFrameMixin = CreateFromMixins(AuctionHouseSortOrderSystemMixin);

-- These events are registered in OnLoad, as the browse results can be updated
-- when the player retrieves specific item and commodity results.
local AUCTION_HOUSE_BROWSE_RESULTS_FRAME_EVENTS = {
	"AUCTION_HOUSE_BROWSE_RESULTS_UPDATED",
	"AUCTION_HOUSE_BROWSE_RESULTS_ADDED",
	"AUCTION_HOUSE_BROWSE_FAILURE",
};

function AuctionHouseBrowseResultsFrameMixin:SetupTableBuilder(extraInfoColumn)
	self.ItemList:SetTableBuilderLayout(AuctionHouseTableBuilder.GetBrowseListLayout(self, self.ItemList, extraInfoColumn));

	self.tableBuilderLayoutDirty = false;
end

function AuctionHouseBrowseResultsFrameMixin:OnLoad()
	FrameUtil.RegisterFrameForEvents(self, AUCTION_HOUSE_BROWSE_RESULTS_FRAME_EVENTS);
	
	AuctionHouseSortOrderSystemMixin.OnLoad(self);

	self.ItemList:SetLineTemplate("AuctionHouseFavoritableLineTemplate");

	self.ItemList:SetSelectionCallback(function(browseResult)
		self:OnBrowseResultSelected(browseResult);
		return false; -- browse lines are never selected.
	end);

	self.ItemList:SetLineOnEnterCallback(AuctionHouseUtil.LineOnEnterCallback);
	self.ItemList:SetLineOnLeaveCallback(AuctionHouseUtil.LineOnLeaveCallback);

	local extraInfoColumn = nil;
	self:SetupTableBuilder(extraInfoColumn);

	local function BrowseListSearchStarted()
		return self.searchStarted, AUCTION_HOUSE_BROWSE_FAVORITES_TIP;
	end

	local function BrowseListGetNumEntries()
		return #self.browseResults; -- Implemented in-line instead of using GetNumBrowseResults for performance.
	end

	local function BrowseListGetEntry(index)
		return self.browseResults[index];
	end

	self.ItemList:SetDataProvider(BrowseListSearchStarted, BrowseListGetEntry, BrowseListGetNumEntries, C_AuctionHouse.HasFullBrowseResults);

	self:Reset();

	-- If the player has favorites, an automatic search will be started immediately. This is required because
	-- when the addon is loaded, the AuctionHouseFrame on show is called first. All other times the auction house
	-- is opened, the BrowseResultsFrame will have on show called first and register for the browse search started event first.
	self.searchStarted = C_AuctionHouse.HasFavorites();
end

function AuctionHouseBrowseResultsFrameMixin:OnShow()
	self.ItemList:RefreshScrollFrame();

	self:GetAuctionHouseFrame():RegisterCallback(AuctionHouseFrameMixin.Event.CategorySelected, self.OnCategorySelected, self);
	self:GetAuctionHouseFrame():RegisterCallback(AuctionHouseFrameMixin.Event.BrowseSearchStarted, self.OnBrowseSearchStarted, self);
end

function AuctionHouseBrowseResultsFrameMixin:OnHide()
	self:GetAuctionHouseFrame():UnregisterCallback(AuctionHouseFrameMixin.Event.CategorySelected, self);
	self:GetAuctionHouseFrame():UnregisterCallback(AuctionHouseFrameMixin.Event.BrowseSearchStarted, self);
end

function AuctionHouseBrowseResultsFrameMixin:OnEvent(event, ...)
	if event == "AUCTION_HOUSE_BROWSE_RESULTS_UPDATED" then
		self:UpdateBrowseResults();
	elseif event == "AUCTION_HOUSE_BROWSE_RESULTS_ADDED" then
		local addedBrowseResults = ...;
		self:UpdateBrowseResults(addedBrowseResults);
	elseif event == "AUCTION_HOUSE_BROWSE_FAILURE" then
		self.ItemList:SetCustomError(RED_FONT_COLOR:WrapTextInColorCode(ERR_AUCTION_DATABASE_ERROR));
	end
end

function AuctionHouseBrowseResultsFrameMixin:Reset()
	self.browseResults = {};
	self.sortOrder = nil;
	self.isSortOrderReversed = false;
	self.searchStarted = false;
end

function AuctionHouseBrowseResultsFrameMixin:OnCategorySelected(selectedCategoryIndex, selectedSubCategoryIndex, selectedSubSubCategoryIndex)
	local extraColumnInfo = AuctionFrame_GetDetailColumnStringUnsafe(selectedCategoryIndex, selectedSubCategoryIndex);
	self.pendingExtraColumnInfo = extraColumnInfo;
	self.tableBuilderLayoutDirty = true;
end

function AuctionHouseBrowseResultsFrameMixin:OnBrowseSearchStarted()
	self.searchStarted = true;
	self.browseResults = {};
	self.ItemList:DirtyScrollFrame();
end

function AuctionHouseBrowseResultsFrameMixin:UpdateBrowseResults(addedBrowseResults)
	self.searchStarted = true;

	if self.tableBuilderLayoutDirty then
		self:SetupTableBuilder(self.pendingExtraColumnInfo);
		self.pendingExtraColumnInfo = nil;
	end
	
	if addedBrowseResults then
		tAppendAll(self.browseResults, addedBrowseResults);
	else
		self.browseResults = C_AuctionHouse.GetBrowseResults();
	end

	if C_AuctionHouse.HasFullBrowseResults() then
		self.ItemList:SetRefreshCallback(nil);
	else
		local function ItemListRefreshCallback(lastDisplayEntry)
			if C_AuctionHouse.HasFullBrowseResults() then
				self.ItemList:SetRefreshCallback(nil);
			elseif self:GetNumBrowseResults() - lastDisplayEntry < BROWSE_SCROLL_OFFSET_REFRESH_THRESHOLD then
				C_AuctionHouse.RequestMoreBrowseResults();
			end
		end

		self.ItemList:SetRefreshCallback(ItemListRefreshCallback);
	end

	if addedBrowseResults then
		self.ItemList:DirtyScrollFrame();
	else
		self.ItemList:Reset();
	end
end

function AuctionHouseBrowseResultsFrameMixin:GetNumBrowseResults()
	return #self.browseResults;
end

function AuctionHouseBrowseResultsFrameMixin:SetSortOrder(sortOrder)
	self:GetAuctionHouseFrame():SetBrowseSortOrder(sortOrder);
	self:UpdateHeaders();
end

function AuctionHouseBrowseResultsFrameMixin:GetSortOrderState(sortOrder)
	return self:GetAuctionHouseFrame():GetBrowseSortOrderState(sortOrder);
end

function AuctionHouseBrowseResultsFrameMixin:OnBrowseResultSelected(browseResult)
	if IsModifiedClick("DRESSUP") then
		if browseResult.appearanceLink then
			local _, _, hyperlinkString = ExtractHyperlinkString(browseResult.appearanceLink);
			DressUpTransmogLink(hyperlinkString);
		else
			local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(browseResult.itemKey);
			if itemKeyInfo and itemKeyInfo.battlePetLink then
				DressUpBattlePetLink(itemKeyInfo.battlePetLink);
			else
				local _, itemLink = C_Item.GetItemInfo(browseResult.itemKey.itemID);
				DressUpLink(itemLink);
			end
		end
	else
		self:GetAuctionHouseFrame():SelectBrowseResult(browseResult);
	end
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseBrowseResultsFrame.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseBrowseResultsFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Frame name="AuctionHouseBrowseResultsFrameTemplate" mixin="AuctionHouseBrowseResultsFrameMixin" virtual="true">
		<Frames>
			<Frame parentKey="ItemList" inherits="AuctionHouseItemListTemplate">
				<KeyValues>
					<KeyValue key="hideStripes" value="true" type="boolean"/>
					<KeyValue key="hideRefreshFrame" value="true" type="boolean"/>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-index" type="string"/>
					<KeyValue key="textureWidthClassic" value="595" type="number"/>
					<KeyValue key="textureHeightClassic" value="414" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOPLEFT" y="-1"/>
					<Anchor point="BOTTOMRIGHT" x="18" y="0"/>
				</Anchors>
			</Frame>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseBrowseResultsFrame.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseBuyDialog.lua ---


local REMAINING_QUOTE_DURATION_THRESHOLD = 10; -- seconds
local MAXIMUM_PREVIEW_PRICE_DIFFERENTIAL = 1.05;


AuctionHouseBuyDialogNotificationFrameMixin = {};

function AuctionHouseBuyDialogNotificationFrameMixin:SetNotificationText(notificationText, fontObject, showNotificationIcon)
	self.Button:SetShown(showNotificationIcon);

	self.Text:SetText(notificationText);
	self.Text:SetFontObject(fontObject);
	self.Text:ClearAllPoints();
	self.Text:SetPoint("BOTTOM");
	if showNotificationIcon then
		self.Text:SetPoint("CENTER", -15, 0);
	end
end

function AuctionHouseBuyDialogNotificationFrameMixin:SetPriceIncreases(unitPriceIncrease, totalPriceIncrease)
	self.unitPriceIncrease = unitPriceIncrease;
	self.totalPriceIncrease = totalPriceIncrease;
end

function AuctionHouseBuyDialogNotificationFrameMixin:GetPriceIncreases()
	return self.unitPriceIncrease, self.totalPriceIncrease;
end


AuctionHouseBuyDialogNotificationButtonMixin = {};

function AuctionHouseBuyDialogNotificationButtonMixin:OnEnter()
	GameTooltip:SetOwner(self, "ANCHOR_RIGHT");

	-- Use normal size font for the title line.
	GameTooltipTextLeft1:SetFontObject(GameTooltipText);
	GameTooltipTextRight1:SetFontObject(GameTooltipText);

	local normalR, normalG, normalB = NORMAL_FONT_COLOR:GetRGB();
	local unitPriceIncrease, totalPriceIncrease = self:GetParent():GetPriceIncreases();
	GameTooltip:AddDoubleLine(AUCTION_HOUSE_DIALOG_PER_UNIT_INCREASE, GetMoneyString(unitPriceIncrease), normalR, normalG, normalB, HIGHLIGHT_FONT_COLOR:GetRGB());
	GameTooltip:AddDoubleLine(AUCTION_HOUSE_DIALOG_TOTAL_INCREASE, GetMoneyString(totalPriceIncrease), normalR, normalG, normalB, HIGHLIGHT_FONT_COLOR:GetRGB());
	GameTooltip:Show();
end

function AuctionHouseBuyDialogNotificationButtonMixin:OnLeave()
	GameTooltipTextLeft1:SetFontObject(GameTooltipHeaderText);
	GameTooltipTextRight1:SetFontObject(GameTooltipHeaderText);

	GameTooltip:Hide();
end


AuctionHouseBuyDialogButtonMixin = {};

function AuctionHouseBuyDialogButtonMixin:OnClick()
	-- Implement in your derived mixin.
end


AuctionHouseBuyDialogBuyNowButtonMixin = CreateFromMixins(AuctionHouseBuyDialogButtonMixin);

function AuctionHouseBuyDialogBuyNowButtonMixin:OnClick()
	self:GetParent():BuyNow();
	PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
end


AuctionHouseBuyDialogCancelButtonMixin = CreateFromMixins(AuctionHouseBuyDialogButtonMixin);

function AuctionHouseBuyDialogCancelButtonMixin:OnClick()
	self:GetParent():Cancel();
	PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
end


AuctionHouseBuyDialogOkayButtonMixin = CreateFromMixins(AuctionHouseBuyDialogButtonMixin);

function AuctionHouseBuyDialogOkayButtonMixin:OnClick()
	self:GetParent():Cancel();
	PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
end


AuctionHouseBuyDialogMixin = CreateFromMixins(AuctionHouseSystemMixin);

local AUCTION_HOUSE_BUY_DIALOG_EVENTS = {
	"COMMODITY_PRICE_UPDATED",
	"COMMODITY_PRICE_UNAVAILABLE",
	"COMMODITY_PURCHASE_SUCCEEDED",
	"COMMODITY_PURCHASE_FAILED",
};

local BuyState = EnumUtil.MakeEnum(
	"WaitingForQuote",
	"PriceConfirmed",
	"PriceUpdated",
	"PriceUnavailable",
	"Purchasing",
	"Waiting"
);

function AuctionHouseBuyDialogMixin:OnShow()
	FrameUtil.RegisterFrameForEvents(self, AUCTION_HOUSE_BUY_DIALOG_EVENTS);
	self:GetAuctionHouseFrame():SetDialogOverlayShown(true);
end

function AuctionHouseBuyDialogMixin:OnHide()
	self:GetAuctionHouseFrame():SetDialogOverlayShown(false);
	FrameUtil.UnregisterFrameForEvents(self, AUCTION_HOUSE_BUY_DIALOG_EVENTS);

	C_AuctionHouse.CancelCommoditiesPurchase();

	self:GetAuctionHouseFrame():RefreshSearchResults(AuctionHouseSearchContext.BuyCommodities, C_AuctionHouse.MakeItemKey(self.itemID));

	if self.purchaseTimer then
		self.purchaseTimer:Cancel();
	end
end

function AuctionHouseBuyDialogMixin:OnUpdate()
	self.quoteDurationRemaining = C_AuctionHouse.GetQuoteDurationRemaining();
	if self.quoteDurationRemaining == 0 then
		self:Hide();
		return;
	end

	self:UpdateTimeLeft();
end

function AuctionHouseBuyDialogMixin:UpdateTimeLeft()
	local showQuoteDuration = self.quoteDurationRemaining <= REMAINING_QUOTE_DURATION_THRESHOLD;
	self.TimeLeftText:SetShown(showQuoteDuration);
	if showQuoteDuration then
		self.TimeLeftText:SetText(self.quoteDurationRemaining);
	end
end

function AuctionHouseBuyDialogMixin:OnEvent(event, ...)
	if event == "COMMODITY_PRICE_UPDATED" then
		local updatedUnitPrice, updatedTotalPrice = ...;
		local currentTotalPrice = self.PriceFrame:GetAmount();
		local currentUnitPrice = currentTotalPrice / self.quantity;

		if updatedUnitPrice > (currentUnitPrice * MAXIMUM_PREVIEW_PRICE_DIFFERENTIAL) then
			self:SetState(BuyState.PriceUnavailable);
		elseif updatedUnitPrice > currentUnitPrice then
			local totalPriceIncrease = updatedTotalPrice - currentTotalPrice;
			local unitPriceIncrease = math.ceil(totalPriceIncrease / self.quantity); -- Using math.ceil directly because we want to show copper.
			self.Notification:SetPriceIncreases(unitPriceIncrease, totalPriceIncrease);
			self.PriceFrame:SetAmount(updatedTotalPrice);
			self:SetState(BuyState.PriceUpdated);
		else
			self:SetState(BuyState.PriceConfirmed);
		end
	elseif event == "COMMODITY_PRICE_UNAVAILABLE" then
		self:SetState(BuyState.PriceUnavailable);
	elseif event == "COMMODITY_PURCHASE_SUCCEEDED" then
		PlaySound(SOUNDKIT.LOOT_WINDOW_COIN_SOUND);
		self:Hide();
	elseif event == "COMMODITY_PURCHASE_FAILED" then
		self:SetState(BuyState.PriceUnavailable);
	end
end

function AuctionHouseBuyDialogMixin:SetState(buyState)
	local itemDisplayShown = false;
	local buyNowShown = false;
	local buyNowEnabled = false;
	local okayShown = false;
	local spinnerShown = false;
	local darkOverlayShown = false;
	local notificationText = nil;
	local notificationFontObject = GameFontNormal;
	local showNotificationIcon = false;
	local notificationAnchor = { "CENTER" };
	local dialogHeight = 100;
	if buyState == BuyState.WaitingForQuote then
		itemDisplayShown = true;
		buyNowShown = true;
	elseif buyState == BuyState.PriceConfirmed then
		itemDisplayShown = true;
		buyNowShown = true;
		buyNowEnabled = true;
	elseif buyState == BuyState.PriceUpdated then
		dialogHeight = 126;
		itemDisplayShown = true;
		buyNowShown = true;
		buyNowEnabled = true;
		notificationText = AUCTION_HOUSE_DIALOG_PRICE_UPDATED;
		showNotificationIcon = true;
		notificationAnchor = { "BOTTOM", self.OkayButton, "TOP", 0, 13 };
	elseif buyState == BuyState.PriceUnavailable then
		okayShown = true;
		dialogHeight = 85;
		notificationText = AUCTION_HOUSE_DIALOG_PRICE_UNAVAILABLE;
		notificationFontObject = GameFontNormal;

		local topOffset = 20;
		local bottomOffset = self.OkayButton:GetTop() - self:GetBottom();
		local yOffset = (dialogHeight - (bottomOffset + topOffset)) / 2;
		notificationAnchor = { "CENTER", self.OkayButton, "TOP", 0, yOffset };
	elseif buyState == BuyState.Purchasing then
		buyNowShown = true;
		itemDisplayShown = true;
	elseif buyState == BuyState.Waiting then
		buyNowShown = true;
		itemDisplayShown = true;
		spinnerShown = true;
		darkOverlayShown = true;
	else
		self:Cancel();
	end

	self.ItemDisplay:SetShown(itemDisplayShown);
	self.PriceFrame:SetShown(itemDisplayShown);
	self.BuyNowButton:SetShown(buyNowShown);
	self.CancelButton:SetShown(buyNowShown);
	self.CancelButton:SetEnabled(buyNowEnabled);
	self.OkayButton:SetShown(okayShown);
	self.LoadingSpinner:SetShown(spinnerShown);
	self.DarkOverlay:SetShown(darkOverlayShown);
	self.Notification:SetShown(notificationText ~= nil);
	self.Notification:SetNotificationText(notificationText or "", notificationFontObject, showNotificationIcon);
	self.Notification:ClearAllPoints();
	self.Notification:SetPoint(unpack(notificationAnchor));
	self:SetHeight(dialogHeight);

	if not buyNowEnabled then
		self.BuyNowButton:SetDisableTooltip("");
	elseif self.PriceFrame:GetAmount() > GetMoney() then
		self.BuyNowButton:SetDisableTooltip(AUCTION_HOUSE_TOOLTIP_TITLE_NOT_ENOUGH_MONEY);
	else
		self.BuyNowButton:SetDisableTooltip(nil);
	end

	local quoteTimeoutActive = buyState == BuyState.PriceConfirmed or buyState == BuyState.PriceUpdated;
	self:SetScript("OnUpdate", quoteTimeoutActive and AuctionHouseBuyDialogMixin.OnUpdate or nil);
end

function AuctionHouseBuyDialogMixin:SetItemID(itemID, quantity, unitPricePreview, totalPricePreview)
	self.itemID = itemID;
	self.quantity = quantity;
	self.unitPricePreview = AuctionHouseUtil.SanitizeAuctionHousePrice(unitPricePreview);

	local itemName = C_Item.GetItemNameByID(itemID);
	local itemQuality = C_Item.GetItemQualityByID(itemID);
	if itemName and itemQuality then
		local itemDisplayText = itemName or "";
		local colorData = ColorManager.GetColorDataForItemQuality(itemQuality or Enum.ItemQuality.Common);
		if colorData then
			itemDisplayText = colorData.color:WrapTextInColorCode(itemName or "");
		end

		self.ItemDisplay.ItemText:SetText(AUCTION_HOUSE_DIALOG_ITEM_FORMAT:format(itemDisplayText, quantity));
	end

	self.PriceFrame:SetAmount(totalPricePreview);

	self:SetState(BuyState.WaitingForQuote);
end

function AuctionHouseBuyDialogMixin:BuyNow()
	self:SetState(BuyState.Purchasing);
	C_AuctionHouse.ConfirmCommoditiesPurchase(self.itemID, self.quantity);

	self.purchaseTimer = C_Timer.NewTimer(2, function()
		self:SetState(BuyState.Waiting);
	end);
end

function AuctionHouseBuyDialogMixin:Cancel()
	self:Hide();
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseBuyDialog.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseBuyDialog.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Frame name="AuctionHouseBuyDialogNotificationFrameTemplate" mixin="AuctionHouseBuyDialogNotificationFrameMixin" virtual="true">
		<Size x="1" y="1"/>
		<Layers>
			<Layer level="OVERLAY">
				<FontString parentKey="Text" inherits="Number13FontWhite" justifyH="CENTER">
					<Anchors>
						<Anchor point="CENTER" x="-15" y="0"/>
						<Anchor point="BOTTOM"/>
					</Anchors>
				</FontString>
			</Layer>
		</Layers>
		<Frames>
			<Button parentKey="Button" mixin="AuctionHouseBuyDialogNotificationButtonMixin">
				<Size x="22" y="22"/>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.Text" relativePoint="RIGHT" x="0" y="0"/>
				</Anchors>
				<Layers>
					<Layer level="ARTWORK">
						<Texture parentKey="HelpI" alphaMode="BLEND" file="Interface\common\help-i"/>
					</Layer>
				</Layers>
				<Scripts>
					<OnEnter method="OnEnter"/>
					<OnLeave method="OnLeave"/>
				</Scripts>
				<HighlightTexture alphaMode="ADD" file="Interface\Minimap\UI-Minimap-ZoomButton-Highlight">
					<Size x="22" y="22"/>
					<Anchors>
						<Anchor point="CENTER" x="0" y="0"/>
					</Anchors>
				</HighlightTexture>
			</Button>
		</Frames>
	</Frame>

	<Button name="AuctionHouseDialogButtonTemplate" mixin="AuctionHouseBuyDialogButtonMixin" inherits="UIPanelButtonTemplate" virtual="true">
		<Size x="120" y="22"/>
		<Anchors>
			<Anchor point="BOTTOM" x="0" y="18"/>
		</Anchors>
		<Scripts>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>

	<Frame name="AuctionHouseBuyDialogTemplate" mixin="AuctionHouseBuyDialogMixin" frameLevel="1000" virtual="true">
		<Size x="420" y="0"/>
		<Frames>
			<Frame parentKey="Border" inherits="DialogBorderDarkTemplate" useParentLevel="true"/>

			<Frame parentKey="ItemDisplay" hidden="true">
				<Size x="1" y="1"/>
				<Anchors>
					<Anchor point="TOP" x="0" y="-17"/>
				</Anchors>
				<Layers>
					<Layer level="OVERLAY">
						<FontString parentKey="ItemText" inherits="Number15FontWhite" justifyH="CENTER">
							<Anchors>
								<Anchor point="TOP"/>
							</Anchors>
						</FontString>
					</Layer>
				</Layers>
			</Frame>
			<Frame parentKey="PriceFrame" inherits="MoneyDisplayFrameTemplate" hidden="true">
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.ItemDisplay.ItemText" relativePoint="BOTTOM" x="0" y="-6"/>
				</Anchors>
				<KeyValues>
					<KeyValue key="useAuctionHouseCopperValue" value="true" type="boolean"/>
					<KeyValue key="resizeToFit" value="true" type="boolean"/>
					<KeyValue key="useAuctionHouseIcons" value="true" type="boolean"/>
				</KeyValues>
			</Frame>

			<Button parentKey="BuyNowButton" mixin="AuctionHouseBuyDialogBuyNowButtonMixin" inherits="AuctionHouseDialogButtonTemplate, ButtonWithDisableTooltipTemplate" text="AUCTION_HOUSE_DIALOG_BUY_NOW" hidden="true">
				<Anchors>
					<Anchor point="CENTER" x="-64" y="0"/>
				</Anchors>
			</Button>
			<Button parentKey="CancelButton" mixin="AuctionHouseBuyDialogCancelButtonMixin" inherits="AuctionHouseDialogButtonTemplate" text="CANCEL" hidden="true">
				<Anchors>
					<Anchor point="CENTER" x="64" y="0"/>
				</Anchors>
			</Button>
			<Button parentKey="OkayButton" mixin="AuctionHouseBuyDialogOkayButtonMixin" inherits="AuctionHouseDialogButtonTemplate" text="OKAY" hidden="true"/>

			<Frame parentKey="Notification" inherits="AuctionHouseBuyDialogNotificationFrameTemplate" hidden="true"/>

			<Frame parentKey="DarkOverlay" setAllPoints="true" hidden="true" frameLevel="1500">
				<Anchors>
					<Anchor point="TOPLEFT" x="11" y="-11"/>
					<Anchor point="BOTTOMRIGHT" x="-11" y="11"/>
				</Anchors>
				<Layers>
					<Layer level="OVERLAY">
						<Texture setAllPoints="true">
							<Color r="0" g="0" b="0" a="0.8"/>
						</Texture>
					</Layer>
				</Layers>
			</Frame>
			<Frame parentKey="LoadingSpinner" hidden="true" inherits="SpinnerTemplate" frameLevel="2000">
				<Size x="60" y="60"/>
				<Anchors>
					<Anchor point="CENTER" x="0" y="0"/>
				</Anchors>
			</Frame>
		</Frames>
		<Layers>
			<Layer level="OVERLAY">
				<FontString parentKey="TimeLeftText" inherits="NumberFontNormalRightRed" justifyH="CENTER">
					<Anchors>
						<Anchor point="RIGHT" x="-25" y="0"/>
						<Anchor point="CENTER" relativeKey="$parent.CancelButton" relativePoint="CENTER"/>
					</Anchors>
				</FontString>
			</Layer>
		</Layers>
		<Scripts>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnUpdate method="OnUpdate"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseBuyDialog.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCategoriesList.lua ---


-- Converted from AuctionUI.lua for the 2019 AH revamp.

local EXPANDED_FILTERS = {};

function AuctionFrameFilters_Update(categoriesList, forceSelectionIntoView)
	AuctionFrameFilters_UpdateCategories(categoriesList, forceSelectionIntoView);
end

function AuctionFrameFilters_UpdateCategories(categoriesList, forceSelectionIntoView)
	local selectedCategoryIndex, selectedSubCategoryIndex = categoriesList:GetSelectedCategory();
	-- Initialize the list of open filters
	EXPANDED_FILTERS = {};
	
	for categoryIndex, categoryInfo in ipairs(AuctionCategories) do
		local selected = selectedCategoryIndex and selectedCategoryIndex == categoryIndex;
		local isToken = categoryInfo:HasFlag("WOW_TOKEN_FLAG");

		tinsert(EXPANDED_FILTERS, { name = categoryInfo.name, type = "category", categoryIndex = categoryIndex, selected = selected, isToken = isToken, });

		if ( selected ) then
			AuctionFrameFilters_AddSubCategories(categoriesList, categoryInfo.subCategories);
		end
	end

	local dataProvider = CreateDataProvider(EXPANDED_FILTERS);
	categoriesList.ScrollBox:SetDataProvider(dataProvider, ScrollBoxConstants.RetainScrollPosition);

	if forceSelectionIntoView and selectedCategoryIndex and (not selectedSubCategoryIndex and not selectedSubSubCategoryIndex) then
		categoriesList.ScrollBox:ScrollToElementDataIndex(selectedCategoryIndex, ScrollBoxConstants.AlignBegin);
	end
end

function AuctionFrameFilters_AddSubCategories(categoriesList, subCategories)
	if subCategories then
		for subCategoryIndex, subCategoryInfo in ipairs(subCategories) do
			local selected = select(2, categoriesList:GetSelectedCategory()) == subCategoryIndex;

			tinsert(EXPANDED_FILTERS, { name = subCategoryInfo.name, type = "subCategory", subCategoryIndex = subCategoryIndex, selected = selected });
		 
			if ( selected ) then
				AuctionFrameFilters_AddSubSubCategories(categoriesList, subCategoryInfo.subCategories);
			end
		end
	end
end

function AuctionFrameFilters_AddSubSubCategories(categoriesList, subSubCategories)
	if subSubCategories then
		for subSubCategoryIndex, subSubCategoryInfo in ipairs(subSubCategories) do
			local selected = select(3, categoriesList:GetSelectedCategory()) == subSubCategoryIndex;
			local isLast = subSubCategoryIndex == #subSubCategories;

			tinsert(EXPANDED_FILTERS, { name = subSubCategoryInfo.name, type = "subSubCategory", subSubCategoryIndex = subSubCategoryIndex, selected = selected, isLast = isLast});
		end
	end
end

function AuctionFrameFilter_OnLoad(self)
	self:SetPushedTextOffset(0, 0);
end

function AuctionFrameFilter_OnEnter(self)
	TruncatedTooltipScript_OnEnter(self);

	self.HighlightTexture:Show();
end

function AuctionFrameFilter_OnLeave(self)
	TruncatedTooltipScript_OnLeave(self);

	self.HighlightTexture:Hide();
end

function AuctionFrameFilter_OnMouseDown(self)
	self.Text:AdjustPointsOffset(1, -1);
end

function AuctionFrameFilter_OnMouseUp(self)
	self.Text:AdjustPointsOffset(-1, 1);
end

AuctionHouseCategoriesListMixin = CreateFromMixins(AuctionHouseSystemMixin);

function AuctionHouseCategoriesListMixin:OnLoad()
	local view = CreateScrollBoxListLinearView();
	view:SetElementInitializer("AuctionCategoryButtonTemplate", function(button, elementData)
		AuctionHouseFilterButton_SetUp(button, elementData);
		button:SetScript("OnClick", function(button, buttonName)
			self:OnFilterClicked(button, buttonName);
		end);
	end);
	local leftPad = 3;
	local spacing = 0;
	view:SetPadding(0,0,leftPad,0,spacing);

	ScrollUtil.InitScrollBoxListWithScrollBar(self.ScrollBox, self.ScrollBar, view);

	if (AuctionHouseUtil.ApplyClassicBackgroundTexture) then
		AuctionHouseUtil.ApplyClassicBackgroundTexture(self);
	end
end

function AuctionHouseCategoriesListMixin:OnFilterClicked(button, buttonName)
	local selectedCategoryIndex, selectedSubCategoryIndex, selectedSubSubCategoryIndex = self:GetSelectedCategory();
	if ( button.type == "category" ) then
		local wasToken = AuctionFrame_DoesCategoryHaveFlag("WOW_TOKEN_FLAG", selectedCategoryIndex);
		if ( selectedCategoryIndex == button.categoryIndex ) then
			selectedCategoryIndex = nil;
		else
			selectedCategoryIndex = button.categoryIndex;
		end
		selectedSubCategoryIndex = nil;
		selectedSubSubCategoryIndex = nil;
	elseif ( button.type == "subCategory" ) then
		if ( selectedSubCategoryIndex == button.subCategoryIndex ) then
			selectedSubCategoryIndex = nil;
			selectedSubSubCategoryIndex = nil;
		else
			selectedSubCategoryIndex = button.subCategoryIndex;
			selectedSubSubCategoryIndex = nil;
		end
	elseif ( button.type == "subSubCategory" ) then
		if ( selectedSubSubCategoryIndex == button.subSubCategoryIndex ) then
			selectedSubSubCategoryIndex = nil;
		else
			selectedSubSubCategoryIndex = button.subSubCategoryIndex;
		end
	end

	self:SetSelectedCategory(selectedCategoryIndex, selectedSubCategoryIndex, selectedSubSubCategoryIndex);
	AuctionFrameFilters_Update(self, true);
end

function AuctionHouseCategoriesListMixin:OnShow()
	AuctionFrameFilters_Update(self);
end

function AuctionHouseCategoriesListMixin:IsWoWTokenCategorySelected()
	local categoryInfo = AuctionHouseCategory_FindDeepest(self.selectedCategoryIndex, self.selectedSubCategoryIndex, self.selectedSubSubCategoryIndex);
	return categoryInfo and categoryInfo:HasFlag("WOW_TOKEN_FLAG");
end

function AuctionHouseCategoriesListMixin:SetSelectedCategory(selectedCategoryIndex, selectedSubCategoryIndex, selectedSubSubCategoryIndex)
	self.selectedCategoryIndex = selectedCategoryIndex;
	self.selectedSubCategoryIndex = selectedSubCategoryIndex;
	self.selectedSubSubCategoryIndex = selectedSubSubCategoryIndex;

	self:GetAuctionHouseFrame():TriggerEvent(AuctionHouseFrameMixin.Event.CategorySelected, selectedCategoryIndex, selectedSubCategoryIndex, selectedSubSubCategoryIndex);
	
	local displayMode = self:GetAuctionHouseFrame():GetDisplayMode();
	if self:IsWoWTokenCategorySelected() and displayMode ~= AuctionHouseFrameDisplayMode.WoWTokenBuy then
		self:GetAuctionHouseFrame():SetDisplayMode(AuctionHouseFrameDisplayMode.WoWTokenBuy);
	elseif displayMode ~= AuctionHouseFrameDisplayMode.Buy and displayMode ~= AuctionHouseFrameDisplayMode.ItemBuy and displayMode ~= AuctionHouseFrameDisplayMode.CommoditiesBuy then
		self:GetAuctionHouseFrame():SetDisplayMode(AuctionHouseFrameDisplayMode.Buy);
	end

	AuctionFrameFilters_Update(self);
end

function AuctionHouseCategoriesListMixin:GetSelectedCategory()
	return self.selectedCategoryIndex, self.selectedSubCategoryIndex, self.selectedSubSubCategoryIndex;
end

function AuctionHouseCategoriesListMixin:GetCategoryData()
	local selectedCategoryIndex, selectedSubCategoryIndex, selectedSubSubCategoryIndex = self:GetSelectedCategory();
	if selectedCategoryIndex and selectedSubCategoryIndex and selectedSubSubCategoryIndex then
		return AuctionCategories[selectedCategoryIndex].subCategories[selectedSubCategoryIndex].subCategories[selectedSubSubCategoryIndex];
	elseif selectedCategoryIndex and selectedSubCategoryIndex then
		return AuctionCategories[selectedCategoryIndex].subCategories[selectedSubCategoryIndex];
	elseif selectedCategoryIndex then
		return AuctionCategories[selectedCategoryIndex];
	end
end

function AuctionHouseCategoriesListMixin:GetCategoryFilterData()
	local categoryData = self:GetCategoryData();
	if categoryData == nil then
		return nil, nil;
	end

	return categoryData.filters, categoryData.implicitFilter;
end

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCategoriesList.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesBuyFrame.lua ---


AuctionHouseCommoditiesBackButtonMixin = {};

function AuctionHouseCommoditiesBackButtonMixin:OnClick()
	self:GetParent():GetAuctionHouseFrame():SetDisplayMode(AuctionHouseFrameDisplayMode.Buy);
	PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
end


AuctionHouseCommoditiesBuyButtonMixin = {};

function AuctionHouseCommoditiesBuyButtonMixin:OnClick()
	self:GetParent():StartCommoditiesPurchase();
	PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
end


AuctionHouseCommoditiesBuyDisplayMixin = {};

function AuctionHouseCommoditiesBuyDisplayMixin:OnLoad()
	AuctionHouseBackgroundMixin.OnLoad(self);

	self.ItemDisplay.NineSlice:Hide();

	self.QuantityInput.MaxButton:Hide();

	self.ItemDisplay:SetAuctionHouseFrame(self:GetAuctionHouseFrame());

	local function QuantityInputChanged()
		self:GetAuctionHouseFrame():TriggerEvent(AuctionHouseFrameMixin.Event.CommoditiesQuantitySelectionChanged, self.QuantityInput:GetQuantity());
	end

	self.QuantityInput:SetInputChangedCallback(QuantityInputChanged);

	self.quantitySelectionChangedCallback = CommoditiesQuantitySelectionChangedCallback;
end

function AuctionHouseCommoditiesBuyDisplayMixin:OnShow()
	self:RegisterEvent("COMMODITY_PURCHASE_SUCCEEDED");
	self:RegisterEvent("COMMODITY_SEARCH_RESULTS_RECEIVED");

	self.resultsLoaded = false;

	self:Layout();

	self:GetAuctionHouseFrame():RegisterCallback(AuctionHouseFrameMixin.Event.CommoditiesQuantitySelectionChanged, self.OnQuantitySelectionChanged, self);
end

function AuctionHouseCommoditiesBuyDisplayMixin:OnQuantitySelectionChanged(quantity)
	local suppressEvent = true;
	self:SetQuantitySelected(quantity, suppressEvent);
end

function AuctionHouseCommoditiesBuyDisplayMixin:UpdateBuyButton()
	if self.TotalPrice:GetAmount() > GetMoney() then
		self.BuyButton:SetDisableTooltip(AUCTION_HOUSE_TOOLTIP_TITLE_NOT_ENOUGH_MONEY);
	elseif self.QuantityInput:GetQuantity() <= 0 then
		self.BuyButton:SetDisableTooltip(AUCTION_HOUSE_TOOLTIP_TITLE_NONE_AVAILABLE);
	else
		self.BuyButton:SetDisableTooltip(nil);
	end
end

function AuctionHouseCommoditiesBuyDisplayMixin:SetItemIDAndPrice(itemID, minPrice)
	if itemID then
		self.ItemDisplay:SetItem(itemID);
		self:SetQuantitySelected(1);
		self:SetPrice(minPrice, minPrice);
	else
		self.ItemDisplay:SetItem(nil);
		self:SetQuantitySelected(0);
		self:SetPrice(0, 0);
	end
end

function AuctionHouseCommoditiesBuyDisplayMixin:SetPrice(unitPrice, totalPrice)
	self.UnitPrice:SetAmount(unitPrice);
	self.TotalPrice:SetAmount(totalPrice);

	self:UpdateBuyButton();
end

function AuctionHouseCommoditiesBuyDisplayMixin:GetItemID()
	return self.ItemDisplay:GetItemID();
end

function AuctionHouseCommoditiesBuyDisplayMixin:OnHide()
	self:UnregisterEvent("COMMODITY_PURCHASE_SUCCEEDED");
	self:UnregisterEvent("COMMODITY_SEARCH_RESULTS_RECEIVED");

	self:GetAuctionHouseFrame():UnregisterCallback(AuctionHouseFrameMixin.Event.CommoditiesQuantitySelectionChanged, self);
end

function AuctionHouseCommoditiesBuyDisplayMixin:OnEvent(event, ...)
	if event == "COMMODITY_PURCHASE_SUCCEEDED" then
		self.QuantityInput:SetQuantity(1);
		self:GetAuctionHouseFrame():TriggerEvent(AuctionHouseFrameMixin.Event.CommoditiesQuantitySelectionChanged, self.QuantityInput:GetQuantity());
	elseif event == "COMMODITY_SEARCH_RESULTS_RECEIVED" then
		self.resultsLoaded = true;
	end
end

function AuctionHouseCommoditiesBuyDisplayMixin:SetQuantitySelected(quantity)
	local totalQuantity = 1;
	local totalPrice = 0;
	local commodityItemKey = C_AuctionHouse.MakeItemKey(self:GetItemID());
	if C_AuctionHouse.HasSearchResults(commodityItemKey) and self.resultsLoaded then
		-- Total quantity will be restricted to at most the entire amount available on the auction house.
		-- This means the user is prevented from entering an amount to buy greater than the available supply.
		totalQuantity, totalPrice = AuctionHouseUtil.AggregateSearchResultsByQuantity(self:GetItemID(), quantity);
		if totalQuantity == 0 then
			self.QuantityInput:SetQuantity(0);
			self:SetPrice(0, 0);
			return;
		end
	end

	if self.oldQuantitySelected ~= quantity then
		self.QuantityInput:SetQuantity(self.resultsLoaded and totalQuantity or quantity);
		self.oldQuantitySelected = quantity;
	end
	
	local unitPrice = AuctionHouseUtil.SanitizeAuctionHousePrice(totalPrice / totalQuantity);
	self:SetPrice(unitPrice, totalPrice);
end

function AuctionHouseCommoditiesBuyDisplayMixin:GetQuantitySelected()
	return self.QuantityInput:GetQuantity();
end

function AuctionHouseCommoditiesBuyDisplayMixin:StartCommoditiesPurchase()
	local itemID = self:GetItemID();
	if not itemID then
		return;
	end

	local quantity = self:GetQuantitySelected();
	local unitPrice = self.UnitPrice:GetAmount();
	local totalPrice = self.TotalPrice:GetAmount();
	self:GetAuctionHouseFrame():StartCommoditiesPurchase(itemID, quantity, unitPrice, totalPrice);
end

function AuctionHouseCommoditiesBuyDisplayMixin:GetAuctionHouseFrame()
	return self:GetParent():GetAuctionHouseFrame();
end


AuctionHouseCommoditiesBuyFrameMixin = CreateFromMixins(AuctionHouseSortOrderSystemMixin);

function AuctionHouseCommoditiesBuyFrameMixin:OnLoad()
	AuctionHouseSortOrderSystemMixin.OnLoad(self);

	self:SetSearchContext(AuctionHouseSearchContext.BuyCommodities);

	self.ItemList:SetSelectionCallback(AuctionHouseUtil.GenerateRowSelectedCallbackWithLink(self, self.OnAuctionSelected));
end

function AuctionHouseCommoditiesBuyFrameMixin:GetItemID()
	return self.BuyDisplay:GetItemID();
end

function AuctionHouseCommoditiesBuyFrameMixin:OnAuctionSelected(searchResultInfo)
	local totalQuantity = AuctionHouseUtil.AggregateCommoditySearchResultsByMaxPrice(self:GetItemID(), searchResultInfo.unitPrice);
	self:GetAuctionHouseFrame():TriggerEvent(AuctionHouseFrameMixin.Event.CommoditiesQuantitySelectionChanged, totalQuantity);
	return true;
end

function AuctionHouseCommoditiesBuyFrameMixin:SetItemIDAndPrice(itemID, price)
	self.BuyDisplay:SetItemIDAndPrice(itemID, price);
	self.ItemList:SetItemID(itemID);
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesBuyFrame.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesBuyFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Frame name="AuctionHouseCommoditiesBuyDisplayTemplate" inherits="VerticalLayoutFrame, AuctionHouseBackgroundTemplate" mixin="AuctionHouseCommoditiesBuyDisplayMixin" virtual="true">
		<KeyValues>
			<KeyValue key="topPadding" value="19" type="number"/>
			<KeyValue key="bottomPadding" value="120" type="number"/>
			<KeyValue key="leftPadding" value="15" type="number"/>
			<KeyValue key="rightPadding" value="16" type="number"/>
			
			<KeyValue key="spacing" value="15" type="number"/>

			<KeyValue key="backgroundAtlas" value="auctionhouse-background-buy-commodities" type="string"/>
			<KeyValue key="backgroundTextureClassic" value="Interface\QuestFrame\UI-TextBackground-BackdropBackground" type="string"/>
			<KeyValue key="textureWidthClassic" value="368" type="number"/>
			<KeyValue key="textureHeightClassic" value="397" type="number"/>
			<KeyValue key="textureXOffsetClassic" value="2" type="number"/>
			<KeyValue key="textureYOffsetClassic" value="-2" type="number"/>
		</KeyValues>
		<Frames>
			<Button parentKey="ItemDisplay" inherits="AuctionHouseItemDisplayTemplate">
				<Size x="342" y="72"/>
				<KeyValues>
					<KeyValue key="itemButtonXOffset" value="11" type="number"/>
					<KeyValue key="itemButtonYOffset" value="0" type="number"/>
					<KeyValue key="bottomPadding" value="8" type="number"/>
					<KeyValue key="layoutIndex" value="10" type="number"/>
				</KeyValues>
				<Layers>
					<Layer level="ARTWORK">
						<Texture atlas="auctionhouse-itemheaderframe" useAtlasSize="true">
							<Anchors>
								<Anchor point="CENTER"/>
							</Anchors>
						</Texture>
					</Layer>
				</Layers>
				<Scripts>
					<OnLoad method="OnLoad"/>
				</Scripts>
			</Button>
			<Frame parentKey="QuantityInput" inherits="AuctionHouseAlignedQuantityInputFrameTemplate">
				<KeyValues>
					<KeyValue key="layoutIndex" value="20" type="number"/>
					<KeyValue key="labelText" value="AUCTION_HOUSE_QUANTITY_LABEL" type="global"/>
				</KeyValues>
			</Frame>
			<Frame parentKey="UnitPrice" inherits="AuctionHouseAlignedPriceDisplayTemplate">
				<KeyValues>
					<KeyValue key="layoutIndex" value="30" type="number"/>
					<KeyValue key="labelText" value="AUCTION_HOUSE_UNIT_PRICE_LABEL" type="global"/>
				</KeyValues>
			</Frame>
			<Frame parentKey="TotalPrice" inherits="AuctionHouseAlignedPriceDisplayTemplate">
				<KeyValues>
					<KeyValue key="layoutIndex" value="40" type="number"/>
					<KeyValue key="labelText" value="AUCTION_HOUSE_TOTAL_PRICE_LABEL" type="global"/>
				</KeyValues>
			</Frame>

			<Button parentKey="BuyButton" mixin="AuctionHouseCommoditiesBuyButtonMixin" inherits="UIPanelButtonTemplate, ButtonWithDisableTooltipTemplate" text="AUCTION_HOUSE_BUY_BUTTON">
				<KeyValues>
					<KeyValue key="layoutIndex" value="50" type="number"/>
					<KeyValue key="leftPadding" value="110" type="number"/>
				</KeyValues>
				<Size x="196" y="22"/>
				<Scripts>
					<OnClick method="OnClick"/>
				</Scripts>
			</Button>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseCommoditiesBuyFrameTemplate" mixin="AuctionHouseCommoditiesBuyFrameMixin" virtual="true">
		<Frames>
			<Button parentKey="BackButton" mixin="AuctionHouseCommoditiesBackButtonMixin" inherits="UIPanelButtonTemplate" text="AUCTION_HOUSE_BACK_BUTTON">
				<Size x="110" y="22"/>
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent" relativePoint="TOPLEFT" x="11" y="-9"/>
				</Anchors>
				<Scripts>
					<OnClick method="OnClick"/>
				</Scripts>
			</Button>
			<Frame parentKey="BuyDisplay" inherits="AuctionHouseCommoditiesBuyDisplayTemplate">
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.BackButton" relativePoint="BOTTOM" x="0" y="-10"/>
					<Anchor point="LEFT"/>
					<Anchor point="BOTTOM"/>
				</Anchors>
			</Frame>
			<Frame parentKey="ItemList" inherits="AuctionHouseCommoditiesBuyListTemplate">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.BuyDisplay" relativePoint="TOPRIGHT" x="1" y="0"/>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent.BuyDisplay" relativePoint="BOTTOMRIGHT" x="2" y="0"/>
					<Anchor point="RIGHT" x="-4"/>
				</Anchors>
				<KeyValues>
					<KeyValue key="scrollbarYOffsetClassic" value="-17" type="number"/>
				</KeyValues>
			</Frame>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesBuyFrame.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesList.lua ---


local COMMODITIES_LIST_SCROLL_OFFSET_REFRESH_THRESHOLD = 30;
local MINIMUM_UNSELECTED_ENTRIES = 6;


AuctionHouseCommoditiesListMixin = CreateFromMixins(AuctionHouseItemListMixin, AuctionHouseSystemMixin);

local AUCTION_HOUSE_COMMODITIES_LIST_EVENTS = {
	"COMMODITY_SEARCH_RESULTS_UPDATED",
	"COMMODITY_SEARCH_RESULTS_RECEIVED",
	"COMMODITY_SEARCH_RESULTS_ADDED",
};

function AuctionHouseCommoditiesListMixin:OnLoad()
	AuctionHouseItemListMixin.OnLoad(self);
	
	local function CommoditiesListGetTotalQuantity()
		return self.itemID and C_AuctionHouse.GetCommoditySearchResultsQuantity(self.itemID) or 0;
	end

	local function CommoditiesListRefreshResults()
		self.resultsLoaded = false;

		if self.itemID then
			self:GetAuctionHouseFrame():RefreshSearchResults(self.searchContext, C_AuctionHouse.MakeItemKey(self.itemID));
		end
	end

	self:SetRefreshFrameFunctions(CommoditiesListGetTotalQuantity, CommoditiesListRefreshResults);
end

function AuctionHouseCommoditiesListMixin:OnShow()
	self:UpdateDataProvider();

	self.resultsLoaded = false;

	AuctionHouseItemListMixin.OnShow(self);

	FrameUtil.RegisterFrameForEvents(self, AUCTION_HOUSE_COMMODITIES_LIST_EVENTS);
end

function AuctionHouseCommoditiesListMixin:OnHide()
	FrameUtil.UnregisterFrameForEvents(self, AUCTION_HOUSE_COMMODITIES_LIST_EVENTS);
end

function AuctionHouseCommoditiesListMixin:OnEvent(event, ...)
	if event == "COMMODITY_SEARCH_RESULTS_UPDATED" then
		self:Reset();
	elseif event == "COMMODITY_SEARCH_RESULTS_RECEIVED" then
		self.resultsLoaded = true;
		self:Reset();
	elseif event == "COMMODITY_SEARCH_RESULTS_ADDED" then
		self:DirtyScrollFrame();
	end
end

function AuctionHouseCommoditiesListMixin:SetItemID(itemID)
	self.itemID = itemID;
	self:UpdateDataProvider();
	self:DirtyScrollFrame();
end

function AuctionHouseCommoditiesListMixin:UpdateDataProvider()
	local itemID = self.itemID;

	local function CommoditiesListSearchStarted()
		return itemID ~= nil;
	end

	local function CommoditiesListGetEntry(index)
		return C_AuctionHouse.GetCommoditySearchResultInfo(itemID, index);
	end

	local function CommoditiesListGetNumEntries()
		return C_AuctionHouse.GetNumCommoditySearchResults(itemID);
	end

	local function CommoditiesListHasFullResults()
		return C_AuctionHouse.HasFullCommoditySearchResults(itemID);
	end

	self:SetDataProvider(CommoditiesListSearchStarted, CommoditiesListGetEntry, CommoditiesListGetNumEntries, CommoditiesListHasFullResults);
end

function AuctionHouseCommoditiesListMixin:RefreshScrollFrame()
	AuctionHouseItemListMixin.RefreshScrollFrame(self);

	if not self.isInitialized or not self.itemID then
		return;
	end

	self:GetAuctionHouseFrame():TriggerEvent(AuctionHouseFrameMixin.Event.CommoditiesQuantitySelectionChanged, self.quantitySelected);

	if C_AuctionHouse.HasFullCommoditySearchResults(self.itemID) then
		return;
	end

	local numEntries = C_AuctionHouse.GetNumCommoditySearchResults(self.itemID);
	if numEntries > 0 and (numEntries - self.ScrollBox:GetDataIndexEnd() < COMMODITIES_LIST_SCROLL_OFFSET_REFRESH_THRESHOLD) then
		C_AuctionHouse.RequestMoreCommoditySearchResults(self.itemID);
	end
end


AuctionHouseCommoditiesBuyListMixin = CreateFromMixins(AuctionHouseCommoditiesListMixin);

function AuctionHouseCommoditiesBuyListMixin:OnLoad()
	AuctionHouseItemListMixin.OnLoad(self);
	
	local function CommoditiesListGetTotalQuantity()
		return self.itemID and C_AuctionHouse.GetCommoditySearchResultsQuantity(self.itemID) or 0;
	end

	local function CommoditiesListRefreshResults()
		self.resultsLoaded = false;
		self:GetParent().BuyDisplay.resultsLoaded = false;

		if self.itemID then
			self:GetAuctionHouseFrame():RefreshSearchResults(self.searchContext, C_AuctionHouse.MakeItemKey(self.itemID));
		end
	end
	self:SetRefreshFrameFunctions(CommoditiesListGetTotalQuantity, CommoditiesListRefreshResults);

	self:SetTableBuilderLayout(AuctionHouseTableBuilder.GetCommoditiesBuyListLayout(self));
	self.quantitySelected = 1;

	self.getEntryInfoCallback = function(index)
		return C_AuctionHouse.GetCommoditySearchResultInfo(self.itemID, index);
	end

	self.ScrollBox:SetPoint("TOPLEFT", self.HeaderContainer, "TOPLEFT", 0, -6);
end

function AuctionHouseCommoditiesBuyListMixin:OnEnterListLine(line, rowData)
	if rowData.containsOwnerItem then
		GameTooltip:SetOwner(line, "ANCHOR_RIGHT");
		GameTooltip_SetTitle(GameTooltip, AUCTION_HOUSE_OWNED_COMMODITIES_LINE_TOOLTIP_TITLE);
		GameTooltip_AddNormalLine(GameTooltip, AUCTION_HOUSE_OWNED_COMMODITIES_LINE_TOOLTIP_TEXT);
		GameTooltip:Show();
	end
end

function AuctionHouseCommoditiesBuyListMixin:OnLeaveListLine(line, rowData)
	GameTooltip:Hide();
end

function AuctionHouseCommoditiesBuyListMixin:UpdateDynamicCallbacks()
	-- These callbacks are based on quantity selected and need to be reset when the quantity selection changes.

	-- Also note that because commodities are selected and highlighted in order, the later results depend
	-- on the earlier ones, so these callbacks also need to be reset when the scroll frame is refreshed.

	self:UpdateListHighlightCallback();
end

function AuctionHouseCommoditiesBuyListMixin:UpdateListHighlightCallback()
	if not self.quantitySelected or self.quantitySelected == 0 then
		self:SetHighlightCallback(nil);
	else
		self:SetHighlightCallback(function(currentRowData, selectedRowData, currentRowIndex)
			local shouldHighlight = currentRowIndex <= (self.resultsMaxHighlightIndex or 0);
			local highlightAlpha = (currentRowData.containsOwnerItem or currentRowData.containsAccountItem or 
					(currentRowIndex == self.resultsMaxHighlightIndex and self.resultsPartiallyPurchased)) and 0.5 or 1.0;
			return shouldHighlight, highlightAlpha;
		end);
	end
end

function AuctionHouseCommoditiesBuyListMixin:SetQuantitySelected(quantity)
	local canUseSearchResults = self.itemID and C_AuctionHouse.HasSearchResults(C_AuctionHouse.MakeItemKey(self.itemID)) and self.resultsLoaded;
	local oldQuantitySelected = self.quantitySelected;
	self.quantitySelected = quantity;
	if canUseSearchResults then
		local totalItemQuantity = C_AuctionHouse.GetCommoditySearchResultsQuantity(self.itemID);
		self.quantitySelected = math.min(totalItemQuantity, quantity);
	else 
		return;
	end

	if self.resultsMaxHighlightIndex == nil or oldQuantitySelected ~= self.quantitySelected then
		self.resultsMaxHighlightIndex, self.resultsPartiallyPurchased = select(3, AuctionHouseUtil.AggregateSearchResultsByQuantity(self.itemID, self.quantitySelected));
		if self.ScrollBox:HasView() and self.ScrollBox:HasDataProvider() then
			local scrollIndex = math.min(self.ScrollBox:GetDataProviderSize(), self.resultsMaxHighlightIndex + MINIMUM_UNSELECTED_ENTRIES);
			self.ScrollBox:ScrollToElementDataIndex(scrollIndex, ScrollBoxConstants.AlignEnd);
		end

		self:UpdateDynamicCallbacks();
		self:DirtyScrollFrame();
	elseif self.resultsLoaded then
		self.resultsMaxHighlightIndex, self.resultsPartiallyPurchased = select(3, AuctionHouseUtil.AggregateSearchResultsByQuantity(self.itemID, self.quantitySelected));
	end
end

function AuctionHouseCommoditiesBuyListMixin:OnShow()
	AuctionHouseCommoditiesListMixin.OnShow(self);

	self:GetAuctionHouseFrame():RegisterCallback(AuctionHouseFrameMixin.Event.CommoditiesQuantitySelectionChanged, self.OnCommoditiesQuantitySelectionChanged, self);
end

function AuctionHouseCommoditiesBuyListMixin:OnHide()
	AuctionHouseCommoditiesListMixin.OnHide(self);

	self:GetAuctionHouseFrame():UnregisterCallback(AuctionHouseFrameMixin.Event.CommoditiesQuantitySelectionChanged, self);
end

function AuctionHouseCommoditiesBuyListMixin:OnCommoditiesQuantitySelectionChanged(quantity)
	self:SetQuantitySelected(quantity);
end

function AuctionHouseCommoditiesBuyListMixin:SetItemID(itemID)
	AuctionHouseCommoditiesListMixin.SetItemID(self, itemID);

	self.resultsMaxHighlightIndex = nil;
	self:SetQuantitySelected(1);
end

function AuctionHouseCommoditiesBuyListMixin:UpdateDataProvider() -- Overrides AuctionHouseCommoditiesListMixin
	local itemID = self.itemID;

	local function CommoditiesBuyListSearchStarted()
		return itemID ~= nil;
	end

	local function CommoditiesBuyListGetEntry(index)
		return self.getEntryInfoCallback(index);
	end

	local function CommoditiesBuyListGetNumEntries()
		return C_AuctionHouse.GetNumCommoditySearchResults(itemID);
	end

	local function CommoditiesBuyListHasFullResults()
		return C_AuctionHouse.HasFullCommoditySearchResults(itemID);
	end

	self:SetDataProvider(CommoditiesBuyListSearchStarted, CommoditiesBuyListGetEntry, CommoditiesBuyListGetNumEntries, CommoditiesBuyListHasFullResults);
end

function AuctionHouseCommoditiesBuyListMixin:GetAuctionHouseFrame() -- Overrides AuctionHouseCommoditiesListMixin
	return self:GetParent():GetAuctionHouseFrame();
end

function AuctionHouseCommoditiesBuyListMixin:RefreshScrollFrame()
	self:UpdateDynamicCallbacks();

	AuctionHouseCommoditiesListMixin.RefreshScrollFrame(self);
end


AuctionHouseCommoditiesSellListMixin = CreateFromMixins(AuctionHouseCommoditiesListMixin);

function AuctionHouseCommoditiesSellListMixin:OnLoad()
	AuctionHouseCommoditiesListMixin.OnLoad(self);

	self:SetTableBuilderLayout(AuctionHouseTableBuilder.GetCommoditiesSellListLayout(self, self));

	self:SetHighlightCallback(function(currentRowData, selectedRowData)
		return selectedRowData and currentRowData.unitPrice == selectedRowData.unitPrice;
	end);
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesList.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesList.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Frame name="AuctionHouseCommoditiesListTemplate" mixin="AuctionHouseCommoditiesListMixin" inherits="AuctionHouseItemListTemplate" virtual="true">
		<KeyValues>
			<!--
			searchContext: What search context should be used for this list when refreshing search results.
			<KeyValue key="searchContext" value="AuctionHouseSearchContext.BuyCommodities" type="global"/>
			-->

			<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
			<KeyValue key="refreshFrameYOffset" value="30" type="number"/>
		</KeyValues>
		<Size x="210" y="400"/>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseCommoditiesBuyListTemplate" mixin="AuctionHouseCommoditiesBuyListMixin" inherits="AuctionHouseCommoditiesListTemplate" virtual="true">
		<KeyValues>
			<KeyValue key="backgroundAtlas" value="auctionhouse-background-buy-commodities-market" type="string"/>
			<KeyValue key="textureWidthClassic" value="221" type="number"/>
			<KeyValue key="textureHeightClassic" value="397" type="number"/>
			<KeyValue key="backgroundYOffset" value="0" type="number"/>
			<KeyValue key="searchContext" value="AuctionHouseSearchContext.BuyCommodities" type="global"/>
		</KeyValues>
	</Frame>

	<Frame name="AuctionHouseCommoditiesSellListTemplate" mixin="AuctionHouseCommoditiesSellListMixin" inherits="AuctionHouseCommoditiesListTemplate" virtual="true">
		<KeyValues>
			<KeyValue key="backgroundAtlas" value="auctionhouse-background-sell-right" type="string"/>
			<KeyValue key="textureWidthClassic" value="399" type="number"/>
			<KeyValue key="textureHeightClassic" value="419" type="number"/>
			<KeyValue key="searchContext" value="AuctionHouseSearchContext.SellCommodities" type="global"/>
			<KeyValue key="refreshFrameXOffset" value="-8" type="number"/>
			<KeyValue key="refreshFrameYOffset" value="30" type="number"/>
		</KeyValues>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesList.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesSellFrame.lua ---


AuctionHouseCommoditiesSellFrameMixin = CreateFromMixins(AuctionHouseSellFrameMixin);

local COMMODITIES_SELL_FRAME_EVENTS = {
	"COMMODITY_SEARCH_RESULTS_UPDATED",
};

function AuctionHouseCommoditiesSellFrameMixin:Init()
	if self.isInitialized then
		return;
	end

	self.isInitialized = true;

	self:SetSearchContext(AuctionHouseSearchContext.SellCommodities);

	local commoditiesSellList = self:GetCommoditiesSellList();
	commoditiesSellList:SetSelectionCallback(AuctionHouseUtil.GenerateRowSelectedCallbackWithLink(self, self.OnAuctionSelected));

	commoditiesSellList:RefreshScrollFrame();
end

function AuctionHouseCommoditiesSellFrameMixin:OnShow()
	AuctionHouseSellFrameMixin.OnShow(self);

	FrameUtil.RegisterFrameForEvents(self, COMMODITIES_SELL_FRAME_EVENTS);

	self.PriceInput.PerItemPostfix:Show();

	-- We need to use a separate Init instead of OnLoad to avoid load order problems.
	self:Init();
end

function AuctionHouseCommoditiesSellFrameMixin:OnHide()
	AuctionHouseSellFrameMixin.OnHide(self);

	FrameUtil.UnregisterFrameForEvents(self, COMMODITIES_SELL_FRAME_EVENTS);
end

function AuctionHouseCommoditiesSellFrameMixin:OnEvent(event, ...)
	AuctionHouseSellFrameMixin.OnEvent(self, event, ...);

	if event == "COMMODITY_SEARCH_RESULTS_UPDATED" then
		self:UpdatePriceSelection();
	end
end

function AuctionHouseCommoditiesSellFrameMixin:UpdatePriceSelection()
	self:ClearSearchResultPrice();

	if (self:GetUnitPrice() == self:GetDefaultPrice() and C_AuctionHouse.ShouldAutoPopulatePrice()) then
		local itemLocation = self:GetItem();
		if itemLocation then
			local firstSearchResult = C_AuctionHouse.GetCommoditySearchResultInfo(C_Item.GetItemID(itemLocation), 1);
			if firstSearchResult then
				self:GetCommoditiesSellList():SetSelectedEntry(firstSearchResult);
			end
		end
	else
		self:GetCommoditiesSellList():SetSelectedEntry(nil);
	end
end

function AuctionHouseCommoditiesSellFrameMixin:OnAuctionSelected(commoditySearchResult)
	if (not commoditySearchResult) then
		return;
	end

	self.PriceInput:SetAmount(commoditySearchResult.unitPrice);
	self:SetSearchResultPrice(commoditySearchResult.unitPrice);
end

function AuctionHouseCommoditiesSellFrameMixin:GetUnitPrice()
	local unitPrice = self.PriceInput:GetAmount();
	return unitPrice;
end

function AuctionHouseCommoditiesSellFrameMixin:GetDepositAmount()
	local item = self:GetItem();
	if not item or not item:IsValid() then
		return 0;
	end

	local duration = self:GetDuration();
	local quantity = self:GetQuantity();
	local deposit = C_AuctionHouse.CalculateCommodityDeposit(C_Item.GetItemID(item), duration, quantity);
	return deposit;
end

function AuctionHouseCommoditiesSellFrameMixin:GetTotalPrice()
	return self:GetQuantity() * self:GetUnitPrice();
end

function AuctionHouseCommoditiesSellFrameMixin:CanPostItem()
	local canPostItem, reasonTooltip = AuctionHouseSellFrameMixin.CanPostItem(self);
	if not canPostItem then
		return canPostItem, reasonTooltip;
	end

	local unitPrice = self:GetUnitPrice();
	if unitPrice == 0 then
		return false, AUCTION_HOUSE_SELL_FRAME_ERROR_PRICE;
	end

	return true, nil;
end

function AuctionHouseCommoditiesSellFrameMixin:GetPostDetails()
	local item = self:GetItem();
	local duration = self:GetDuration();
	local quantity = self:GetQuantity();
	local unitPrice = self:GetUnitPrice();

	return item, duration, quantity, unitPrice;
end

function AuctionHouseCommoditiesSellFrameMixin:StartPost(...)
	if not self:CanPostItem() then
		return;
	end

	if not C_AuctionHouse.PostCommodity(...) then
		self:ClearPost();
	else
		self:CachePendingPost(...);
	end
end

function AuctionHouseCommoditiesSellFrameMixin:PostItem()
	self:StartPost(self:GetPostDetails());
end

function AuctionHouseCommoditiesSellFrameMixin:ConfirmPost()
	if self.pendingPost then
		C_AuctionHouse.ConfirmPostCommodity(SafeUnpack(self.pendingPost));
		self:ClearPost();
		return true;
	end
end

function AuctionHouseCommoditiesSellFrameMixin:CachePendingPost(...)
	self.pendingPost = SafePack(...);
end

function AuctionHouseCommoditiesSellFrameMixin:ClearPost()
	self.pendingPost = nil;

	local fromItemDisplay = nil;
	local refreshListWithPreviousItem = true;
	self:SetItem(nil, fromItemDisplay, refreshListWithPreviousItem);
end

function AuctionHouseCommoditiesSellFrameMixin:SetItem(itemLocation, fromItemDisplay, refreshListWithPreviousItem)
	local previousItemLocation = self:GetItem();

	AuctionHouseSellFrameMixin.SetItem(self, itemLocation, fromItemDisplay);

	local itemKey = itemLocation and C_AuctionHouse.GetItemKeyFromItem(itemLocation) or nil;
	if refreshListWithPreviousItem then
		local previousItemKey = previousItemLocation and C_AuctionHouse.GetItemKeyFromItem(previousItemLocation) or nil;
		if previousItemKey then
			itemKey = previousItemKey;
		end
	end

	if itemKey then
		self:GetAuctionHouseFrame():QueryItem(self:GetSearchContext(), itemKey);
	end

	self:UpdatePriceSelection();

	if itemLocation then
		self.QuantityInput:SetQuantity(C_Item.GetStackCount(itemLocation));
		self:UpdateTotalPrice();

		-- Hack fix for a spacing problem: Without this line, the edit box would be scrolled to
		-- the left and the text would not be visible. This seems to be a problem with setting
		-- the text on the edit box and showing it in the same frame.
		self.QuantityInput.InputBox:SetCursorPosition(0);
	end

	self:GetCommoditiesSellList():SetItemID(itemKey and itemKey.itemID or nil);
end

function AuctionHouseCommoditiesSellFrameMixin:GetCommoditiesSellList()
	local commoditiesSellList = self:GetAuctionHouseFrame():GetCommoditiesSellListFrames();
	return commoditiesSellList;
end

function AuctionHouseCommoditiesSellFrameMixin:GetCommoditiesSellListFrames()
	return self:GetAuctionHouseFrame():GetCommoditiesSellListFrames();
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesSellFrame.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesSellFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	
	<Frame name="AuctionHouseCommoditiesSellFrameTemplate" inherits="AuctionHouseSellFrameTemplate" mixin="AuctionHouseCommoditiesSellFrameMixin" virtual="true">
		<Scripts>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseCommoditiesSellFrame.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseFrame.lua ---


g_auctionHouseSortsBySearchContext = g_auctionHouseSortsBySearchContext or nil;
g_outbidAuctionIDs = g_outbidAuctionIDs or nil;
g_activeBidAuctionIDs = g_activeBidAuctionIDs or nil;

local MaxNumActiveBidsTracked = 100;

UIPanelWindows["AuctionHouseFrame"] = { area = "doublewide", pushable = 0, xoffset = 20, yoffset = -0, showFailedFunc = C_AuctionHouse.CloseAuctionHouse, };

local function BuyoutDialogOnAccept(popup)
	C_AuctionHouse.PlaceBid(popup.data.auctionID, popup.data.buyout);
end

local function BuyoutDialogOnEvent(popup, event, ...)
	if event == "AUCTION_HOUSE_PURCHASE_COMPLETED" then
		local auctionID = ...;
		if auctionID == popup.data.auctionID then
			return true;
		end
	elseif event == "AUCTION_HOUSE_SHOW_ERROR" then
		return true;
	end
	return false;
end

StaticPopupDialogs["BUYOUT_AUCTION"] = {
	text = BUYOUT_AUCTION_CONFIRMATION,
	button1 = ACCEPT,
	button2 = CANCEL,

	OnAccept = GenerateClosure(StaticPopup_OnAcceptWithSpinner, BuyoutDialogOnAccept, BuyoutDialogOnEvent, {"AUCTION_HOUSE_PURCHASE_COMPLETED", "AUCTION_HOUSE_SHOW_ERROR"}, 2),
	OnShow = function(self)
		MoneyFrame_Update(self.moneyFrame, self.data.buyout);
	end,
	hasMoneyFrame = 1,
	showAlert = 1,
	timeout = 0,
	exclusive = 1,
	hideOnEscape = 1
};

StaticPopupDialogs["BID_AUCTION"] = {
	text = BID_AUCTION_CONFIRMATION,
	button1 = ACCEPT,
	button2 = CANCEL,
	OnAccept = function(self)
		C_AuctionHouse.PlaceBid(self.data.auctionID, self.data.bid);
	end,
	OnShow = function(self)
		MoneyFrame_Update(self.moneyFrame, self.data.bid);
	end,
	hasMoneyFrame = 1,
	showAlert = 1,
	timeout = 0,
	exclusive = 1,
	hideOnEscape = 1
};

StaticPopupDialogs["PURCHASE_AUCTION_UNIQUE"] = {
	text = "",
	button1 = OKAY,
	button2 = CANCEL,
	OnShow = function(self, data)
		self.text:SetText(PURCHASE_UNIQUE_AUCTION_CONFIRMATION:format(data.categoryName));
	end,
	OnAccept = function(self, data)
		data.callback();
	end,

	showAlert = 1,
	timeout = 0,
	exclusive = 1,
	hideOnEscape = 1,
	acceptDelay = 3,
};

StaticPopupDialogs["CANCEL_AUCTION"] = {
	text = CANCEL_AUCTION_CONFIRMATION,
	button1 = ACCEPT,
	button2 = CANCEL,
	OnAccept = function(self)
		C_AuctionHouse.CancelAuction(self.data.auctionID);
	end,
	OnShow = function(self)
		local cancelCost = C_AuctionHouse.GetCancelCost(self.data.auctionID);
		MoneyFrame_Update(self.moneyFrame, cancelCost);
		if cancelCost > 0 then
			self.text:SetText(CANCEL_AUCTION_CONFIRMATION_MONEY);
		else
			self.text:SetText(CANCEL_AUCTION_CONFIRMATION);
		end
	end,
	hasMoneyFrame = 1,
	showAlert = 1,
	timeout = 0,
	exclusive = 1,
	hideOnEscape = 1
};

StaticPopupDialogs["AUCTION_HOUSE_POST_WARNING"] = {
	text = NORMAL_FONT_COLOR:WrapTextInColorCode(CONFIRM_AUCTION_POSTING_TEXT),
	button1 = ACCEPT,
	button2 = CANCEL,
	OnAccept = function ()
		if not AuctionHouseFrame.CommoditiesSellFrame:ConfirmPost() then
			AuctionHouseFrame.ItemSellFrame:ConfirmPost();
		end
	end,
	OnHide = function()
		AuctionHouseFrame:SetDialogOverlayShown(false);
	end,

	showAlert = true,
	hideOnEscape = 1,
	timeout = 0,
	whileDead = 1,
}

StaticPopupDialogs["AUCTION_HOUSE_POST_ERROR"] = {
	text = NORMAL_FONT_COLOR:WrapTextInColorCode(AUCTION_POSTING_ERROR_TEXT),
	button1 = OKAY,
	OnHide = function()
		AuctionHouseFrame:SetDialogOverlayShown(false);
	end,
	showAlert = true,
	hideOnEscape = 1,
	timeout = 0,
	whileDead = 1,
}

AUCTION_HOUSE_STATIC_POPUPS = {
	"BUYOUT_AUCTION",
	"BID_AUCTION",
	"CANCEL_AUCTION",
	"AUCTION_HOUSE_POST_WARNING",
	"AUCTION_HOUSE_POST_ERROR",
};


local AuctionHouseSortVersion = 2;
local MaxNumAuctionHouseSortTypes = 2;

AuctionHouseSortOrderState = tInvert({
	"None",
	"PrimarySorted",
	"PrimaryReversed",
	"Sorted",
	"Reversed",
});


local function InitAuctionHouseSortsBySearchContext()
	-- [[ Transition between compatible sort versions. ]]
	if g_auctionHouseSortsBySearchContext and g_auctionHouseSortsBySearchContext.auctionHouseSortVersion == 1 then
		g_auctionHouseSortsBySearchContext[AuctionHouseSearchContext.AllAuctions][1] = { sortOrder = Enum.AuctionHouseSortOrder.Name, reverseSort = false };
		g_auctionHouseSortsBySearchContext[AuctionHouseSearchContext.AllAuctions][2] = { sortOrder = Enum.AuctionHouseSortOrder.Price, reverseSort = false };
		g_auctionHouseSortsBySearchContext[AuctionHouseSearchContext.AllBids][1] = { sortOrder = Enum.AuctionHouseSortOrder.Name, reverseSort = false };
		g_auctionHouseSortsBySearchContext[AuctionHouseSearchContext.AllBids][2] = { sortOrder = Enum.AuctionHouseSortOrder.Price, reverseSort = false };
	end


	-- If the sort version couldn't be updated, do a clean reset.
	if g_auctionHouseSortsBySearchContext == nil or g_auctionHouseSortsBySearchContext.auctionHouseSortVersion ~= AuctionHouseSortVersion then
		g_auctionHouseSortsBySearchContext = { auctionHouseSortVersion = AuctionHouseSortVersion };

		local browseContexts = {
			[AuctionHouseSearchContext.BrowseAll] = true,
			[AuctionHouseSearchContext.BrowseTradeGoods] = true,
			[AuctionHouseSearchContext.BrowseArmor] = true,
			[AuctionHouseSearchContext.BrowseWeapons] = true,
			[AuctionHouseSearchContext.BrowseConsumables] = true,
			[AuctionHouseSearchContext.BrowseItemEnhancements] = true,
			[AuctionHouseSearchContext.BrowseGems] = true,
			[AuctionHouseSearchContext.BrowseBattlePets] = true,
			[AuctionHouseSearchContext.BrowseRecipes] = true,
			[AuctionHouseSearchContext.BrowseQuestItems] = true,
			[AuctionHouseSearchContext.BrowseContainers] = true,
			[AuctionHouseSearchContext.BrowseGlpyhs] = true,
			[AuctionHouseSearchContext.BrowseMiscellaneous] = true,
			[AuctionHouseSearchContext.AllFavorites] = true,
		};

		local itemContexts = {
			[AuctionHouseSearchContext.BuyItems] = true,
			[AuctionHouseSearchContext.SellItems] = true,
			[AuctionHouseSearchContext.AuctionsItems] = true,
			[AuctionHouseSearchContext.BidItems] = true,
		};

		local ownedContexts = {
			[AuctionHouseSearchContext.AllAuctions] = true,
			[AuctionHouseSearchContext.AllBids] = true,
		};

		for i, searchContext in pairs(AuctionHouseSearchContext) do
			g_auctionHouseSortsBySearchContext[searchContext] = {};

			if browseContexts[searchContext] then
				g_auctionHouseSortsBySearchContext[searchContext][1] = { sortOrder = Enum.AuctionHouseSortOrder.Price, reverseSort = false };
				g_auctionHouseSortsBySearchContext[searchContext][2] = { sortOrder = Enum.AuctionHouseSortOrder.Name, reverseSort = false };
			elseif itemContexts[searchContext] then
				g_auctionHouseSortsBySearchContext[searchContext][1] = { sortOrder = Enum.AuctionHouseSortOrder.Buyout, reverseSort = false };
				g_auctionHouseSortsBySearchContext[searchContext][2] = { sortOrder = Enum.AuctionHouseSortOrder.Bid, reverseSort = false };
			elseif ownedContexts[searchContext] then
				g_auctionHouseSortsBySearchContext[searchContext][1] = { sortOrder = Enum.AuctionHouseSortOrder.Name, reverseSort = false };
				g_auctionHouseSortsBySearchContext[searchContext][2] = { sortOrder = Enum.AuctionHouseSortOrder.Price, reverseSort = false };
			end
		end

	end
end

local function AddSortType(searchContext, newSortType)
	if not g_auctionHouseSortsBySearchContext[searchContext] then
		g_auctionHouseSortsBySearchContext[searchContext] = {};
	end

	local sorts = g_auctionHouseSortsBySearchContext[searchContext];
	for i, sortType in ipairs(sorts) do
		if sortType.sortOrder == newSortType.sortOrder then
			if (i == 1) and sortType.reverseSort == newSortType.reverseSort then
				newSortType.reverseSort = not newSortType.reverseSort;
			end

			table.remove(sorts, i);
			break;
		end
	end

	table.insert(sorts, 1, newSortType);

	if #sorts > MaxNumAuctionHouseSortTypes then
		sorts[#sorts] = nil;
	end
end

local function GetSortTypes(searchContext)
	return g_auctionHouseSortsBySearchContext[searchContext] or {};
end

local function GetSortOrderState(searchContext, sortOrder)
	local sorts = g_auctionHouseSortsBySearchContext[searchContext];
	if not sorts then
		return AuctionHouseSortOrderState.None;
	end

	for i, sortType in ipairs(sorts) do
		if sortType.sortOrder == sortOrder then
			if sortType.reverseSort then
				return (i == 1) and AuctionHouseSortOrderState.PrimaryReversed or AuctionHouseSortOrderState.Reversed;
			else
				return (i == 1) and AuctionHouseSortOrderState.PrimarySorted or AuctionHouseSortOrderState.Sorted;
			end
		end
	end

	return AuctionHouseSortOrderState.None;
end

local function AreSortTypesLoaded()
	return g_auctionHouseSortsBySearchContext ~= nil;
end


local function InitBidLists()
	g_outbidAuctionIDs = {};
	g_activeBidAuctionIDs = g_activeBidAuctionIDs or {};
end

local function UpdateBidLists()
	-- Mark all active bids as outbid. We'll reset the mark on auctions that we have an active bid on.
	for i = 1, #g_activeBidAuctionIDs do
		local auctionID = g_activeBidAuctionIDs[i];
		g_outbidAuctionIDs[auctionID] = true;
	end

	g_activeBidAuctionIDs = {};
	for i = 1, C_AuctionHouse.GetNumBids() do
		local bid = C_AuctionHouse.GetBidInfo(i);
		local auctionID = bid.auctionID;

		if #g_activeBidAuctionIDs < MaxNumActiveBidsTracked then
			table.insert(g_activeBidAuctionIDs, auctionID);
		end

		if bid.bidder and bid.bidder == UnitGUID("player") then
			g_outbidAuctionIDs[auctionID] = nil;
		end
	end
end

local function HasBeenOutbid(auctionID)
	return g_outbidAuctionIDs[auctionID];
end

local function GetActiveBidList()
	return g_activeBidAuctionIDs;
end


AuctionHouseFrameMixin = CreateFromMixins(CallbackRegistryMixin);

AuctionHouseFrameMixin:GenerateCallbackEvents(
{
	"CategorySelected",
	"CommoditiesQuantitySelectionChanged",
	"BrowseSearchStarted",
});

local AUCTION_HOUSE_FRAME_EVENTS = {
	"PLAYER_MONEY",
	"ITEM_SEARCH_RESULTS_ADDED",
	"ITEM_SEARCH_RESULTS_UPDATED",
	"COMMODITY_SEARCH_RESULTS_ADDED",
	"COMMODITY_SEARCH_RESULTS_UPDATED",
	"BIDS_UPDATED",
	"BID_ADDED",
	"OWNED_AUCTIONS_UPDATED",
	"AUCTION_HOUSE_AUCTION_CREATED",
	"AUCTION_HOUSE_SHOW_ERROR",
	"AUCTION_HOUSE_SHOW_COMMODITY_WON_NOTIFICATION",
};

local function AuctionHouseFrame_GenerateMaxWidthFunction(self, cacheName, maxPriceFunction, key)
	if key then
		local function GetMaxWidth(self, fontObject)
			local cache = self[cacheName];
			local cacheByKey = cache[key];
			return (cacheByKey and cacheByKey[fontObject]) or self:GetMaxPriceWidth(cache, key, fontObject, maxPriceFunction());
		end

		return GetMaxWidth;
	else
		local function GetMaxWidth(self, itemKey, fontObject)
			local cache = self[cacheName];

			-- We should only have display item results for a single itemKey at once.
			local cacheKey = "SearchResults";
			local cacheByKey = cache[cacheKey];
			return (cacheByKey and cacheByKey[fontObject]) or self:GetMaxPriceWidth(cache, cacheKey, fontObject, maxPriceFunction(itemKey));
		end

		return GetMaxWidth;
	end
end

local MaxWidthArguments = {
	GetMaxBidWidth 							= { "maxBidPriceWidth", C_AuctionHouse.GetMaxItemSearchResultBid, };
	GetMaxBidPriceWidthForAllAuctions 		= { "maxBidPriceWidth", C_AuctionHouse.GetMaxOwnedAuctionBid, "AllAuctions" };
	GetMaxBidPriceWidthForAllBids 			= { "maxBidPriceWidth", C_AuctionHouse.GetMaxBidItemBid, "AllBids" };
	GetMaxBuyoutWidth 						= { "maxBuyoutPriceWidth", C_AuctionHouse.GetMaxItemSearchResultBuyout };
	GetMaxBuyoutPriceWidthForAllAuctions 	= { "maxBuyoutPriceWidth", C_AuctionHouse.GetMaxOwnedAuctionBuyout, "AllAuctions" };
	GetMaxBuyoutPriceWidthForAllBids 		= { "maxBuyoutPriceWidth", C_AuctionHouse.GetMaxBidItemBuyout, "AllBids" };
	GetMaxUnitPriceWidth 					= { "maxUnitPriceWidth", C_AuctionHouse.GetMaxCommoditySearchResultPrice };
};

function AuctionHouseFrameMixin:OnLoad()
	CallbackRegistryMixin.OnLoad(self);

	self.activeSearches = {};

	self.maxBidPriceWidth = {};
	self.maxBuyoutPriceWidth = {};
	self.maxUnitPriceWidth = {};

	for functionName, arguments in pairs(MaxWidthArguments) do
		self[functionName] = AuctionHouseFrame_GenerateMaxWidthFunction(self, unpack(arguments));
	end

	self:RegisterEvent("ADDON_LOADED");
	self:RegisterEvent("AUCTION_HOUSE_POST_WARNING");
	self:RegisterEvent("AUCTION_HOUSE_POST_ERROR");

	PanelTemplates_SetNumTabs(self, #self.Tabs);

	self.tabsForDisplayMode = {};
	for i, tab in ipairs(self.Tabs) do
		self.tabsForDisplayMode[tab.displayMode] = i;

		if tab == self.SellTab then
			self.tabsForDisplayMode[AuctionHouseFrameDisplayMode.CommoditiesSell] = i;
			self.tabsForDisplayMode[AuctionHouseFrameDisplayMode.WoWTokenSell] = i;
		elseif tab == self.BuyTab then
			self.tabsForDisplayMode[AuctionHouseFrameDisplayMode.WoWTokenBuy] = i;
		end
	end
end

function AuctionHouseFrameMixin:OnShow()
	FrameUtil.RegisterFrameForEvents(self, AUCTION_HOUSE_FRAME_EVENTS);

	self:SetPortraitToUnit("npc");

	self:SetDisplayMode(AuctionHouseFrameDisplayMode.Buy);

	self:UpdateMoneyFrame();

	if C_AuctionHouse.HasFavorites() then
		self:QueryAll(AuctionHouseSearchContext.AllFavorites);
	end

	OpenAllBags(self);

	PlaySound(SOUNDKIT.AUCTION_WINDOW_OPEN);
end

function AuctionHouseFrameMixin:OnEvent(event, ...)
	if event == "PLAYER_MONEY" then
		self:UpdateMoneyFrame();
	elseif event == "ADDON_LOADED" then
		local addonName = ...;
		if not addonName or addonName ~= "Blizzard_AuctionHouseUI" then
			return;
		end

		self:UnregisterEvent("ADDON_LOADED");
		InitAuctionHouseSortsBySearchContext();
		InitBidLists();

		-- We need to query bids to properly show outbid indicators.
		self:QueryAll(AuctionHouseSearchContext.AllBids);
	elseif event == "ITEM_SEARCH_RESULTS_ADDED" or event == "ITEM_SEARCH_RESULTS_UPDATED" or
			event == "OWNED_AUCTIONS_UPDATED" or event == "BIDS_UPDATED" or event == "BID_ADDED" then
		-- Clear the cached values.
		self:ClearMaxWidthCaches();

		if event == "BIDS_UPDATED" then
			UpdateBidLists();
		end
	elseif event == "COMMODITY_SEARCH_RESULTS_ADDED" or event == "COMMODITY_SEARCH_RESULTS_UPDATED" then
		-- Clear the cached values.
		self.maxUnitPriceWidth = {};
	elseif event == "AUCTION_HOUSE_AUCTION_CREATED" then
		Chat_AddSystemMessage(ERR_AUCTION_STARTED);
	elseif event == "AUCTION_HOUSE_SHOW_ERROR" then
		local auctionHouseError = ...;
		UIErrorsFrame:AddExternalErrorMessage(AuctionHouseUtil.GetErrorText(auctionHouseError));
	elseif event == "AUCTION_HOUSE_SHOW_COMMODITY_WON_NOTIFICATION" then
		local commodityName, commodityQuantity = ...;
		Chat_AddSystemMessage(ERR_AUCTION_COMMODITY_WON_S:format(commodityName, commodityQuantity));
	elseif event == "AUCTION_HOUSE_POST_WARNING" then
		self:ShowPostConfirmationDialog("AUCTION_HOUSE_POST_WARNING");
	elseif event == "AUCTION_HOUSE_POST_ERROR" then
		self:ShowPostConfirmationDialog("AUCTION_HOUSE_POST_ERROR");
	end
end

function AuctionHouseFrameMixin:OnHide()
	FrameUtil.UnregisterFrameForEvents(self, AUCTION_HOUSE_FRAME_EVENTS);

	AuctionHouseMultisellProgressFrame:Hide();

	self.BrowseResultsFrame:Reset();
	self:SetDialogOverlayShown(false);

	self:ClearPostItem();

	C_AuctionHouse.CloseAuctionHouse();

	self:CloseStaticPopups();

	CloseAllBags(self);

	PlaySound(SOUNDKIT.AUCTION_WINDOW_CLOSE);
end

function AuctionHouseFrameMixin:CloseStaticPopups()
	for i, popup in ipairs(AUCTION_HOUSE_STATIC_POPUPS) do
		if StaticPopup_Visible(popup) then
			StaticPopup_Hide(popup);
		end
	end
end

function AuctionHouseFrameMixin:ClearMaxWidthCaches()
	self.maxBidPriceWidth = {};
	self.maxBuyoutPriceWidth = {};
	self.maxUnitPriceWidth = {};
end

function AuctionHouseFrameMixin:UpdateMoneyFrame()
	self.MoneyFrameBorder.MoneyFrame:SetAmount(GetMoney());
end

AuctionHouseFrameDisplayMode = {
	Buy = {
		"CategoriesList",
		"SearchBar",
		"BrowseResultsFrame",
	},

	WoWTokenBuy = {
		"CategoriesList",
		"SearchBar",
		"WoWTokenResults",
	},

	CommoditiesBuy = {
		"CategoriesList",
		"SearchBar",
		"CommoditiesBuyFrame",
	},

	ItemBuy = {
		"CategoriesList",
		"SearchBar",
		"ItemBuyFrame",
	},

	CommoditiesSell = {
		"CommoditiesSellFrame",
		"CommoditiesSellList",
	},

	ItemSell = {
		"ItemSellFrame",
		"ItemSellList",
	},

	WoWTokenSell = {
		"WoWTokenSellFrame",
	},

	Auctions = {
		"AuctionsFrame",
	},
};

AuctionHouseFrameDialogs = {
	"BuyDialog",
};

AuctionHouseFramePopups = {
	"BID_AUCTION",
	"BUYOUT_AUCTION",
	"CANCEL_AUCTION",
	"TOKEN_AUCTIONABLE_TOKEN_OWNED",
	"TOKEN_NONE_FOR_SALE",
};

function AuctionHouseFrameMixin:SetDisplayMode(displayMode)
	-- If we have an active post item, show that display.
	if displayMode == AuctionHouseFrameDisplayMode.ItemSell or
		displayMode == AuctionHouseFrameDisplayMode.CommoditiesSell or
		displayMode == AuctionHouseFrameDisplayMode.WoWTokenSell then

		if self.ItemSellFrame:GetItem() then
			displayMode = AuctionHouseFrameDisplayMode.ItemSell;
		elseif self.CommoditiesSellFrame:GetItem() then
			displayMode = AuctionHouseFrameDisplayMode.CommoditiesSell;
		elseif self.WoWTokenSellFrame:GetItem() then
			displayMode = AuctionHouseFrameDisplayMode.WoWTokenSell;
		end
	elseif displayMode == AuctionHouseFrameDisplayMode.Buy then
		if self:GetCategoriesList():IsWoWTokenCategorySelected() then
			displayMode = AuctionHouseFrameDisplayMode.WoWTokenBuy;
		end
	end

	if self.displayMode == displayMode then
		return;
	end

	self.displayMode = displayMode;

	local subframesToUpdate = {};
	for displayModeName, mode in pairs(AuctionHouseFrameDisplayMode) do
		for j, subframe in ipairs(mode) do
			subframesToUpdate[subframe] = subframesToUpdate[subframe] or mode == displayMode;
		end
	end

	for subframe, shouldShow in pairs(subframesToUpdate) do
		if not shouldShow then
			self[subframe]:Hide();
		end
	end

	for i = 1, #displayMode do
		local subFrame = displayMode[i];
		self[subFrame]:Show();
	end

	local tab = self.tabsForDisplayMode[displayMode];
	if tab then
		PanelTemplates_SetTab(self, tab);
		self:UpdateTitle();
	end

	for i, dialogName in ipairs(AuctionHouseFrameDialogs) do
		self[dialogName]:Hide();
	end

	for i, popup in ipairs(AuctionHouseFramePopups) do
		StaticPopup_Hide(popup);
	end
end

function AuctionHouseFrameMixin:GetDisplayMode()
	return self.displayMode;
end

function AuctionHouseFrameMixin:IsListingAuctions()
	local displayMode = self:GetDisplayMode();
	return displayMode == AuctionHouseFrameDisplayMode.ItemSell or displayMode == AuctionHouseFrameDisplayMode.CommoditiesSell or displayMode == AuctionHouseFrameDisplayMode.WoWTokenSell;
end

function AuctionHouseFrameMixin:SetPostItem(itemLocation)
	if not itemLocation:IsValid() or not C_AuctionHouse.IsSellItemValid(itemLocation) or AuctionHouseMultisellProgressFrame:IsShown() then
		return;
	end

	local itemCommodityStatus = C_AuctionHouse.GetItemCommodityStatus(itemLocation);
	if itemCommodityStatus == Enum.ItemCommodityStatus.Unknown then
		return; -- No item data, bail out.
	end

	self:ClearPostItem();

	if C_WowTokenPublic.IsAuctionableWowToken(C_Item.GetItemID(itemLocation)) then
		self:SetDisplayMode(AuctionHouseFrameDisplayMode.WoWTokenSell);
		self.WoWTokenSellFrame:SetItem(itemLocation);
	elseif itemCommodityStatus == Enum.ItemCommodityStatus.Commodity then
		self:SetDisplayMode(AuctionHouseFrameDisplayMode.CommoditiesSell);
		self.CommoditiesSellFrame:SetItem(itemLocation);
		self.CommoditiesSellList:SetItemID(C_Item.GetItemID(itemLocation));
	elseif itemCommodityStatus == Enum.ItemCommodityStatus.Item then
		self:SetDisplayMode(AuctionHouseFrameDisplayMode.ItemSell);
		self.ItemSellFrame:SetItem(itemLocation);
	end
end

function AuctionHouseFrameMixin:ClearPostItem()
	self.WoWTokenSellFrame:SetItem(nil);
	self.CommoditiesSellFrame:SetItem(nil);
	self.CommoditiesSellList:SetItemID(nil);
	self.ItemSellFrame:SetItem(nil);
end

function AuctionHouseFrameMixin:UpdateTitle()
	local tab = PanelTemplates_GetSelectedTab(self);

	local title = AUCTION_HOUSE_FRAME_TITLE_BUY;
	if tab == 2 then
		title = AUCTION_HOUSE_FRAME_TITLE_SELL;
	elseif tab == 3 then
		title = AUCTION_HOUSE_AUCTIONS_SUB_TAB;
	end

	self:SetTitle(title);
end

function AuctionHouseFrameMixin:GetCategoriesList()
	return self.CategoriesList;
end

function AuctionHouseFrameMixin:GetBrowseResultsFrame()
	return self.BrowseResultsFrame;
end

function AuctionHouseFrameMixin:GetItemSellList()
	return self.ItemSellList;
end

function AuctionHouseFrameMixin:GetCommoditiesSellListFrames()
	return self.CommoditiesSellList, self.CommoditiesSellListHeaders;
end

function AuctionHouseFrameMixin:GetBrowseSearchContext()
	if self.isDisplayingFavorites then
		return AuctionHouseSearchContext.AllFavorites;
	else
		return self:GetCategorySearchContext();
	end
end

function AuctionHouseFrameMixin:GetCategorySearchContext()
	local selectedCategoryIndex = self:GetCategoriesList():GetSelectedCategory();
	local browseSearchContext = AuctionHouseUtil.ConvertCategoryToSearchContext(selectedCategoryIndex);
	return browseSearchContext;
end

function AuctionHouseFrameMixin:SelectBrowseResult(browseResult)
	local itemKey = browseResult.itemKey;
	local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(itemKey);
	local searchContext = itemKeyInfo.isCommodity and AuctionHouseSearchContext.BuyCommodities or AuctionHouseSearchContext.BuyItems;
	if itemKeyInfo.isCommodity then
		self.CommoditiesBuyFrame:SetItemIDAndPrice(itemKey.itemID, browseResult.minPrice);
		self.CommoditiesBuyFrame.BuyDisplay.ItemDisplay.FavoriteButton:SetItemKey(itemKey);
		self:SetDisplayMode(AuctionHouseFrameDisplayMode.CommoditiesBuy);
	else
		self.ItemBuyFrame:SetItemKey(itemKey);
		self:SetDisplayMode(AuctionHouseFrameDisplayMode.ItemBuy);
	end
end

function AuctionHouseFrameMixin:GetSortOrderState(searchContext, sortOrder)
	return GetSortOrderState(searchContext, sortOrder);
end

function AuctionHouseFrameMixin:SetSortOrder(searchContext, sortOrder)
	if not AreSortTypesLoaded() then
		return;
	end

	local activeSearch = self.activeSearches[searchContext];
	if not activeSearch then
		return;
	end

	local sortType = { sortOrder = sortOrder, reverseSort = false };
	AddSortType(searchContext, sortType);

	if searchContext == AuctionHouseSearchContext.BuyItems or searchContext == AuctionHouseSearchContext.SellItems or searchContext == AuctionHouseSearchContext.AuctionsItems or searchContext == AuctionHouseSearchContext.BidItems then
		self:QueryItem(unpack(activeSearch));
	elseif searchContext == AuctionHouseSearchContext.AllFavorites or searchContext == AuctionHouseSearchContext.AllAuctions or searchContext == AuctionHouseSearchContext.AllBids then
		self:QueryAll(unpack(activeSearch));
	else
		self:SendBrowseQueryInternal(unpack(activeSearch));
	end
end

function AuctionHouseFrameMixin:SetBrowseSortOrder(sortOrder)
	local browseSearchContext = self:GetBrowseSearchContext();
	self:SetSortOrder(browseSearchContext, sortOrder);
end

function AuctionHouseFrameMixin:GetBrowseSortOrderState(sortOrder)
	local browseSearchContext = self:GetBrowseSearchContext();
	return self:GetSortOrderState(browseSearchContext, sortOrder);
end

function AuctionHouseFrameMixin:GetSortsForContext(searchContext)
	return GetSortTypes(searchContext);
end

function AuctionHouseFrameMixin:QueryItem(searchContext, itemKey, byItemID)
	if not AreSortTypesLoaded() then
		return;
	end

	self.activeSearches[searchContext] = { searchContext, itemKey, byItemID };

	self.isDisplayingFavorites = false;

	local sorts = GetSortTypes(searchContext);
	local separateOwnerItems = searchContext == AuctionHouseSearchContext.AuctionsItems or searchContext == AuctionHouseSearchContext.AuctionsCommodities;
	if byItemID then
		C_AuctionHouse.SendSellSearchQuery(itemKey, sorts, separateOwnerItems);
	else
		if searchContext == AuctionHouseSearchContext.BuyItems then
			local minLevel, maxLevel = self.SearchBar:GetLevelFilterRange();
			C_AuctionHouse.SendSearchQuery(itemKey, sorts, separateOwnerItems, minLevel, maxLevel);
		else
			C_AuctionHouse.SendSearchQuery(itemKey, sorts, separateOwnerItems);
		end
	end
end

function AuctionHouseFrameMixin:QueryAll(searchContext)
	if not AreSortTypesLoaded() then
		return;
	end

	self.activeSearches[searchContext] = { searchContext };

	local sorts = GetSortTypes(searchContext);

	self.isDisplayingFavorites = searchContext == AuctionHouseSearchContext.AllFavorites;

	if searchContext == AuctionHouseSearchContext.AllFavorites then
		C_AuctionHouse.SearchForFavorites(sorts);
		self:TriggerEvent(AuctionHouseFrameMixin.Event.BrowseSearchStarted);
		self:SetDisplayMode(AuctionHouseFrameDisplayMode.Buy);
		self.BrowseResultsFrame:UpdateHeaders();
	elseif searchContext == AuctionHouseSearchContext.AllAuctions then
		C_AuctionHouse.QueryOwnedAuctions(sorts);
	elseif searchContext == AuctionHouseSearchContext.AllBids then
		C_AuctionHouse.QueryBids(sorts, GetActiveBidList());
	end
end

function AuctionHouseFrameMixin:SendBrowseQuery(searchString, minLevel, maxLevel, filtersArray)
	if not AreSortTypesLoaded() then
		return;
	end

	local browseSearchContext = self:GetCategorySearchContext();
	self:SendBrowseQueryInternal(browseSearchContext, searchString, minLevel, maxLevel, filtersArray);
	self:TriggerEvent(AuctionHouseFrameMixin.Event.BrowseSearchStarted);
	self.BrowseResultsFrame:UpdateHeaders();
end

function AuctionHouseFrameMixin:SendBrowseQueryInternal(browseSearchContext, searchString, minLevel, maxLevel, filtersArray)
	if not AreSortTypesLoaded() then
		return;
	end

	local categoriesList = self:GetCategoriesList();
	local filterData, implicitCategoryFilter;
	if categoriesList:IsWoWTokenCategorySelected() then
		categoriesList:SetSelectedCategory(nil);
	else
		filterData, implicitCategoryFilter = categoriesList:GetCategoryFilterData();
	end

	if implicitCategoryFilter then
		table.insert(filtersArray, implicitCategoryFilter);
	end

	self.activeSearches[browseSearchContext] = { browseSearchContext, searchString, minLevel, maxLevel, filtersArray };

	self.isDisplayingFavorites = browseSearchContext == AuctionHouseSearchContext.AllFavorites;


	local query = {};
	query.searchString = searchString;
	query.minLevel = minLevel;
	query.maxLevel = maxLevel;
	query.filters = filtersArray;
	query.itemClassFilters = filterData;
	query.sorts = GetSortTypes(browseSearchContext);
	C_AuctionHouse.SendBrowseQuery(query);

	self:SetDisplayMode(AuctionHouseFrameDisplayMode.Buy);
end

function AuctionHouseFrameMixin:RefreshSearchResults(searchContext, itemKey)
	if C_AuctionHouse.HasSearchResults(itemKey) then
		local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(itemKey);
		if itemKeyInfo.isCommodity then
			C_AuctionHouse.RefreshCommoditySearchResults(itemKey.itemID);
		elseif searchContext == AuctionHouseSearchContext.BuyItems then
			local minLevel, maxLevel = self.SearchBar:GetLevelFilterRange();
			C_AuctionHouse.RefreshItemSearchResults(itemKey, minLevel, maxLevel);
		else
			C_AuctionHouse.RefreshItemSearchResults(itemKey);
		end
	else
		self:QueryItem(searchContext, itemKey);
	end
end

function AuctionHouseFrameMixin:StartCommoditiesPurchase(itemID, quantity, unitPrice, totalPrice)
	self.BuyDialog:SetItemID(itemID, quantity, unitPrice, totalPrice);
	self.BuyDialog:Show();
	C_AuctionHouse.StartCommoditiesPurchase(itemID, quantity, unitPrice);
end

function AuctionHouseFrameMixin:StartItemBid(auctionID, bid)
	local function StartItemBid()
		local data = { auctionID = auctionID, bid = bid };
		StaticPopup_Show("BID_AUCTION", nil, nil, data);
	end

	self:StartItemPurchase(auctionID, StartItemBid);
end

function AuctionHouseFrameMixin:StartItemBuyout(auctionID, buyout)
	local function StartItemBuyout()
		local data = { auctionID = auctionID, buyout = buyout };
		StaticPopup_Show("BUYOUT_AUCTION", nil, nil, data);
	end

	self:StartItemPurchase(auctionID, StartItemBuyout);
end

function AuctionHouseFrameMixin:StartItemPurchase(auctionID, callback)
	local isUniqueShadowlandsCrafted, categoryName = AuctionHouseUtil.IsAuctionIDUniqueShadowlandsCrafted(auctionID);
	if isUniqueShadowlandsCrafted then
		local data = { categoryName = categoryName, callback = callback };
		StaticPopup_Show("PURCHASE_AUCTION_UNIQUE", nil, nil, data);
	else
		callback();
	end
end

function AuctionHouseFrameMixin:SetSearchText(text)
	if self.displayMode == AuctionHouseFrameDisplayMode.Buy or self.displayMode == AuctionHouseFrameDisplayMode.ItemBuy or
		self.displayMode == AuctionHouseFrameDisplayMode.WoWTokenBuy or self.displayMode == AuctionHouseFrameDisplayMode.CommoditiesBuy then
		self.SearchBar:SetSearchText(text);
		return true;
	end

	return false;
end

function AuctionHouseFrameMixin:GetMaxPriceWidth(cache, key, fontObject, maxPrice)
	self.DummyMoneyDisplayFrame:SetAmount(maxPrice or 0);
	self.DummyMoneyDisplayFrame:SetFontObject(fontObject);
	local width = self.DummyMoneyDisplayFrame:GetWidth();

	cache[key] = cache[key] or {};
	cache[key][fontObject] = width;
	return width;
end

function AuctionHouseFrameMixin:GetBidStatus(bidInfo)
	if not bidInfo.bidder then
		return AuctionHouseBidStatus.NoBid;
	elseif bidInfo.bidder == UnitGUID("player") then
		return AuctionHouseBidStatus.PlayerBid;
	elseif HasBeenOutbid(bidInfo.auctionID) then
		return AuctionHouseBidStatus.PlayerOutbid;
	else
		return AuctionHouseBidStatus.OtherBid;
	end
end

function AuctionHouseFrameMixin:SetDialogOverlayShown(shown)
	self.DialogOverlay:SetShown(shown);
end

function AuctionHouseFrameMixin:ShowPostConfirmationDialog(which)
	self:SetDialogOverlayShown(true);
	StaticPopup_Show(which);
end

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseFrame.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Frame name="AuctionHouseFrame" toplevel="true" enableMouse="true" parent="UIParent" mixin="AuctionHouseFrameMixin" inherits="PortraitFrameTemplate" hidden="true">
		<Size x="800" y="538"/>
		<Anchors>
			<Anchor point="CENTER"/>
		</Anchors>
		<Frames>
			<!-- Base Frame -->
			<Frame parentKey="MoneyFrameInset" inherits="InsetFrameTemplate" useParentLevel="true">
				<Anchors>
					<Anchor point="TOPLEFT" relativePoint="BOTTOMLEFT" x="2" y="27"/>
					<Anchor point="BOTTOMRIGHT" relativePoint="BOTTOMLEFT" x="167" y="3"/>
				</Anchors>
			</Frame>
			<Frame parentKey="MoneyFrameBorder" inherits="ThinGoldEdgeTemplate">
				<Size x="158" y="19"/>
				<Anchors>
					<Anchor point="BOTTOMLEFT" x="5" y="6"/>
				</Anchors>
				<Frames>
					<Frame parentKey="MoneyFrame" inherits="MoneyDisplayFrameTemplate">
						<Anchors>
							<Anchor point="RIGHT" x="-6" y="0"/>
						</Anchors>
					</Frame>
				</Frames>
				<Layers>
					<Layer level="BORDER">
						<Texture file="Interface\FrameGeneral\UI-Frame">
							<Size x="13" y="23"/>
							<Anchors>
								<Anchor point="TOPLEFT" relativePoint="TOPRIGHT" x="-3" y="2"/>
							</Anchors>
							<TexCoords left="0.8984375" right="1" top="0.015625" bottom="0.1953125"/>
						</Texture>
					</Layer>
				</Layers>
			</Frame>
			<!-- Base Frame -->

			<!-- Tabs -->
			<Button name="$parentBuyTab" parentKey="BuyTab" inherits="AuctionHouseFrameDisplayModeTabTemplate" text="AUCTION_HOUSE_BUY_TAB">
				<KeyValues>
					<KeyValue key="displayMode" value="AuctionHouseFrameDisplayMode.Buy" type="global"/>
				</KeyValues>
				<Anchors>
					<Anchor point="BOTTOMLEFT" x="20" y="-28"/>
				</Anchors>
			</Button>
			<Button name="$parentSellTab" parentKey="SellTab" inherits="AuctionHouseFrameDisplayModeTabTemplate" text="AUCTION_HOUSE_SELL_TAB">
				<KeyValues>
					<KeyValue key="displayMode" value="AuctionHouseFrameDisplayMode.ItemSell" type="global"/>
				</KeyValues>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.BuyTab" relativePoint="RIGHT" x="-15" y="0"/>
				</Anchors>
			</Button>
			<Button name="$parentAuctionsTab" parentKey="AuctionsTab" inherits="AuctionHouseFrameDisplayModeTabTemplate" text="AUCTION_HOUSE_AUCTIONS_SUB_TAB">
				<KeyValues>
					<KeyValue key="displayMode" value="AuctionHouseFrameDisplayMode.Auctions" type="global"/>
				</KeyValues>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.SellTab" relativePoint="RIGHT" x="-15" y="0"/>
				</Anchors>
			</Button>
			<!-- Tabs -->

			<!-- Browsing frames -->
			<Frame parentKey="SearchBar" inherits="AuctionHouseSearchBarTemplate" hidden="true">
				<Anchors>
					<Anchor point="TOPRIGHT" x="-12" y="-29"/>
				</Anchors>
			</Frame>
			<Frame parentKey="CategoriesList" inherits="AuctionHouseCategoriesListTemplate" hidden="true">
				<Anchors>
					<Anchor point="LEFT" x="4" y="0"/>
					<Anchor point="TOP" relativeKey="$parent.SearchBar" relativePoint="BOTTOM" x="0" y="-4"/>
				</Anchors>
			</Frame>
			<Frame parentKey="BrowseResultsFrame" inherits="AuctionHouseBrowseResultsFrameTemplate" hidden="true">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.CategoriesList" relativePoint="TOPRIGHT" x="0" y="0"/>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent.CategoriesList" relativePoint="BOTTOMRIGHT" x="8" y="0"/>
					<Anchor point="RIGHT" x="-23" y="0"/>
				</Anchors>
			</Frame>
			<Frame parentKey="WoWTokenResults" inherits="BrowseWowTokenResultsTemplate">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.CategoriesList" relativePoint="TOPRIGHT" x="0" y="-20"/>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent.CategoriesList" relativePoint="BOTTOMRIGHT" x="8" y="0"/>
					<Anchor point="RIGHT" x="-27" y="0"/>
				</Anchors>
			</Frame>
			<!-- Browsing frames -->

			<!-- Buy frames -->
			<Frame parentKey="CommoditiesBuyFrame" inherits="AuctionHouseCommoditiesBuyFrameTemplate" hidden="true">
				<Anchors>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent.CategoriesList" relativePoint="BOTTOMRIGHT" x="0" y="0"/>
					<Anchor point="TOP" relativeKey="$parent.SearchBar" relativePoint="BOTTOM" x="0" y="0"/>
					<Anchor point="RIGHT" x="-1" y="0"/>
				</Anchors>
			</Frame>

			<Frame parentKey="ItemBuyFrame" inherits="AuctionHouseItemBuyFrameTemplate" hidden="true">
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.CategoriesList" relativePoint="RIGHT" x="0" y="0"/>
					<Anchor point="RIGHT" x="-1" y="0"/>
					<Anchor point="TOP" relativeKey="$parent.SearchBar" relativePoint="BOTTOM" x="0" y="0"/>
					<Anchor point="BOTTOM" x="0" y="5"/>
				</Anchors>
			</Frame>
			<!-- Buy frames -->

			<!-- Sell frames -->
			<Frame parentKey="ItemSellFrame" inherits="AuctionHouseItemSellFrameTemplate" hidden="true">
				<Size x="363" y="0"/>
				<Anchors>
					<Anchor point="TOP" x="0" y="-69"/>
					<Anchor point="BOTTOM" relativeKey="$parent.MoneyFrameBorder" relativePoint="TOP" x="0" y="2"/>
					<Anchor point="LEFT" x="4" y="0"/>
				</Anchors>
			</Frame>
			<Frame parentKey="ItemSellList" inherits="AuctionHouseItemListTemplate" hidden="true">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-sell-right" type="string"/>
					<KeyValue key="textureWidthClassic" value="399" type="number"/>
					<KeyValue key="textureHeightClassic" value="419" type="number"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="30" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ItemSellFrame" relativePoint="TOPRIGHT" x="1" y="0"/>
					<Anchor point="RIGHT" x="-5" y="0"/>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent.ItemSellFrame" relativePoint="BOTTOMRIGHT" x="1" y="0"/>
				</Anchors>
			</Frame>

			<Frame parentKey="CommoditiesSellFrame" inherits="AuctionHouseCommoditiesSellFrameTemplate" hidden="true">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ItemSellFrame" relativePoint="TOPLEFT"/>
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.ItemSellFrame" relativePoint="BOTTOMRIGHT"/>
				</Anchors>
			</Frame>
			<Frame parentKey="CommoditiesSellList" inherits="AuctionHouseCommoditiesSellListTemplate" hidden="true">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ItemSellList" relativePoint="TOPLEFT"/>
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.ItemSellList" relativePoint="BOTTOMRIGHT"/>
				</Anchors>
			</Frame>

			<Frame parentKey="WoWTokenSellFrame" inherits="WoWTokenSellFrameTemplate">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ItemSellFrame" relativePoint="TOPLEFT"/>
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.ItemSellFrame" relativePoint="BOTTOMRIGHT"/>
				</Anchors>
			</Frame>
			<!-- Sell frames -->

			<!-- Auctions frames -->
			<Frame name="$parentAuctionsFrame" parentKey="AuctionsFrame" inherits="AuctionHouseAuctionsFrameTemplate" hidden="true">
				<Anchors>
					<Anchor point="LEFT" x="5" y="0"/>
					<Anchor point="RIGHT"/>
					<Anchor point="TOP" x="0" y="-42"/>
					<Anchor point="BOTTOM" relativeKey="$parent.MoneyFrameBorder" relativePoint="TOP" x="0" y="2"/>
				</Anchors>
			</Frame>
			<!-- Auctions frames -->

			<!-- Dialogs -->
			<Button parentKey="DialogOverlay" frameLevel="1000" hidden="true">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent" relativePoint="TOPLEFT" x="0" y="-22"/>
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent" relativePoint="BOTTOMRIGHT"/>
				</Anchors>
			</Button>

			<Frame parentKey="BuyDialog" inherits="AuctionHouseBuyDialogTemplate" hidden="true">
				<Anchors>
					<Anchor point="CENTER" x="0" y="50"/>
				</Anchors>
			</Frame>
			<!-- Dialogs -->

			<!-- Required for measuring max widths. This should always be hidden. -->
			<Frame parentKey="DummyMoneyDisplayFrame" inherits="MoneyDisplayFrameTemplate" hidden="true">
				<Anchors>
					<Anchor point="CENTER"/>
				</Anchors>
				<KeyValues>
					<KeyValue key="useAuctionHouseCopperValue" value="true" type="boolean"/>
					<KeyValue key="useAuctionHouseIcons" value="true" type="boolean"/>
					<KeyValue key="resizeToFit" value="true" type="boolean"/>
				</KeyValues>
			</Frame>
			<!-- Required for measuring max widths. This should always be hidden. -->
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnEvent method="OnEvent"/>
			<OnHide method="OnHide"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseFrame.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemBuyFrame.lua ---


local ITEM_BUY_SCROLL_OFFSET_REFRESH_THRESHOLD = 30;


AuctionHouseItemBuyFrameMixin = CreateFromMixins(AuctionHouseBuySystemMixin, AuctionHouseSortOrderSystemMixin);

local AUCTION_HOUSE_ITEM_BUY_FRAME_EVENTS = {
	"ITEM_SEARCH_RESULTS_UPDATED",
	"ITEM_SEARCH_RESULTS_ADDED",
	"BIDS_UPDATED",
	"AUCTION_HOUSE_BROWSE_RESULTS_UPDATED",
};

function AuctionHouseItemBuyFrameMixin:OnLoad()
	AuctionHouseBuySystemMixin.OnLoad(self);
	AuctionHouseSortOrderSystemMixin.OnLoad(self);

	self:SetSearchContext(AuctionHouseSearchContext.BuyItems);

	self.ItemDisplay:SetAuctionHouseFrame(self:GetAuctionHouseFrame());
	
	self:ResetPrice();

	self.ItemList:SetSelectionCallback(AuctionHouseUtil.GenerateRowSelectedCallbackWithInspect(self, self.OnAuctionSelected));

	self.ItemList:SetHighlightCallback(function(currentRowData, selectedRowData)
		return selectedRowData and (currentRowData.auctionID == selectedRowData.auctionID);
	end);

	self.ItemList:SetLineOnEnterCallback(AuctionHouseUtil.LineOnEnterCallback);
	self.ItemList:SetLineOnLeaveCallback(AuctionHouseUtil.LineOnLeaveCallback);

	self.ItemList:SetTableBuilderLayout(AuctionHouseTableBuilder.GetItemBuyListLayout(self, self.ItemList));


	local function ItemBuyListGetTotalQuantity()
		return self.itemKey and C_AuctionHouse.GetItemSearchResultsQuantity(self.itemKey) or 0;
	end

	local function ItemBuyListRefreshResults()
		if self.itemKey ~= nil then
			self:GetAuctionHouseFrame():RefreshSearchResults(AuctionHouseSearchContext.BuyItems, self.itemKey);
		end
	end

	self.ItemList:SetRefreshFrameFunctions(ItemBuyListGetTotalQuantity, ItemBuyListRefreshResults);
end

function AuctionHouseItemBuyFrameMixin:OnShow()
	FrameUtil.RegisterFrameForEvents(self, AUCTION_HOUSE_ITEM_BUY_FRAME_EVENTS);
end

function AuctionHouseItemBuyFrameMixin:OnHide()
	FrameUtil.UnregisterFrameForEvents(self, AUCTION_HOUSE_ITEM_BUY_FRAME_EVENTS);

	self.ItemList:SetSelectedEntry(nil);
	self:SetAuction(nil);
end

function AuctionHouseItemBuyFrameMixin:OnEvent(event, ...)
	if event == "ITEM_SEARCH_RESULTS_UPDATED" then
		local itemKey, auctionID = ...;

		if auctionID then
			local function FindSelectedAuctionInfo(rowData)
				return rowData.auctionID == auctionID;
			end

			local scrollTo = true;
			self.ItemList:SetSelectedEntryByCondition(FindSelectedAuctionInfo, scrollTo);
		else
			self.ItemList:DirtyScrollFrame();
		end
	elseif event == "ITEM_SEARCH_RESULTS_ADDED" then
		self.ItemList:DirtyScrollFrame();
	elseif event == "BIDS_UPDATED" then
		self.ItemList:DirtyScrollFrame();
	elseif event == "AUCTION_HOUSE_BROWSE_RESULTS_UPDATED" then
		self.ItemList:UpdateRefreshFrame();
	end
end

function AuctionHouseItemBuyFrameMixin:SetItemKey(itemKey)
	self.itemKey = itemKey;

	local function ItemBuyListSearchStarted()
		return self.itemKey ~= nil;
	end

	local function ItemBuyListGetNumEntries()
		return C_AuctionHouse.GetNumItemSearchResults(itemKey);
	end

	local function ItemBuyListGetEntry(index)
		return C_AuctionHouse.GetItemSearchResultInfo(itemKey, index);
	end

	local function ItemBuyListHasFullResults()
		return C_AuctionHouse.HasFullItemSearchResults(itemKey);
	end

	local function ItemBuyListRefreshCallback(lastDisplayEntry)
		local numEntries = ItemBuyListGetNumEntries();
		if numEntries > 0 and numEntries - lastDisplayEntry < ITEM_BUY_SCROLL_OFFSET_REFRESH_THRESHOLD then
			local hasFullResults = C_AuctionHouse.RequestMoreItemSearchResults(itemKey);
			if hasFullResults then
				self.ItemList:SetRefreshCallback(nil);
			end
		end
	end

	self.ItemList:SetDataProvider(ItemBuyListSearchStarted, ItemBuyListGetEntry, ItemBuyListGetNumEntries, ItemBuyListHasFullResults);
	self.ItemDisplay:SetItemKey(itemKey);
	self.ItemList:SetRefreshCallback(ItemBuyListRefreshCallback);
end

function AuctionHouseItemBuyFrameMixin:OnAuctionSelected(auctionData)
	if auctionData == nil then
		self:ResetPrice();
	else
		self:SetAuction(auctionData.auctionID, auctionData.minBid, auctionData.buyoutAmount, AuctionHouseUtil.IsOwnedAuction(auctionData), auctionData.bidder);
	end
end

function AuctionHouseItemBuyFrameMixin:HasAuctionSelected()
	return self.ItemList:GetSelectedEntry() ~= nil;
end

AuctionHouseItemBuyItemDisplayMixin = CreateFromMixins(AuctionHouseItemDisplayMixin);

function AuctionHouseItemBuyItemDisplayMixin:OnLoad() 
	AuctionHouseItemDisplayMixin.OnLoad(self);

	self.FavoriteButton:SetPoint("TOPRIGHT", -10, -11);
	self.Name:SetPoint("RIGHT", -35, 1);
end

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemBuyFrame.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemBuyFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	
	<Frame name="AuctionHouseItemBuyFrameTemplate" mixin="AuctionHouseItemBuyFrameMixin" virtual="true">
		<Size x="600" y="440"/>
		<Frames>
			<Button parentKey="BackButton" mixin="AuctionHouseCommoditiesBackButtonMixin" inherits="UIPanelButtonTemplate" text="AUCTION_HOUSE_BACK_BUTTON">
				<Size x="110" y="22"/>
				<Anchors>
					<Anchor point="TOPLEFT" x="11" y="-9"/>
				</Anchors>
				<Scripts>
					<OnClick method="OnClick"/>
				</Scripts>
			</Button>
			<Button parentKey="ItemDisplay" inherits="AuctionHouseItemDisplayTemplate" mixin="AuctionHouseItemBuyItemDisplayMixin">
				<Size x="622" y="86"/>
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-buy-noncommodities-header" type="string"/>
					<KeyValue key="itemButtonXOffset" value="22" type="number"/>
					<KeyValue key="itemButtonYOffset" value="-2" type="number"/>
					<KeyValue key="backgroundTextureClassic" value="Interface\QuestFrame\UI-TextBackground-BackdropBackground" type="string"/>
					<KeyValue key="textureWidthClassic" value="617" type="number"/>
					<KeyValue key="textureHeightClassic" value="82" type="number"/>
					<KeyValue key="textureXOffsetClassic" value="3" type="number"/>
					<KeyValue key="textureYOffsetClassic" value="-2" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.BackButton" relativePoint="BOTTOM" x="0" y="-10"/>
					<Anchor point="LEFT"/>
				</Anchors>
			</Button>
			
			<Frame parentKey="BuyoutFrame" inherits="AuctionHouseBuyoutFrameTemplate">
				<Anchors>
					<Anchor point="BOTTOMRIGHT"/>
				</Anchors>
			</Frame>
			<Frame parentKey="BidFrame" inherits="AuctionHouseBidFrameTemplate">
				<Anchors>
					<Anchor point="RIGHT" relativeKey="$parent.BuyoutFrame" relativePoint="LEFT" x="-60" y="0"/>
				</Anchors>
			</Frame>
			<Frame parentKey="ItemList" inherits="AuctionHouseItemListTemplate">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-buy-noncommodities-market" type="string"/>
					<KeyValue key="textureWidthClassic" value="595" type="number"/>
					<KeyValue key="textureHeightClassic" value="278" type="number"/>
					<KeyValue key="refreshFrameXOffset" value="-4" type="number"/>
					<KeyValue key="refreshFrameYOffset" value="132" type="number"/>
				</KeyValues>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.ItemDisplay" relativePoint="BOTTOM" x="0" y="-14"/>
					<Anchor point="LEFT"/>
					<Anchor point="BOTTOM" relativeKey="$parent.BuyoutFrame" relativePoint="TOP"/>
					<Anchor point="RIGHT" relativeKey="$parent.BuyoutFrame" relativePoint="RIGHT" x="-4"/>
				</Anchors>
			</Frame>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemBuyFrame.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemList.lua ---


local ItemListState = {
	NoSearch = 1,
	NoResults = 2,
	ResultsPending = 3,
	ShowResults = 4,
};


AuctionHouseItemListLineMixin = CreateFromMixins(TableBuilderRowMixin);

function AuctionHouseItemListLineMixin:OnClick(button)
	-- Overrides register for right click as well, ensure this is a left click. 
	if button == "LeftButton" then
		self:GetItemList():SetSelectedEntry(self.rowData);
	end
end

function AuctionHouseItemListLineMixin:OnLineEnter()
	self.HighlightTexture:Show();
	self:GetItemList():OnEnterListLine(self, self.rowData);
end

function AuctionHouseItemListLineMixin:OnLineLeave()
	self.HighlightTexture:Hide();
	self:GetItemList():OnLeaveListLine(self, self.rowData);
end

function AuctionHouseItemListLineMixin:GetItemList()
	return self:GetParent():GetParent():GetParent();
end

function AuctionHouseItemListLineMixin:GetRowData()
	return self.rowData;
end


AuctionHouseFavoritableLineMixin = {};

function AuctionHouseFavoritableLineMixin:OnClick(buttonName, ...)
	AuctionHouseItemListLineMixin.OnClick(self, buttonName, ...)

	if buttonName == "RightButton" then
		local rowData = self:GetRowData();
		AuctionHouseFavoriteContextMenu(self, rowData.itemKey);
	end
end


AuctionHouseItemListMixin = {};

function AuctionHouseItemListMixin:OnLoad()
	AuctionHouseBackgroundMixin.OnLoad(self);
	
	self.RefreshFrame:SetShown(not self.hideRefreshFrame);
	self.RefreshFrame:SetPoint("TOPRIGHT", self.refreshFrameXOffset or 0, self.refreshFrameYOffset or 0);

	if(AuctionHouseUtil.ApplyClassicScrollbarOffset) then
		AuctionHouseUtil.ApplyClassicScrollbarOffset(self);
	end

	self.NineSlice:SetPoint("BOTTOMRIGHT", -22, 0);

	self.ScrollBox:RegisterCallback(ScrollBoxListMixin.Event.OnScroll, self.OnScrollBoxScroll, self);
end

-- searchStartedFunc should return whether or not a search has been started, and optionally a 2nd return for search results text.
-- getEntry should take an index between 1 and getNumEntries() and return result data to be used in the TableBuilder.
-- getNumEntries should return the number of valid indices for getEntry, 0 for none.
-- (optional) hasFullResultsFunc should return true if there are pending results. This determines whether we show a spinner, or "No Results" if getNumEntries() == 0.
function AuctionHouseItemListMixin:SetDataProvider(searchStartedFunc, getEntry, getNumEntries, hasFullResultsFunc)
	self.searchStartedFunc = searchStartedFunc;
	self.getEntry = getEntry;
	self.getNumEntries = getNumEntries;
	self.hasFullResultsFunc = hasFullResultsFunc;

	if self.tableBuilder then
		self.tableBuilder:SetDataProvider(self.getEntry);
	end
end

-- quantityFunc: Returns the total quantity of items, instead of lines of results.
-- refreshResultsFunc: Function to call when the fresh button is pressed to refresh results.
function AuctionHouseItemListMixin:SetRefreshFrameFunctions(totalQuantityFunc, refreshResultsFunc)
	self.totalQuantityFunc = totalQuantityFunc;
	self.refreshResultsFunc = refreshResultsFunc;
	self.RefreshFrame:SetRefreshCallback(refreshResultsFunc);
end

function AuctionHouseItemListMixin:SetTableBuilderLayout(tableBuilderLayoutFunction)
	self.tableBuilderLayoutFunction = tableBuilderLayoutFunction;
	self.tableBuilderLayoutDirty = true;

	if self.isInitialized and self:IsShown() then
		self:UpdateTableBuilderLayout();
	end
end

function AuctionHouseItemListMixin:SetRefreshCallback(refreshCallback)
	self.refreshCallback = refreshCallback;
end

function AuctionHouseItemListMixin:UpdateTableBuilderLayout()
	if self.tableBuilderLayoutDirty then
		self.tableBuilder:Reset();
		self.tableBuilderLayoutFunction(self.tableBuilder);
		self.tableBuilder:SetTableWidth(self.ScrollBox:GetWidth());
		self.tableBuilder:Arrange();
		self.tableBuilderLayoutDirty = false;
	end
end

function AuctionHouseItemListMixin:SetSelectionCallback(selectionCallback)
	self.selectionCallback = selectionCallback;
end

function AuctionHouseItemListMixin:SetHighlightCallback(highlightCallback)
	self.highlightCallback = highlightCallback;
end

function AuctionHouseItemListMixin:SetLineTemplate(lineTemplate, ...)
	self.lineTemplate = lineTemplate;

	-- 'initArgs' is currently unused. It was previously used to store a reference to a dropdown
	-- frame and a callback to generate it's single option. See AuctionHouseFavoriteContextMenu()
	-- for the menu generation logic.
	self.initArgs = { ... };
end

function AuctionHouseItemListMixin:SetCustomError(errorText)
	self:SetState(ItemListState.NoResults);
	self.ResultsText:Show();
	self.ResultsText:SetText(errorText);
end

function AuctionHouseItemListMixin:Init()
	if self.isInitialized then
		return;
	end

	local view = CreateScrollBoxListLinearView();
	view:SetElementFactory(function(factory, elementData)
		local function Initializer(button, elementData)
			if self.hideStripes then
				-- Force the texture to stay hidden through button clicks, etc.
				button:GetNormalTexture():SetAlpha(0);
			end
		
			button:SetEnabled(self.selectionCallback ~= nil);
		end
		factory(self.lineTemplate or "AuctionHouseItemListLineTemplate", Initializer);
	end);

	ScrollUtil.InitScrollBoxListWithScrollBar(self.ScrollBox, self.ScrollBar, view);
	
	local tableBuilder = CreateTableBuilder(nil, AuctionHouseTableBuilderMixin);
	self.tableBuilder = tableBuilder;

	local function ElementDataTranslator(elementData)
		return elementData;
	end;
	ScrollUtil.RegisterTableBuilder(self.ScrollBox, tableBuilder, ElementDataTranslator);

	if self.getEntry then
		self.tableBuilder:SetDataProvider(self.getEntry);
	end
	
	ScrollUtil.RegisterAlternateRowBehavior(self.ScrollBox, function(button, alternate)
		if self.highlightCallback then
			local highlightShown = false;
			local highlightAlpha = 1.0;

			-- rowData or elementData has been found to occasionally be nil, likely due to this callback 
			-- being invoked before the row has been fully initialized by the table builder. Since this seems to
			-- resolve itself when displayed, just allow the unhighlighted state in the event this occurs.
			local rowData = button.rowData;
			if rowData then
				local elementData = button:GetElementData();
				if elementData then
					highlightShown, highlightAlpha = self.highlightCallback(rowData, self.selectedRowData, elementData);
				end
			end

			if not self.hideStripes then
				button:GetNormalTexture():SetAtlas(alternate and "auctionhouse-rowstripe-1" or "auctionhouse-rowstripe-2");
			end

			button.SelectedHighlight:SetShown(highlightShown);
			button.SelectedHighlight:SetAlpha(highlightAlpha or 1.0);
		else
			button.SelectedHighlight:Hide();
		end
	end);

	self.isInitialized = true;
end

function AuctionHouseItemListMixin:SetLineOnEnterCallback(callback)
	self.lineOnEnterCallback = callback;
end

function AuctionHouseItemListMixin:OnEnterListLine(line, rowData)
	if self.lineOnEnterCallback then
		self.lineOnEnterCallback(line, rowData);
	end
end

function AuctionHouseItemListMixin:SetLineOnLeaveCallback(callback)
	self.lineOnLeaveCallback = callback;
end

function AuctionHouseItemListMixin:OnLeaveListLine(line, rowData)
	if self.lineOnLeaveCallback then
		self.lineOnLeaveCallback(line, rowData);
	end
end

function AuctionHouseItemListMixin:SetSelectedEntry(rowData)
	if self.selectionCallback then
		if not self.selectionCallback(rowData) then
			return;
		end
	end

	self.selectedRowData = rowData;
	self:DirtyScrollFrame();
end

function AuctionHouseItemListMixin:GetSelectedEntry()
	return self.selectedRowData;
end

function AuctionHouseItemListMixin:OnShow()
	self:Init();
	self:UpdateTableBuilderLayout();
	self:RefreshScrollFrame();

	if self.refreshResultsFunc then
		self.refreshResultsFunc();
	end
end

function AuctionHouseItemListMixin:OnUpdate()
	if self.scrollFrameDirty then
		self:RefreshScrollFrame();
	end
end

function AuctionHouseItemListMixin:Reset()
	self.ScrollBox:ScrollToBegin();
	self:RefreshScrollFrame();
end

function AuctionHouseItemListMixin:SetState(state)
	if self.state == state then
		return;
	end

	self.state = state;

	local showResultsText = state ~= ItemListState.ShowResults and state ~= ItemListState.ResultsPending;
	self.ResultsText:SetShown(showResultsText);
	self.LoadingSpinner:Hide();
	if state == ItemListState.NoSearch then
		local searchResultsText = self.searchStartedFunc and select(2, self.searchStartedFunc());
		self.ResultsText:SetText(searchResultsText or "");
	elseif state == ItemListState.NoResults then
		self.ResultsText:SetText(BROWSE_NO_RESULTS);
	elseif state == ItemListState.ResultsPending then
		self.LoadingSpinner:Show();
	end

	self:UpdateRefreshFrame();

	if state ~= ItemListState.ShowResults then
		self.ScrollBox:RemoveDataProvider();
	end
end

function AuctionHouseItemListMixin:SetSelectedEntryByCondition(condition, scrollTo)
	if not self.getNumEntries then
		return;
	end

	local numEntries = self.getNumEntries();
	for i = 1, numEntries do
		local rowData = self.getEntry(i);
		if condition(rowData) then
			self:SetSelectedEntry(rowData);
			self:ScrollToEntryIndex(i);
			return;
		end
	end

	self:SetSelectedEntry(nil);
	self:RefreshScrollFrame();
end

function AuctionHouseItemListMixin:ScrollToEntryIndex(entryIndex)
	if not self.isInitialized then
		return;
	end
	self.ScrollBox:ScrollToElementDataIndex(entryIndex, ScrollBoxConstants.AlignCenter);
end

function AuctionHouseItemListMixin:GetScrollBoxDataIndexBegin()
	return self.ScrollBox:GetDataIndexBegin();
end

function AuctionHouseItemListMixin:UpdateRefreshFrame()
	if not self.RefreshFrame:IsShown() then
		return;
	end

	if state == ItemListState.NoSearch then
		self.RefreshFrame:Deactivate();
	elseif state == ItemListState.NoResults then
		self.RefreshFrame:SetQuantity(0);
	elseif state == ItemListState.ResultsPending then
		self.RefreshFrame:Deactivate();
	else -- state == ItemListState.ShowResults
		self.RefreshFrame:SetQuantity(self.totalQuantityFunc and self.totalQuantityFunc() or 0);
	end
end

function AuctionHouseItemListMixin:DirtyScrollFrame()
	self.scrollFrameDirty = true;
end

function AuctionHouseItemListMixin:RefreshScrollFrame()
	self.scrollFrameDirty = false;

	if not self.isInitialized or not self:IsShown() then
		return;
	end

	if not self.getNumEntries then
		error("Data provider not set. Use AuctionHouseItemListMixin:SetDataProvider.");
		return;
	end

	if self.searchStartedFunc and not self.searchStartedFunc() then
		self:SetState(ItemListState.NoSearch);
		return;
	end
	local numResults = self.getNumEntries();
	if numResults == 0 then
		local hasFullResults = not self.hasFullResultsFunc or self.hasFullResultsFunc();
		self:SetState(hasFullResults and ItemListState.NoResults or ItemListState.ResultsPending);
		return;
	end

	self:SetState(ItemListState.ShowResults);

	local dataProvider = CreateIndexRangeDataProvider(numResults);
	self.ScrollBox:SetDataProvider(dataProvider, ScrollBoxConstants.RetainScrollPosition);
	
	self:CallRefreshCallback();
end

function AuctionHouseItemListMixin:CallRefreshCallback()
	if self.refreshCallback ~= nil then
		local lastDisplayedEntry = self.ScrollBox:GetDataIndexEnd();
		self.refreshCallback(lastDisplayedEntry);
	end
end

function AuctionHouseItemListMixin:OnScrollBoxScroll(scrollPercentage, visibleExtentPercentage, panExtentPercentage)
	self:CallRefreshCallback();
end

function AuctionHouseItemListMixin:GetHeaderContainer()
	return self.HeaderContainer;
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemList.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemSellFrame.lua ---


local ITEM_SELL_SCROLL_OFFSET_REFRESH_THRESHOLD = 30;


AuctionHouseBuyoutModeCheckButtonMixin = {};

function AuctionHouseBuyoutModeCheckButtonMixin:OnLoad()
	self.Text:SetFontObject(GameFontNormal);
	self.Text:SetTextColor(NORMAL_FONT_COLOR:GetRGB());
	self.Text:SetText(AUCTION_HOUSE_BUYOUT_MODE_CHECK_BOX);
end

function AuctionHouseBuyoutModeCheckButtonMixin:OnShow()
	self:SetChecked(true);
	self:UpdateState();
end

function AuctionHouseBuyoutModeCheckButtonMixin:OnEnter()
	GameTooltip:SetOwner(self, "ANCHOR_RIGHT");

	local wrap = true;
	GameTooltip_AddNormalLine(GameTooltip, AUCTION_HOUSE_BUYOUT_MODE_TOOLTIP, wrap);

	GameTooltip:Show();
end

function AuctionHouseBuyoutModeCheckButtonMixin:OnLeave()
	GameTooltip_Hide();
end

function AuctionHouseBuyoutModeCheckButtonMixin:OnClick()
	self:UpdateState();
	PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
end

function AuctionHouseBuyoutModeCheckButtonMixin:UpdateState()
	self:GetParent():SetSecondaryPriceInputEnabled(not self:GetChecked());
end


AuctionHouseItemSellFrameMixin = CreateFromMixins(AuctionHouseSellFrameMixin);

local AUCTION_HOUSE_ITEM_SELL_FRAME_EVENTS = {
	"ITEM_SEARCH_RESULTS_UPDATED",
	"ITEM_SEARCH_RESULTS_ADDED",
	"AUCTION_MULTISELL_START",
	"AUCTION_MULTISELL_UPDATE",
	"AUCTION_MULTISELL_FAILURE",
};

function AuctionHouseItemSellFrameMixin:OnLoad()
	AuctionHouseSellFrameMixin.OnLoad(self);

	self:SetSearchContext(AuctionHouseSearchContext.SellItems);

	self.PriceInput:SetLabel(AUCTION_HOUSE_BUYOUT_LABEL);
	self.PriceInput:SetErrorTooltip(AUCTION_BUYOUT_ERROR);

	self.SecondaryPriceInput:SetOnValueChangedCallback(function()
		self:UpdatePostState();
	end);
end

function AuctionHouseItemSellFrameMixin:OnShow()
	AuctionHouseSellFrameMixin.OnShow(self);

	FrameUtil.RegisterFrameForEvents(self, AUCTION_HOUSE_ITEM_SELL_FRAME_EVENTS);

	self:InitializeItemSellList();

	self:UpdateNoneAvailableEntry();
end

function AuctionHouseItemSellFrameMixin:OnHide()
	AuctionHouseSellFrameMixin.OnHide(self);

	FrameUtil.UnregisterFrameForEvents(self, AUCTION_HOUSE_ITEM_SELL_FRAME_EVENTS);

	if AuctionHouseMultisellProgressFrame:IsShown() then
		-- Clear out any active multisell.
		C_AuctionHouse.CancelSell();
		self:SetMultiSell(false);
	end

	self.listDisplayedItemKey = nil;
end

function AuctionHouseItemSellFrameMixin:OnEvent(event, ...)
	AuctionHouseSellFrameMixin.OnEvent(self, event, ...);

	if event == "ITEM_SEARCH_RESULTS_UPDATED" then
		self:UpdateNoneAvailableEntry();
		self:UpdatePriceSelection();
		self:GetItemSellList():DirtyScrollFrame();
	elseif event == "ITEM_SEARCH_RESULTS_ADDED" then
		self:UpdateNoneAvailableEntry();
		self:GetItemSellList():DirtyScrollFrame();
	elseif event == "AUCTION_MULTISELL_START" then
		local itemLocation = self:GetItem();
		local itemTexture = itemLocation and C_Item.GetItemIcon(itemLocation);
		AuctionHouseMultisellProgressFrame:Start(itemTexture, self:GetQuantity());

		local inProgress = true;
		self:SetMultiSell(inProgress);
	elseif event == "AUCTION_MULTISELL_UPDATE" then
		local numPosted, total = ...;
		AuctionHouseMultisellProgressFrame:Refresh(numPosted, total);

		if numPosted == total then
			local inProgress = false;
			self:SetMultiSell(inProgress);
		end
	elseif event == "AUCTION_MULTISELL_FAILURE" then
		local inProgress = false;
		self:SetMultiSell(inProgress);
	end
end

function AuctionHouseItemSellFrameMixin:SetMultiSell(inProgress)
	self.multisellInProgress = inProgress;
	AuctionHouseMultisellProgressFrame:SetShown(inProgress);
	self.DisabledOverlay:SetShown(inProgress);
	if not inProgress then
		local fromItemDisplay = nil;
		local refreshListWithPreviousItem = true;
		self:SetItem(nil, fromItemDisplay, refreshListWithPreviousItem);
	end
end

local function RowDataCheapestBuyoutComparison(lhs, rhs)
	if (lhs == nil) and (rhs == nil) then
		return false;
	elseif (lhs == nil) or (rhs == nil) then
		return lhs ~= nil;
	elseif (lhs.buyoutAmount ~= nil) and (rhs.buyoutAmount ~= nil) then
		return lhs.buyoutAmount < rhs.buyoutAmount;
	elseif (lhs.buyoutAmount ~= nil) or (rhs.buyoutAmount ~= nil) then
		return lhs.buyoutAmount ~= nil;
	elseif (lhs.bidAmount ~= nil) and (rhs.bidAmount ~= nil) then
		return lhs.bidAmount < rhs.bidAmount;
	elseif (lhs.bidAmount ~= nil) or (rhs.bidAmount ~= nil) then
		return lhs.bidAmount ~= nil;
	end

	return false;
end

function AuctionHouseItemSellFrameMixin:GetBestEntry()
	if (self.itemLocation == nil) or (self.listDisplayedItemKey == nil) then
		return nil;
	end

	local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(self.listDisplayedItemKey);
	local itemLevel = C_Item.GetCurrentItemLevel(self.itemLocation);
	local isGreenQuality = C_Item.GetItemQuality(self.itemLocation) == Enum.ItemQuality.Uncommon;
	local ignoreItemLevel = isGreenQuality or itemKeyInfo.isPet;
	local bestEntry = nil;
	local numSearchResults = C_AuctionHouse.GetNumItemSearchResults(self.listDisplayedItemKey);
	for i = 1, numSearchResults do
		local searchResult = C_AuctionHouse.GetItemSearchResultInfo(self.listDisplayedItemKey, i);
		if ignoreItemLevel or (searchResult.itemKey.itemLevel == itemLevel) then
			if RowDataCheapestBuyoutComparison(searchResult, bestEntry) then
				bestEntry = searchResult;
			end
		end
	end

	if (numSearchResults > 0) and (bestEntry == nil) then
		bestEntry = self.noneAvailableEntry;
	end

	return bestEntry;
end

function AuctionHouseItemSellFrameMixin:ClearNoneAvailableEntry()
	self.noneAvailableIndex = nil;
	self.noneAvailableEntry = nil;
end

function AuctionHouseItemSellFrameMixin:UpdateNoneAvailableEntry()
	local previousEntry = self.noneAvailableEntry;

	self:ClearNoneAvailableEntry();
	if (self.itemLocation == nil) or (self.listDisplayedItemKey == nil) then
		return;
	end

	local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(self.listDisplayedItemKey);
	if itemKeyInfo.isPet then
		return;
	end

	local numSearchResults = C_AuctionHouse.GetNumItemSearchResults(self.listDisplayedItemKey);
	if numSearchResults == 0 then
		return;
	end

	local sorts = self:GetAuctionHouseFrame():GetSortsForContext(AuctionHouseSearchContext.SellItems);
	local primarySort = sorts[1];
	local reverseSort = primarySort.reverseSort;

	local itemLevel = C_Item.GetCurrentItemLevel(self.itemLocation);
	local noneAvailableIndex = nil;
	for i = 1, numSearchResults do
		local searchResult = C_AuctionHouse.GetItemSearchResultInfo(self.listDisplayedItemKey, i);
		if searchResult.itemKey.itemLevel == itemLevel then
			return;
		elseif (searchResult.itemKey.itemLevel > itemLevel) then
			if reverseSort then
				noneAvailableIndex = i + 1;
			elseif noneAvailableIndex == nil then
				noneAvailableIndex = i;
			end
		end
	end

	self.noneAvailableIndex = noneAvailableIndex or (numSearchResults + 1);

	local isSelectedVirtualEntry = (previousEntry ~= nil) and (self:GetItemSellList():GetSelectedEntry() == previousEntry);
	self.noneAvailableEntry = AuctionHouseUtil.CreateVirtualRowData(AUCTION_HOUSE_NONE_AVAILABLE_FORMAT:format(itemLevel), isSelectedVirtualEntry);
end

function AuctionHouseItemSellFrameMixin:UpdatePriceSelection()
	self:ClearSearchResultPrice();

	if self.listDisplayedItemKey then
		local defaultPrice = self:GetDefaultPrice();
		local defaultBid = not self.SecondaryPriceInput:IsShown() or self.SecondaryPriceInput:GetAmount() == 0;
		local defaultBuyout = self.PriceInput:GetAmount() == defaultPrice;


		if (C_AuctionHouse.ShouldAutoPopulatePrice()) then
			-- If the user hasn't entered a price, update to the lowest price available.
			if defaultBid and defaultBuyout then
				local bestEntry = self:GetBestEntry();
				if bestEntry ~= nil then
					self:GetItemSellList():SetSelectedEntry(bestEntry);
				end
			end
		else
			self:GetItemSellList():SetSelectedEntry(nil);
		end
	end
end

function AuctionHouseItemSellFrameMixin:InitializeItemSellList()
	if self.itemSellListIsInitialized then
		return;
	end

	self.itemSellListIsInitialized = true;

	local itemSellList = self:GetItemSellList();

	itemSellList:SetSelectionCallback(AuctionHouseUtil.GenerateRowSelectedCallbackWithInspect(self, self.OnSearchResultSelected));

	itemSellList:SetHighlightCallback(function(currentRowData, selectedRowData)
		return selectedRowData and currentRowData.auctionID == selectedRowData.auctionID;
	end);

	itemSellList:SetLineOnEnterCallback(AuctionHouseUtil.LineOnEnterCallback);
	itemSellList:SetLineOnLeaveCallback(AuctionHouseUtil.LineOnLeaveCallback);

	local isEquipment = false;
	local isPet = false;
	itemSellList:SetTableBuilderLayout(AuctionHouseTableBuilder.GetItemSellListLayout(self, itemSellList, isEquipment, isPet));

	local function ItemSellListSearchStarted()
		return self.listDisplayedItemKey ~= nil;
	end

	local function ItemSellListGetEntry(index)
		if self.listDisplayedItemKey == nil then
			return nil;
		end

		if self.noneAvailableIndex ~= nil then
			if index > self.noneAvailableIndex then
				index = index - 1;
			elseif index == self.noneAvailableIndex then
				return self.noneAvailableEntry;
			end
		end

		return C_AuctionHouse.GetItemSearchResultInfo(self.listDisplayedItemKey, index);
	end

	local function ItemSellListGetNumEntries()
		if self.listDisplayedItemKey == nil then
			return 0;
		end

		return C_AuctionHouse.GetNumItemSearchResults(self.listDisplayedItemKey) + ((self.noneAvailableIndex ~= nil) and 1 or 0);
	end

	local function ItemSellListHasFullResults()
		return self.listDisplayedItemKey == nil or C_AuctionHouse.HasFullItemSearchResults(self.listDisplayedItemKey);
	end

	itemSellList:SetDataProvider(ItemSellListSearchStarted, ItemSellListGetEntry, ItemSellListGetNumEntries, ItemSellListHasFullResults);


	local function ItemSellListGetTotalQuantity()
		return self.listDisplayedItemKey and C_AuctionHouse.GetItemSearchResultsQuantity(self.listDisplayedItemKey) or 0; -- Implemented in-line instead for performance.
	end

	local function ItemSellListRefreshResults()
		if self.listDisplayedItemKey ~= nil then
			self:GetAuctionHouseFrame():RefreshSearchResults(self:GetSearchContext(), self.listDisplayedItemKey);
		end
	end

	itemSellList:SetRefreshFrameFunctions(ItemSellListGetTotalQuantity, ItemSellListRefreshResults);
end

function AuctionHouseItemSellFrameMixin:OnSearchResultSelected(searchResult)
	if (not searchResult) then
		return;
	end

	if self.SecondaryPriceInput:IsShown() then
		self.SecondaryPriceInput:SetAmount(searchResult.bidAmount or 0);
	end
	
	self.PriceInput:SetAmount(searchResult.buyoutAmount or 0);
	self:SetSearchResultPrice(searchResult.buyoutAmount);

	if self.noneAvailableEntry ~= nil then
		self.noneAvailableEntry.isSelectedVirtualEntry = (searchResult == self.noneAvailableEntry);
	end
end

function AuctionHouseItemSellFrameMixin:SetSecondaryPriceInputEnabled(enabled)
	self.BuyoutModeCheckButton:SetChecked(not enabled);
	self.PriceInput:SetLabel(AUCTION_HOUSE_BUYOUT_LABEL);
	self.PriceInput:SetSubtext(enabled and AUCTION_HOUSE_BUYOUT_OPTIONAL_LABEL or nil);
	self.PriceInput.PerItemPostfix:SetShown(not enabled);
	self.SecondaryPriceInput:SetShown(enabled);
	self.SecondaryPriceInput:Clear();

	self:UpdatePostState();
	self:UpdateFocusTabbing();
	self:MarkDirty();
end

function AuctionHouseItemSellFrameMixin:SetItem(itemLocation, fromItemDisplay, refreshListWithPreviousItem)
	if self.DisabledOverlay:IsShown() then
		return;
	end

	self:ClearNoneAvailableEntry();

	AuctionHouseSellFrameMixin.SetItem(self, itemLocation, fromItemDisplay);

	self.SecondaryPriceInput:Clear();

	local itemKey = itemLocation and C_AuctionHouse.GetItemKeyFromItem(itemLocation) or nil;
	if refreshListWithPreviousItem and self.previousItemKey then
		itemKey = self.previousItemKey;
	end

	local newItemKey = AuctionHouseUtil.ConvertItemSellItemKey(itemKey);
	self.listDisplayedItemKey = newItemKey;

	local itemSellList = self:GetItemSellList();
	local itemKeyInfo = nil;
	if itemKey then
		itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(itemKey);
		itemSellList:SetTableBuilderLayout(AuctionHouseTableBuilder.GetItemSellListLayout(self, itemSellList, itemKeyInfo and itemKeyInfo.isEquipment, itemKeyInfo and itemKeyInfo.isPet));
	else
		itemSellList:SetTableBuilderLayout(AuctionHouseTableBuilder.GetItemSellListLayout(self, itemSellList));
	end

	local hasItemKey = itemKey ~= nil;
	if hasItemKey then
		local function ItemSellListRefreshCallback(lastDisplayEntry)
			local numEntries = C_AuctionHouse.GetNumItemSearchResults(itemKey);
			if numEntries > 0 and numEntries - lastDisplayEntry < ITEM_SELL_SCROLL_OFFSET_REFRESH_THRESHOLD then
				local hasFullResults = C_AuctionHouse.RequestMoreItemSearchResults(itemKey);
				if hasFullResults then
					itemSellList:SetRefreshCallback(nil);
				end
			end
		end

		itemSellList:SetRefreshCallback(ItemSellListRefreshCallback);
	else
		itemSellList:SetRefreshCallback(nil);
	end

	if hasItemKey then
		self:GetAuctionHouseFrame():QueryItem(self:GetSearchContext(), itemKey, itemKeyInfo and itemKeyInfo.isEquipment);
	end

	self:UpdateNoneAvailableEntry();
	self:UpdatePriceSelection();
	itemSellList:DirtyScrollFrame();

	self.previousItemKey = itemKey;
end

function AuctionHouseItemSellFrameMixin:UpdatePostState()
	AuctionHouseSellFrameMixin.UpdatePostState(self);

	local bidPrice, buyoutPrice = self:GetPrice();
	if bidPrice and buyoutPrice and buyoutPrice <= bidPrice then
		self.PriceInput:SetLabelColor(RED_FONT_COLOR);
		self.PriceInput:SetErrorShown(true);
	else
		self.PriceInput:SetLabelColor(NORMAL_FONT_COLOR);
		self.PriceInput:SetErrorShown(false);
	end
end

function AuctionHouseItemSellFrameMixin:UpdateFocusTabbing()
	if self.SecondaryPriceInput:IsShown() then
		self.QuantityInput:SetNextEditBox(self.SecondaryPriceInput.MoneyInputFrame.GoldBox);
		self.SecondaryPriceInput:SetNextEditBox(self.PriceInput.MoneyInputFrame.GoldBox);
		self.PriceInput:SetNextEditBox(self.QuantityInput:IsShown() and self.QuantityInput.InputBox or self.SecondaryPriceInput.MoneyInputFrame.GoldBox);
	else
		self.QuantityInput:SetNextEditBox(self.PriceInput.MoneyInputFrame.GoldBox);
		self.PriceInput:SetNextEditBox(self.QuantityInput:IsShown() and self.QuantityInput.InputBox or nil);
	end
end

function AuctionHouseItemSellFrameMixin:GetDepositAmount()
	local item = self:GetItem();
	if not item then
		return 0;
	end

	local duration = self:GetDuration();
	local quantity = self:GetQuantity();
	local deposit = C_AuctionHouse.CalculateItemDeposit(item, duration, quantity);
	return deposit;
end

function AuctionHouseItemSellFrameMixin:GetTotalPrice()
	local bidPrice, buyoutPrice = self:GetPrice();
	return self:GetQuantity() * (buyoutPrice or bidPrice or 0);
end

function AuctionHouseItemSellFrameMixin:GetPrice()
	local buyoutPrice = self.PriceInput:GetAmount();
	local bidPrice = self.SecondaryPriceInput:IsShown() and self.SecondaryPriceInput:GetAmount() or nil;

	if buyoutPrice == 0 then
		buyoutPrice = nil;
	end

	if bidPrice == 0 then
		bidPrice = nil;
	end

	return bidPrice, buyoutPrice;
end

function AuctionHouseItemSellFrameMixin:CanPostItem()
	if self.multisellInProgress then
		return false, nil;
	end

	local canPostItem, reasonTooltip = AuctionHouseSellFrameMixin.CanPostItem(self);
	if not canPostItem then
		return canPostItem, reasonTooltip;
	end

	local bidPrice, buyoutPrice = self:GetPrice();
	if bidPrice == nil and buyoutPrice == nil then
		return false, AUCTION_HOUSE_SELL_FRAME_ERROR_PRICE;
	end

	if bidPrice and buyoutPrice and buyoutPrice <= bidPrice then
		return false, AUCTION_HOUSE_SELL_FRAME_ERROR_BUYOUT;
	end

	return true, nil;
end

function AuctionHouseItemSellFrameMixin:GetPostDetails()
	local item = self:GetItem();
	local duration = self:GetDuration();
	local quantity = self:GetQuantity();
	local bidPrice, buyoutPrice = self:GetPrice();

	return item, duration, quantity, bidPrice, buyoutPrice;
end

function AuctionHouseItemSellFrameMixin:StartPost(...)
	if not self:CanPostItem() then
		return;
	end

	if not C_AuctionHouse.PostItem(...) then
		self:ClearPost();
	else
		self:CachePendingPost(...);
	end
end

function AuctionHouseItemSellFrameMixin:PostItem()
	self:StartPost(self:GetPostDetails());
end

function AuctionHouseItemSellFrameMixin:ConfirmPost()
	if self.pendingPost then
		C_AuctionHouse.ConfirmPostItem(SafeUnpack(self.pendingPost));
		self:ClearPost();
		return true;
	end
end

function AuctionHouseItemSellFrameMixin:CachePendingPost(...)
	self.pendingPost = SafePack(...);
end

function AuctionHouseItemSellFrameMixin:ClearPost()
	self.pendingPost = nil;

	if self:GetQuantity() == 1 then
		local fromItemDisplay = nil;
		local refreshListWithPreviousItem = true;
		self:SetItem(nil, fromItemDisplay, refreshListWithPreviousItem);
	end
end

function AuctionHouseItemSellFrameMixin:GetItemSellList()
	return self:GetAuctionHouseFrame():GetItemSellList();
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemSellFrame.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemSellFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Frame name="AuctionHouseItemSellFrameTemplate" inherits="AuctionHouseSellFrameTemplate" mixin="AuctionHouseItemSellFrameMixin" virtual="true">
		<Frames>
			<CheckButton parentKey="BuyoutModeCheckButton" frameLevel="350" mixin="AuctionHouseBuyoutModeCheckButtonMixin" inherits="UICheckButtonTemplate">
				<Size x="36" y="36"/>
				<Anchors>
					<Anchor point="BOTTOMLEFT" x="8" y="8"/>
				</Anchors>
				<Scripts>
					<OnLoad method="OnLoad"/>
					<OnShow method="OnShow"/>
					<OnEnter method="OnEnter"/>
					<OnLeave method="OnLeave"/>
					<OnClick method="OnClick"/>
				</Scripts>
			</CheckButton>
			<Frame parentKey="SecondaryPriceInput" inherits="AuctionHouseAlignedPriceInputFrameTemplate" hidden="true">
				<Size x="300" y="20"/>
				<KeyValues>
					<KeyValue key="topPadding" value="5" type="number"/>
					<KeyValue key="layoutIndex" value="25" type="number"/>
					<KeyValue key="labelText" value="AUCTION_HOUSE_BID_LABEL" type="global"/>
				</KeyValues>
			</Frame>
			<Button parentKey="DisabledOverlay" frameLevel="1500" setAllPoints="true" hidden="true">
				<Layers>
					<Layer level="OVERLAY">
						<Texture setAllPoints="true">
							<Color r="0" g="0" b="0" a="0.4"/>
						</Texture>
					</Layer>
				</Layers>
			</Button>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseItemSellFrame.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseMultisell.lua ---


local MULTISELL_ALPHA_STEP = 0.05;

MultisellProgressFrameMixin = {};

local function MultisellProgressFrame_OnUpdate(self)
	local alpha = self:GetAlpha() - MULTISELL_ALPHA_STEP;
	if alpha > 0 then
		self:SetAlpha(alpha);
	else
		self:SetScript("OnUpdate", nil);
	end
end

function MultisellProgressFrameMixin:Start(itemTexture, total)
	self:SetAlpha(1);
	self:SetScript("OnUpdate", nil);
	self.ProgressBar:SetMinMaxValues(0, total);
	self.ProgressBar:SetValue(0.01);
	self.ProgressBar.Text:SetFormattedText(AUCTION_CREATING, 0, total);
	self.ProgressBar.Icon:SetTexture(itemTexture);
end

function MultisellProgressFrameMixin:Refresh(currentCount, totalCount)
	self.ProgressBar:SetValue(currentCount);
	self.ProgressBar.Text:SetFormattedText(AUCTION_CREATING, currentCount, totalCount);
	if currentCount == totalCount then
		self:SetScript("OnUpdate", MultisellProgressFrame_OnUpdate);
	end
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseMultisell.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSearchBar.lua ---

AuctionHouseSearchButtonMixin = {};

function AuctionHouseSearchButtonMixin:OnClick()
	self:GetParent():StartSearch();
	PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
end


AuctionHouseFavoritesSearchButtonMixin = {};

local AUCTION_HOUSE_FAVORITES_SEARCH_BUTTON_EVENTS = {
	"AUCTION_HOUSE_FAVORITES_UPDATED",
};

function AuctionHouseFavoritesSearchButtonMixin:OnLoad()
	local function FavoriteSearchOnClickHandler()
		self:GetParent():StartFavoritesSearch();
	end

	self:SetOnClickHandler(FavoriteSearchOnClickHandler);
	self:SetAtlas("auctionhouse-icon-favorite");

	SquareIconButtonMixin.OnLoad(self);
end

function AuctionHouseFavoritesSearchButtonMixin:OnShow()
	FrameUtil.RegisterFrameForEvents(self, AUCTION_HOUSE_FAVORITES_SEARCH_BUTTON_EVENTS);

	self:UpdateState();
end

function AuctionHouseFavoritesSearchButtonMixin:OnHide()
	FrameUtil.UnregisterFrameForEvents(self, AUCTION_HOUSE_FAVORITES_SEARCH_BUTTON_EVENTS);
end

function AuctionHouseFavoritesSearchButtonMixin:OnEvent(event, ...)
	self:UpdateState();
end

function AuctionHouseFavoritesSearchButtonMixin:OnEnter()
	local hasFavorites = C_AuctionHouse.HasFavorites();
	self:SetTooltipInfo(AUCTION_HOUSE_FAVORITES_SEARCH_TOOLTIP_TITLE, not hasFavorites and AUCTION_HOUSE_FAVORITES_SEARCH_TOOLTIP_NO_FAVORITES or nil);

	SquareIconButtonMixin.OnEnter(self);
end

function AuctionHouseFavoritesSearchButtonMixin:UpdateState()
	local hasFavorites = C_AuctionHouse.HasFavorites();
	self:SetEnabled(hasFavorites);
	self.Icon:SetDesaturated(not hasFavorites);
end


AuctionHouseFilterButtonMixin = {};

function AuctionHouseFilterButtonMixin:OnLoad()
	WowStyle1FilterDropdownMixin.OnLoad(self);

	self:Reset();

	self.ClearFiltersButton:SetScript("OnClick", function()
		self:Reset();
	end);
end

function AuctionHouseFilterButtonMixin:ToggleFilter(filter)
	self.filters[filter] = not self.filters[filter];

	self:GetParent():OnFilterToggled();
end

function AuctionHouseFilterButtonMixin:Reset()
	self.filters = CopyTable(AUCTION_HOUSE_DEFAULT_FILTERS);
	self.minLevel = 0;
	self.maxLevel = 0;
	self.ClearFiltersButton:Hide();
end

function AuctionHouseFilterButtonMixin:GetFilters()
	return self.filters;
end

function AuctionHouseFilterButtonMixin:CalculateFiltersArray()
	local filtersArray = {};
	for key, value in pairs(self.filters) do
		if value then
			table.insert(filtersArray, key);
		end
	end
	return filtersArray;
end

function AuctionHouseFilterButtonMixin:GetLevelRange()
	return self.minLevel, self.maxLevel;
end

AuctionHouseSearchBoxMixin = {};

function AuctionHouseSearchBoxMixin:OnEnterPressed()
	EditBox_ClearFocus(self);
	self:GetParent():StartSearch();
end

function AuctionHouseSearchBoxMixin:Reset()
	self:SetText("");
end

function AuctionHouseSearchBoxMixin:GetSearchString()
	return self:GetText();
end


AuctionHouseSearchBarMixin = CreateFromMixins(AuctionHouseSystemMixin);

function AuctionHouseSearchBarMixin:OnLoad()
	local function IsSelected(filter)
		return self.FilterButton.filters[filter];
	end

	local function SetSelected(filter)
		self.FilterButton:ToggleFilter(filter);
	end

	self.FilterButton:SetWidth(93);
	self.FilterButton:SetupMenu(function(dropdown, rootDescription)
		rootDescription:SetTag("MENU_AUCTION_HOUSE_SEARCH_FILTER");

		rootDescription:CreateTitle(AUCTION_HOUSE_FILTER_DROP_DOWN_LEVEL_RANGE);

		local levelRangeFrame = rootDescription:CreateTemplate("LevelRangeFrameTemplate");
		levelRangeFrame:AddInitializer(function(frame, elementDescription, menu)
			frame:Reset();

			local minLevel = self.FilterButton.minLevel;
			if minLevel > 0 then
				frame:SetMinLevel(minLevel);
			end

			local maxLevel = self.FilterButton.maxLevel;
			if maxLevel > 0 then
				frame:SetMaxLevel(maxLevel);
			end

			frame:SetLevelRangeChangedCallback(function(minLevel, maxLevel)
				self.FilterButton.minLevel, self.FilterButton.maxLevel = minLevel, maxLevel;
				self:UpdateClearFiltersButton();
			end);
		end);

		for index, filterGroup in ipairs(C_AuctionHouse.GetFilterGroups()) do
			rootDescription:CreateTitle(GetAHFilterCategoryName(filterGroup.category));

			for _, filter in ipairs(filterGroup.filters) do
				rootDescription:CreateCheckbox(GetAHFilterName(filter), IsSelected, SetSelected, filter);
			end

			rootDescription:QueueSpacer();
		end
	end);
end

function AuctionHouseSearchBarMixin:OnShow()
	self.SearchBox:Reset();
	self.FilterButton:Reset();
end

function AuctionHouseSearchBarMixin:OnFilterToggled()
	self:UpdateClearFiltersButton();
end

function AuctionHouseSearchBarMixin:UpdateClearFiltersButton()
	local areFiltersDefault = tCompare(self.FilterButton:GetFilters(), AUCTION_HOUSE_DEFAULT_FILTERS);
	local minLevel, maxLevel = self.FilterButton:GetLevelRange();
	self.FilterButton.ClearFiltersButton:SetShown(not areFiltersDefault or minLevel ~= 0 or maxLevel ~= 0);
end

function AuctionHouseSearchBarMixin:SetSearchText(searchText)
	self.SearchBox:SetText(searchText);
end

function AuctionHouseSearchBarMixin:GetLevelFilterRange()
	return self.FilterButton:GetLevelRange();
end

function AuctionHouseSearchBarMixin:StartSearch()
	local searchString = self.SearchBox:GetSearchString();
	local minLevel, maxLevel = self:GetLevelFilterRange();
	local filtersArray = self.FilterButton:CalculateFiltersArray();
	self:GetAuctionHouseFrame():SendBrowseQuery(searchString, minLevel, maxLevel, filtersArray);
end

function AuctionHouseSearchBarMixin:StartFavoritesSearch()
	self:GetParent():GetCategoriesList():SetSelectedCategory(nil);
	self:GetAuctionHouseFrame():QueryAll(AuctionHouseSearchContext.AllFavorites);
end

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSearchBar.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSearchBar.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
		
	<EditBox name="AuctionHouseSearchBoxTemplate" autoFocus="false" historyLines="1" bytes="64" mixin="AuctionHouseSearchBoxMixin" inherits="SearchBoxTemplate" virtual="true">
		<Size x="241" y="22"/>
		<Scripts>
			<OnEnterPressed method="OnEnterPressed"/>
		</Scripts>
	</EditBox>
	
	<Button name="AuctionHouseFavoritesSearchButtonTemplate" mixin="AuctionHouseFavoritesSearchButtonMixin" inherits="SquareIconButtonTemplate" motionScriptsWhileDisabled="true" virtual="true">
		<Scripts>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Button>

	<DropdownButton name="AuctionHouseFilterButtonTemplate" mixin="AuctionHouseFilterButtonMixin" inherits="WowStyle1FilterDropdownTemplate" virtual="true">
		<Frames>
			<Button parentKey="ClearFiltersButton">
				<Size x="23" y="23"/>
				<Anchors>
					<Anchor point="CENTER" relativeKey="$parent" relativePoint="TOPRIGHT" x="-3" y="0"/>
				</Anchors>
				<NormalTexture atlas="auctionhouse-ui-filter-redx">
					<Size x="23" y="23"/>
				</NormalTexture>
				<HighlightTexture atlas="auctionhouse-ui-filter-redx" alphaMode="ADD" alpha="0.4">
					<Size x="23" y="23"/>
				</HighlightTexture>
			</Button>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
		</Scripts>
	</DropdownButton>

	<Button name="AuctionHouseSearchButtonTemplate" text="AUCTION_HOUSE_SEARCH_BUTTON" mixin="AuctionHouseSearchButtonMixin" inherits="UIPanelButtonTemplate" virtual="true">
		<Size x="132" y="22"/>
		<Scripts>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>	

	<Frame name="AuctionHouseSearchBarTemplate" mixin="AuctionHouseSearchBarMixin" virtual="true">
		<Size x="618" y="40"/>
		<Frames>
			<Button parentKey="FavoritesSearchButton" inherits="AuctionHouseFavoritesSearchButtonTemplate">
				<Anchors>
					<Anchor point="LEFT" x="0" y="0"/>
				</Anchors>
			</Button>
			<EditBox parentKey="SearchBox" inherits="AuctionHouseSearchBoxTemplate">
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.FavoritesSearchButton" relativePoint="RIGHT" x="9" y="0"/>
				</Anchors>
			</EditBox>
			<Button parentKey="SearchButton" inherits="AuctionHouseSearchButtonTemplate">
				<Anchors>
					<Anchor point="RIGHT" relativeKey="$parent" relativePoint="RIGHT" x="0" y="0"/>
				</Anchors>
			</Button>
			<DropdownButton parentKey="FilterButton" inherits="AuctionHouseFilterButtonTemplate">
				<Anchors>
					<Anchor point="RIGHT" relativeKey="$parent.SearchButton" relativePoint="LEFT" x="-10" y="0"/>
				</Anchors>
			</DropdownButton>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSearchBar.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSellFrame.lua ---


AuctionHouseSellFrameAlignedControlMixin = {};

function AuctionHouseSellFrameAlignedControlMixin:OnLoad()
	self:SetLabel(self.labelText);
end

function AuctionHouseSellFrameAlignedControlMixin:SetLabel(text)
	self.Label:SetText(text or "");
	self.LabelTitle:SetText(text or "");
end

function AuctionHouseSellFrameAlignedControlMixin:SetSubtext(text)
	self.Subtext:SetText(text);

	local hasSubtext = text ~= nil;
	self.Label:SetShown(not hasSubtext);
	self.LabelTitle:SetShown(hasSubtext);
	self.Subtext:SetShown(hasSubtext);
end

function AuctionHouseSellFrameAlignedControlMixin:SetLabelColor(color)
	self.Label:SetTextColor(color:GetRGB());
	self.LabelTitle:SetTextColor(color:GetRGB());
end


AuctionHouseAlignedQuantityInputBoxMixin = {};

function AuctionHouseAlignedQuantityInputBoxMixin:OnEditFocusLost()
	EditBox_ClearHighlight(self);

	if self:GetNumber() < 1 then
		self:Reset();

		local inputChangedCallback = self:GetInputChangedCallback();
		if inputChangedCallback then
			inputChangedCallback();
		end
	end
end

function AuctionHouseAlignedQuantityInputBoxMixin:SetNextEditBox(nextEditBox)
	self.nextEditBox = nextEditBox;

	if nextEditBox then
		nextEditBox.previousEditBox = self;
	end
end


AuctionHouseQuantityInputMaxButtonMixin = {};

function AuctionHouseQuantityInputMaxButtonMixin:OnClick()
	self:GetParent():GetParent():SetToMaxQuantity();
	PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
end


AuctionHouseAlignedQuantityInputFrameMixin = {};

function AuctionHouseAlignedQuantityInputFrameMixin:GetQuantity()
	return self.InputBox:GetNumber();
end

function AuctionHouseAlignedQuantityInputFrameMixin:SetQuantity(quantity)
	self.InputBox:SetNumber(quantity);
end

function AuctionHouseAlignedQuantityInputFrameMixin:SetInputChangedCallback(callback)
	self.InputBox:SetInputChangedCallback(callback);
end

function AuctionHouseAlignedQuantityInputFrameMixin:Reset()
	self.InputBox:Reset();
end

function AuctionHouseAlignedQuantityInputFrameMixin:SetNextEditBox(nextEditBox)
	self.InputBox:SetNextEditBox(nextEditBox);
end


AuctionHouseAlignedPriceInputFrameMixin = {};

function AuctionHouseAlignedPriceInputFrameMixin:OnLoad()
	AuctionHouseSellFrameAlignedControlMixin.OnLoad(self);

	if (C_AuctionHouse.SupportsCopperValues()) then
		self.PerItemPostfix:ClearAllPoints();
		self.PerItemPostfix:SetPoint("RIGHT", self.MoneyInputFrame, "LEFT", -20, -10);
	end
end

function AuctionHouseAlignedPriceInputFrameMixin:SetNextEditBox(nextEditBox)
	self.MoneyInputFrame:SetNextEditBox(nextEditBox);
end

function AuctionHouseAlignedPriceInputFrameMixin:Clear()
	self.MoneyInputFrame:Clear();
end

function AuctionHouseAlignedPriceInputFrameMixin:SetAmount(amount)
	if amount == 0 then
		self.MoneyInputFrame:Clear();
	else
		self.MoneyInputFrame:SetAmount(amount);
	end
end

function AuctionHouseAlignedPriceInputFrameMixin:GetAmount()
	return self.MoneyInputFrame:GetAmount();
end

function AuctionHouseAlignedPriceInputFrameMixin:SetOnValueChangedCallback(callback)
	return self.MoneyInputFrame:SetOnValueChangedCallback(callback);
end

function AuctionHouseAlignedPriceInputFrameMixin:SetErrorTooltip(tooltip)
	self.PriceError:SetTooltip(tooltip);
end

function AuctionHouseAlignedPriceInputFrameMixin:SetErrorShown(shown)
	self.PriceError:SetShown(shown);
end


AuctionHousePriceErrorFrameMixin = {};

function AuctionHousePriceErrorFrameMixin:OnEnter()
	if self.tooltip then
		GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
		local wrap = true;
		GameTooltip_AddColoredLine(GameTooltip, self.tooltip, RED_FONT_COLOR, wrap);
		GameTooltip:Show();
	end
end

function AuctionHousePriceErrorFrameMixin:OnLeave()
	GameTooltip_Hide();
end

function AuctionHousePriceErrorFrameMixin:SetTooltip(tooltip)
	self.tooltip = tooltip;
end


AuctionHouseAlignedDurationMixin = {};

function AuctionHouseAlignedDurationMixin:OnLoad()
	AuctionHouseSellFrameAlignedControlMixin.OnLoad(self);

	local function IsSelected(index)
		return self:GetDuration() == index;
	end

	local function SetSelected(index)
		self:SetDuration(index);
	end
	
	self.Dropdown:SetWidth(115);
	self.Dropdown.Text:SetFontObject("Number12Font");
	self.Dropdown.Text:SetJustifyH("RIGHT");
	self.Dropdown:SetupMenu(function(region, rootDescription)
		rootDescription:SetTag("MENU_AUCTION_HOUSE_DURATION");

		for index, durationText in ipairs({AUCTION_DURATION_ONE, AUCTION_DURATION_TWO, AUCTION_DURATION_THREE}) do
			local radio = rootDescription:CreateRadio(durationText, IsSelected, SetSelected, index);
			radio:AddInitializer(function(button, description, menu)
				button.fontString:SetFontObject("Number12Font");
			end);
		end
	end);
end

function AuctionHouseAlignedDurationMixin:OnShow()
	if self.durationIndex == nil then
		self.durationIndex = tonumber(GetCVar("auctionHouseDurationDropdown"));
	end

	self.Dropdown:GenerateMenu();
end

function AuctionHouseAlignedDurationMixin:GetDuration()
	return self.durationIndex or tonumber(GetCVar("auctionHouseDurationDropdown"));
end

function AuctionHouseAlignedDurationMixin:SetDuration(index)
	self.durationIndex = index;
	SetCVar("auctionHouseDurationDropdown", index);
	self:GetParent():OnDurationUpdated();
end

AuctionHouseAlignedPriceDisplayMixin = {};

function AuctionHouseAlignedPriceDisplayMixin:GetAmount(amount)
	return self.MoneyDisplayFrame:GetAmount();
end

function AuctionHouseAlignedPriceDisplayMixin:SetAmount(amount)
	self.MoneyDisplayFrame:SetAmount(amount);
end


AuctionHouseSellFramePostButtonMixin = {};

function AuctionHouseSellFramePostButtonMixin:OnClick()
	self:GetParent():PostItem();
	PlaySound(SOUNDKIT.LOOT_WINDOW_COIN_SOUND);
end

function AuctionHouseSellFramePostButtonMixin:OnEnter()
	if self.tooltip then
		GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
		local wrap = true;
		GameTooltip_AddColoredLine(GameTooltip, self.tooltip, RED_FONT_COLOR, wrap);
		GameTooltip:Show();
	end
end

function AuctionHouseSellFramePostButtonMixin:OnLeave()
	GameTooltip_Hide();
end

function AuctionHouseSellFramePostButtonMixin:SetTooltip(tooltip)
	self.tooltip = tooltip;
end


AuctionHouseSellFrameOverlayMixin = {};

function AuctionHouseSellFrameOverlayMixin:OnEnter()
	self:GetParent():OnOverlayEnter();
end

function AuctionHouseSellFrameOverlayMixin:OnLeave()
	self:GetParent():OnOverlayLeave();
end

function AuctionHouseSellFrameOverlayMixin:OnClick()
	self:GetParent():OnOverlayClick();
end

function AuctionHouseSellFrameOverlayMixin:OnReceiveDrag()
	self:GetParent():OnOverlayReceiveDrag();
end


AuctionHouseSellFrameItemDisplayMixin = {};

function AuctionHouseSellFrameItemDisplayMixin:OnLoad()
	AuctionHouseInteractableItemDisplayMixin.OnLoad(self);

	self.NineSlice:Hide();
end


AuctionHouseSellFrameMixin = CreateFromMixins(AuctionHouseSortOrderSystemMixin);

local AUCTION_HOUSE_SELL_FRAME_EVENTS = {
	"CURSOR_CHANGED",
	"AUCTION_HOUSE_THROTTLED_SYSTEM_READY",
	"AUCTION_HOUSE_THROTTLED_MESSAGE_SENT",
}

function AuctionHouseSellFrameMixin:OnLoad()
	AuctionHouseBackgroundMixin.OnLoad(self);
	AuctionHouseSortOrderSystemMixin.OnLoad(self);

	self.ItemDisplay:SetAuctionHouseFrame(self:GetAuctionHouseFrame());

	self.ItemDisplay:SetOnItemChangedCallback(function(item)
		if item == nil then
			local fromItemDisplay = true;
			self:SetItem(item, fromItemDisplay);
		else
			self:GetAuctionHouseFrame():SetPostItem(item);
		end
	end);

	self.ItemDisplay:SetItemValidationFunction(function(itemDisplay)
		local itemLocation = itemDisplay:GetItemLocation();
		return itemLocation == nil or C_AuctionHouse.IsSellItemValid(itemLocation);
	end);

	self.ItemDisplay.ItemButton.Highlight:ClearAllPoints();
	self.ItemDisplay.ItemButton.Highlight:SetPoint("TOPLEFT", self.ItemDisplay.ItemButton, "TOPLEFT");
	self.ItemDisplay.ItemButton.Highlight:SetPoint("BOTTOMRIGHT", self.ItemDisplay.ItemButton, "BOTTOMRIGHT");

	self.QuantityInput:SetInputChangedCallback(function()
		local maxQuantity = self:GetMaxQuantity();
		if self.QuantityInput:GetQuantity() > maxQuantity then
			self.QuantityInput:SetQuantity(maxQuantity);
		end

		self:UpdatePostState();
	end);

	self.PriceInput:SetOnValueChangedCallback(function()
		self:UpdatePostState();
	end);

	self:UpdateFocusTabbing();
end

function AuctionHouseSellFrameMixin:OnShow()
	FrameUtil.RegisterFrameForEvents(self, AUCTION_HOUSE_SELL_FRAME_EVENTS);
	self.fixedWidth = self:GetWidth();
	self.fixedHeight = self:GetHeight();
	self:Layout();
end

function AuctionHouseSellFrameMixin:OnHide()
	FrameUtil.UnregisterFrameForEvents(self, AUCTION_HOUSE_SELL_FRAME_EVENTS);
end

function AuctionHouseSellFrameMixin:OnEvent(event, ...)
	if event == "CURSOR_CHANGED" then
		if self.Overlay:IsMouseOver() then
			self:OnOverlayEnter();
		end
	elseif event == "AUCTION_HOUSE_THROTTLED_SYSTEM_READY" or event == "AUCTION_HOUSE_THROTTLED_MESSAGE_SENT" then
		self:UpdatePostButtonState();
	end
end

function AuctionHouseSellFrameMixin:SetSearchResultPrice(searchResultPrice)
	self.searchResultPrice = searchResultPrice;
end

function AuctionHouseSellFrameMixin:ClearSearchResultPrice()
	self.searchResultPrice = nil;
end

function AuctionHouseSellFrameMixin:GetSearchResultPrice()
	return self.searchResultPrice;
end

function AuctionHouseSellFrameMixin:UpdatePostState()
	self:UpdateDeposit();
	self:UpdateTotalPrice();
	self:UpdatePostButtonState();

	local quantity = self.QuantityInput:GetQuantity();
	self.QuantityInput.MaxButton:SetEnabled(quantity < self:GetMaxQuantity());

	local price = self.PriceInput:GetAmount();
	local searchResultPrice = self:GetSearchResultPrice();
	if searchResultPrice and price == (searchResultPrice - COPPER_PER_SILVER) then
		self:ShowHelpTip();
	else
		self:HideHelpTip();
	end
end

function AuctionHouseSellFrameMixin:UpdateFocusTabbing()
	self.QuantityInput:SetNextEditBox(self.PriceInput.MoneyInputFrame.GoldBox);
	self.PriceInput:SetNextEditBox(self.QuantityInput:IsShown() and self.QuantityInput.InputBox or nil);
end

function AuctionHouseSellFrameMixin:OnDurationUpdated()
	self:UpdatePostState();
end

function AuctionHouseSellFrameMixin:SetToMaxQuantity()
	self.QuantityInput:SetQuantity(self:GetMaxQuantity());
	self:UpdatePostState();
end

function AuctionHouseSellFrameMixin:GetMaxQuantity()
	local itemLocation = self.ItemDisplay:GetItemLocation();
	return itemLocation and C_AuctionHouse.GetAvailablePostCount(itemLocation) or 1;
end

function AuctionHouseSellFrameMixin:SetItem(itemLocation, fromItemDisplay)
	if itemLocation ~= nil then
		if not C_AuctionHouse.IsSellItemValid(itemLocation) then
			return false;
		end
	end

	local itemKey = itemLocation and C_AuctionHouse.GetItemKeyFromItem(itemLocation);
	local itemKeyInfo = itemKey and C_AuctionHouse.GetItemKeyInfo(itemKey);
	self.ItemDisplay:SetItemLevelShown(itemKeyInfo and itemKeyInfo.isEquipment);

	self.itemLocation = itemLocation;

	if not fromItemDisplay then
		local skipCallback = true;
		self.ItemDisplay:SetItemLocation(itemLocation, skipCallback);
	end

	self.QuantityInput:Reset();
	self.PriceInput:SetAmount(self:GetDefaultPrice());
	self:UpdatePostState();

	local showQuantity = self:GetMaxQuantity() > 1;
	self.QuantityInput:SetShown(showQuantity);

	-- Hack fix for a spacing problem: Without this line, the edit box would be scrolled to
	-- the left and the text would not be visible. This seems to be a problem with setting
	-- the text on the edit box and showing it in the same frame.
	self.QuantityInput.InputBox:SetCursorPosition(0);

	self:MarkDirty();

	self:UpdateFocusTabbing();

	return true;
end

function AuctionHouseSellFrameMixin:GetItem()
	return self.itemLocation;
end

function AuctionHouseSellFrameMixin:GetDefaultPrice()
	if (not C_AuctionHouse.ShouldAutoPopulatePrice() ) then
		return 0;
	end

	local itemLocation = self:GetItem();
	if itemLocation and itemLocation:IsValid() then
		local itemLink = C_Item.GetItemLink(itemLocation);
		local defaultPrice = COPPER_PER_SILVER;
		if LinkUtil.IsLinkType(itemLink, "item") then
			local vendorPrice = select(11, C_Item.GetItemInfo(itemLink));
			defaultPrice = vendorPrice ~= nil and (vendorPrice * Constants.AuctionConstants.DEFAULT_AUCTION_PRICE_MULTIPLIER) or COPPER_PER_SILVER;
			defaultPrice = defaultPrice + (COPPER_PER_SILVER - (defaultPrice % COPPER_PER_SILVER)); -- AH prices must be in silver increments.
		end
		return math.max(defaultPrice, COPPER_PER_SILVER);
	end

	return COPPER_PER_SILVER;
end

function AuctionHouseSellFrameMixin:GetDuration()
	return self.Duration:GetDuration();
end

function AuctionHouseSellFrameMixin:GetQuantity()
	return self.QuantityInput:GetQuantity();
end

function AuctionHouseSellFrameMixin:OnOverlayEnter()
	local item = C_Cursor.GetCursorItem();
	if item then
		self.ItemDisplay:SetHighlightLocked(true);
	end
end

function AuctionHouseSellFrameMixin:OnOverlayLeave()
	self.ItemDisplay:SetHighlightLocked(false);
end

function AuctionHouseSellFrameMixin:OnOverlayClick()
	local item = C_Cursor.GetCursorItem();
	if item then
		self.ItemDisplay:SwitchItemWithCursor();
	end
end

function AuctionHouseSellFrameMixin:OnOverlayReceiveDrag()
	self:OnOverlayClick();
end

function AuctionHouseSellFrameMixin:UpdatePostButtonState()
	local canPostItem, reasonTooltip = self:CanPostItem();
	self.PostButton:SetEnabled(canPostItem);
	self.PostButton:SetTooltip(reasonTooltip);
end

function AuctionHouseSellFrameMixin:CanPostItem()
	local item = self:GetItem();
	if item == nil or not item:IsValid() then
		return false, AUCTION_HOUSE_SELL_FRAME_ERROR_ITEM;
	end

	local hasEnoughMoneyForDeposit = GetMoney() >= self:GetDepositAmount();
	if not hasEnoughMoneyForDeposit then
		return false, AUCTION_HOUSE_SELL_FRAME_ERROR_DEPOSIT;
	end

	local quantity = self:GetQuantity();
	if quantity < 1 then
		return false, AUCTION_HOUSE_SELL_FRAME_ERROR_QUANTITY;
	end

	if not C_AuctionHouse.IsThrottledMessageSystemReady() then
		return false, ERR_GENERIC_THROTTLE;
	end

	return true, nil;
end

function AuctionHouseSellFrameMixin:UpdateDeposit()
	local depositCost = self:GetDepositAmount();

	if ( not C_AuctionHouse.SupportsCopperValues() ) then
		depositCost = math.ceil(depositCost / COPPER_PER_SILVER) * COPPER_PER_SILVER;
	end
	self.Deposit:SetAmount(depositCost);
end

function AuctionHouseSellFrameMixin:UpdateTotalPrice()
	self.TotalPrice:SetAmount(self:GetTotalPrice());
end

function AuctionHouseSellFrameMixin:ShowHelpTip()
	local helpTipInfo = {
		text = AUCTION_HOUSE_UNDERCUT_TUTORIAL,
		buttonStyle = HelpTip.ButtonStyle.GotIt,
		targetPoint = HelpTip.Point.RightEdgeCenter,
		alignment = HelpTip.Alignment.CENTER,
		offsetX = -6,
		offsetY = 2,
	};

	HelpTip:Show(self, helpTipInfo, self.PriceInput.MoneyInputFrame);
end

function AuctionHouseSellFrameMixin:HideHelpTip()
	HelpTip:Acknowledge(self, AUCTION_HOUSE_UNDERCUT_TUTORIAL);
end

function AuctionHouseSellFrameMixin:GetDepositAmount()
	-- Implement in your derived mixin.
end

function AuctionHouseSellFrameMixin:GetTotalPrice()
	-- Implement in your derived mixin.
end

function AuctionHouseSellFrameMixin:PostItem()
	-- Implement in your derived mixin.
end

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSellFrame.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSellFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	
	<Frame name="AuctionHouseSellFrameAlignedControlTemplate" mixin="AuctionHouseSellFrameAlignedControlMixin" virtual="true">
		<Size x="200" y="30"/>
		<!-- You can set the label text with a key value:
		<KeyValues>
			<KeyValue key="labelText" value="AUCTION_HOUSE_UNIT_PRICE_LABEL" type="global"/>
		</KeyValues>
		-->
		<Layers>
			<Layer level="ARTWORK">
				<FontString parentKey="Label" inherits="GameFontNormal" justifyH="RIGHT">
					<Size x="93" y="0"/>
					<Anchors>
						<Anchor point="LEFT"/>
					</Anchors>
					<Color color="NORMAL_FONT_COLOR"/>
					<Shadow x="1" y="-1">
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
				<FontString parentKey="LabelTitle" inherits="GameFontNormal" justifyH="RIGHT" hidden="true">
					<Size x="90" y="0"/>
					<Anchors>
						<Anchor point="LEFT" x="0" y="7"/>
					</Anchors>
					<Color color="NORMAL_FONT_COLOR"/>
					<Shadow x="1" y="-1">
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
				<FontString parentKey="Subtext" inherits="GameFontNormalSmall" justifyH="RIGHT" hidden="true">
					<Size x="90" y="0"/>
					<Anchors>
						<Anchor point="TOP" relativeKey="$parent.LabelTitle" relativePoint="BOTTOM" x="0" y="-1"/>
						<Anchor point="LEFT" x="0" y="-6"/>
					</Anchors>
					<Color color="DISABLED_FONT_COLOR"/>
					<Shadow x="1" y="-1">
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad method="OnLoad"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseAlignedQuantityInputFrameTemplate" mixin="AuctionHouseAlignedQuantityInputFrameMixin" inherits="AuctionHouseSellFrameAlignedControlTemplate" virtual="true">
		<Frames>
			<EditBox parentKey="InputBox" mixin="AuctionHouseAlignedQuantityInputBoxMixin" inherits="AuctionHouseQuantityInputEditBoxTemplate">
				<Size x="134" y="33"/>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.Label" relativePoint="RIGHT" x="18" y="-2"/>
				</Anchors>
				<Scripts>
					<OnEditFocusLost method="OnEditFocusLost"/>
				</Scripts>
			</EditBox>
			<Button parentKey="MaxButton" mixin="AuctionHouseQuantityInputMaxButtonMixin" inherits="UIPanelButtonTemplate" text="AUCTION_HOUSE_MAX_QUANTITY_BUTTON">
				<Size x="75" y="22"/>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.InputBox" relativePoint="RIGHT" x="6" y="2"/>
				</Anchors>
				<Scripts>
					<OnClick method="OnClick"/>
				</Scripts>
			</Button>
		</Frames>
	</Frame>

	<Frame name="AuctionHouseAlignedPriceInputFrameTemplate" mixin="AuctionHouseAlignedPriceInputFrameMixin" inherits="AuctionHouseSellFrameAlignedControlTemplate" virtual="true">
		<Frames>
			<Frame name ="MoneyInputFrame" parentKey="MoneyInputFrame" inherits="LargeMoneyInputFrameTemplate">
				<KeyValues>
					<KeyValue key="useAuctionHouseCopperValue" value="true" type="boolean"/>
				</KeyValues>
				<Size x="190" y="33"/>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.Label" relativePoint="RIGHT" x="18" y="-2"/>
				</Anchors>
			</Frame>
			<Frame parentKey="PriceError" mixin="AuctionHousePriceErrorFrameMixin" enableMouse="true" hidden="true">
				<Size x="20" y="20"/>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.MoneyInputFrame" relativePoint="RIGHT" x="10" y="0" />
				</Anchors>
				<Layers>
					<Layer level="ARTWORK">
						<Texture file="Interface\DialogFrame\UI-Dialog-Icon-AlertNew">
							<Size x="20" y="20"/>
							<Anchors>
								<Anchor point="CENTER" />
							</Anchors>
						</Texture>
					</Layer>
				</Layers>
				<Scripts>
					<OnEnter method="OnEnter"/>
					<OnLeave method="OnLeave"/>
				</Scripts>
			</Frame>
		</Frames>
		<Layers>
			<Layer level="ARTWORK">
				<FontString parentKey="PerItemPostfix" inherits="GameFontNormalSmall" justifyH="LEFT" text="AUCTION_HOUSE_PER_ITEM_LABEL" hidden="true">
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.MoneyInputFrame" relativePoint="RIGHT" x="4" y="4"/>
					</Anchors>
					<Color color="DISABLED_FONT_COLOR"/>
					<Shadow x="1" y="-1">
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad method="OnLoad"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseAlignedDurationTemplate" mixin="AuctionHouseAlignedDurationMixin" inherits="AuctionHouseSellFrameAlignedControlTemplate" virtual="true">
		<Frames>
			<DropdownButton parentKey="Dropdown" inherits="WowStyle1DropdownTemplate">
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.Label" relativePoint="RIGHT" x="19" y="-2"/>
				</Anchors>
			</DropdownButton>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseAlignedPriceDisplayTemplate" mixin="AuctionHouseAlignedPriceDisplayMixin" inherits="AuctionHouseSellFrameAlignedControlTemplate" virtual="true">
		<Frames>
			<Frame parentKey="MoneyDisplayFrame" inherits="MoneyDisplayFrameTemplate">
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.Label" relativePoint="RIGHT" x="18" y="0"/>
					<Anchor point="RIGHT"/>
				</Anchors>
				<KeyValues>
					<KeyValue key="useAuctionHouseCopperValue" value="true" type="boolean"/>
					<KeyValue key="leftAlign" value="true" type="boolean"/>
					<KeyValue key="useAuctionHouseIcons" value="true" type="boolean"/>
				</KeyValues>
			</Frame>
		</Frames>
	</Frame>

	<Button name="AuctionHouseSellFrameOverlayTemplate" enableMouse="true" mixin="AuctionHouseSellFrameOverlayMixin" virtual="true">
		<Scripts>
			<OnEnter method="OnEnter"/>
			<OnLeave method="OnLeave"/>
			<OnClick method="OnClick"/>
			<OnReceiveDrag method="OnReceiveDrag"/>
		</Scripts>
	</Button>

	<Frame name="AuctionHouseSellFrameTemplate" inherits="VerticalLayoutFrame, AuctionHouseBackgroundTemplate" mixin="AuctionHouseSellFrameMixin" virtual="true">
		<KeyValues>
			<KeyValue key="topPadding" value="12" type="number"/>
			<KeyValue key="bottomPadding" value="120" type="number"/>
			<KeyValue key="leftPadding" value="11" type="number"/>
			<KeyValue key="rightPadding" value="10" type="number"/>
			
			<KeyValue key="spacing" value="15" type="number"/>
			<KeyValue key="backgroundAtlas" value="auctionhouse-background-sell-left" type="string"/>
			<KeyValue key="backgroundTextureClassic" value="Interface\QuestFrame\UI-TextBackground-BackdropBackground" type="string"/>
			<KeyValue key="textureWidthClassic" value="357" type="number"/>
			<KeyValue key="textureHeightClassic" value="438" type="number"/>
			<KeyValue key="textureXOffsetClassic" value="3" type="number"/>
			<KeyValue key="textureYOffsetClassic" value="-2" type="number"/>
		</KeyValues>
		<Layers>
			<Layer level="ARTWORK">
				<Texture parentKey="CreateAuctionTabLeft" atlas="auctionhouse-selltab-left" useAtlasSize="true">
					<Anchors>
						<Anchor point="BOTTOMLEFT" relativeKey="$parent" relativePoint="TOPLEFT" x="42" y="-3"/>
					</Anchors>
				</Texture>
				<FontString parentKey="CreateAuctionLabel" inherits="GameFontNormalSmall" justifyH="LEFT" text="CREATE_AUCTION">
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.CreateAuctionTabLeft" relativePoint="RIGHT" x="12"/>
					</Anchors>
				</FontString>
			</Layer>
			<Layer level="BORDER">
				<Texture parentKey="CreateAuctionTabMiddle" atlas="auctionhouse-selltab-middle">
					<Size y="23"/>
					<Anchors>
						<Anchor point="TOPLEFT" relativeKey="$parent.CreateAuctionTabLeft" relativePoint="TOPRIGHT" x="0" y="0"/>
						<Anchor point="RIGHT" relativeKey="$parent.CreateAuctionLabel" relativePoint="RIGHT" x="12" y="0"/>
					</Anchors>
				</Texture>

				<Texture parentKey="CreateAuctionTabRight" atlas="auctionhouse-selltab-right" useAtlasSize="true">
					<Anchors>
						<Anchor point="TOPLEFT" relativeKey="$parent.CreateAuctionTabMiddle" relativePoint="TOPRIGHT"/>
						<Anchor point="BOTTOMLEFT" relativeKey="$parent.CreateAuctionTabMiddle" relativePoint="BOTTOMRIGHT"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
		<Frames>
			<Button parentKey="Overlay" inherits="AuctionHouseSellFrameOverlayTemplate" setAllPoints="true"/>
			<Button parentKey="ItemDisplay" inherits="AuctionHouseInteractableItemDisplayTemplate" mixin="AuctionHouseSellFrameItemDisplayMixin" frameLevel="350">
				<Size x="342" y="72"/>
				<KeyValues>
					<KeyValue key="layoutIndex" value="10" type="number"/>
					<KeyValue key="bottomPadding" value="8" type="number"/>
				</KeyValues>
				<Layers>
					<Layer level="ARTWORK">
						<Texture atlas="auctionhouse-itemheaderframe" useAtlasSize="true">
							<Anchors>
								<Anchor point="CENTER"/>
							</Anchors>
						</Texture>
					</Layer>
				</Layers>
				<Scripts>
					<OnLoad method="OnLoad"/>
				</Scripts>
			</Button>
			<Frame parentKey="QuantityInput" inherits="AuctionHouseAlignedQuantityInputFrameTemplate">
				<KeyValues>
					<KeyValue key="layoutIndex" value="20" type="number"/>
					<KeyValue key="labelText" value="AUCTION_HOUSE_QUANTITY_LABEL" type="global"/>
				</KeyValues>
			</Frame>
			<Frame parentKey="PriceInput" inherits="AuctionHouseAlignedPriceInputFrameTemplate">
				<KeyValues>
					<KeyValue key="layoutIndex" value="30" type="number"/>
					<KeyValue key="labelText" value="AUCTION_HOUSE_UNIT_PRICE_LABEL" type="global"/>
				</KeyValues>
			</Frame>
			<Frame parentKey="Duration" inherits="AuctionHouseAlignedDurationTemplate">
				<KeyValues>
					<KeyValue key="layoutIndex" value="40" type="number"/>
					<KeyValue key="labelText" value="AUCTION_HOUSE_DURATION_LABEL" type="global"/>
				</KeyValues>
			</Frame>
			<Frame parentKey="Deposit" inherits="AuctionHouseAlignedPriceDisplayTemplate">
				<KeyValues>
					<KeyValue key="layoutIndex" value="50" type="number"/>
					<KeyValue key="labelText" value="AUCTION_HOUSE_DEPOSIT_LABEL" type="global"/>
				</KeyValues>
			</Frame>
			<Frame parentKey="TotalPrice" inherits="AuctionHouseAlignedPriceDisplayTemplate">
				<KeyValues>
					<KeyValue key="layoutIndex" value="60" type="number"/>
					<KeyValue key="labelText" value="AUCTION_HOUSE_TOTAL_PRICE_LABEL" type="global"/>
				</KeyValues>
			</Frame>
			<Button parentKey="PostButton" motionScriptsWhileDisabled="true" mixin="AuctionHouseSellFramePostButtonMixin" inherits="UIPanelButtonTemplate" text="AUCTION_HOUSE_POST_BUTTON" frameLevel="350">
				<KeyValues>
					<KeyValue key="layoutIndex" value="70" type="number"/>
					<KeyValue key="leftPadding" value="74" type="number"/>
				</KeyValues>
				<Size x="194" y="22"/>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent" relativePoint="RIGHT" x="12" y="0"/>
				</Anchors>
				<Scripts>
					<OnClick method="OnClick"/>
					<OnEnter method="OnEnter"/>
					<OnLeave method="OnLeave"/>
				</Scripts>
			</Button>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSellFrame.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSharedTemplates.lua ---

function AuctionHouseFavoriteContextMenu(frame, itemKey)
	MenuUtil.CreateContextMenu(frame, function(owner, rootDescription)
		rootDescription:SetTag("MENU_AUCTION_HOUSE_FAVORITE");

		local isFavorite = C_AuctionHouse.IsFavoriteItem(itemKey);
	
		local function CanChangeFavoriteState()
			return C_AuctionHouse.FavoritesAreAvailable() and (isFavorite or not C_AuctionHouse.HasMaxFavorites());
		end
	
		local text = isFavorite and AUCTION_HOUSE_DROPDOWN_REMOVE_FAVORITE or AUCTION_HOUSE_DROPDOWN_SET_FAVORITE;
		local buttonDesc = rootDescription:CreateButton(text, function()
			if CanChangeFavoriteState() then
				C_AuctionHouse.SetFavoriteItem(itemKey, not isFavorite);
			end
		end);
	
		buttonDesc:SetEnabled(CanChangeFavoriteState);
	end);
end


AuctionHouseBackgroundMixin = {};

function AuctionHouseBackgroundMixin:OnLoad()
	local xOffset = self.backgroundXOffset or 0;
	local yOffset = self.backgroundYOffset or 0;
	self.Background:SetAtlas(self.backgroundAtlas, true);
	self.Background:SetPoint("TOPLEFT", xOffset + 3, yOffset - 3);

	self.NineSlice:ClearAllPoints();
	self.NineSlice:SetPoint("TOPLEFT", xOffset, yOffset);
	self.NineSlice:SetPoint("BOTTOMRIGHT");
end


AuctionHouseItemDisplayMixin = {};

function AuctionHouseItemDisplayMixin:OnLoad()
	AuctionHouseBackgroundMixin.OnLoad(self);

	self.ItemButton:SetPoint("LEFT", self.itemButtonXOffset or 0, self.itemButtonYOffset or 0);
end

function AuctionHouseItemDisplayMixin:SetItemCountFunction(getItemCount)
	self.getItemCount = getItemCount;
end

function AuctionHouseItemDisplayMixin:SetItemValidationFunction(validationFunc)
	self.itemValidationFunc = validationFunc;
end

function AuctionHouseItemDisplayMixin:OnEvent(event, ...)
	if event == "GET_ITEM_INFO_RECEIVED" then
		if self.pendingInfo.itemKey then
			self:SetItemKey(self.pendingInfo.itemKey);
		elseif self.pendingInfo.itemLocation then
			self:SetItemLocation(self.pendingInfo.itemLocation);
		else
			self:SetItemInternal(self.pendingInfo.item);
		end
	elseif event == "ITEM_KEY_ITEM_INFO_RECEIVED" then
		local itemID = ...;
		if self.pendingItemKey and self.pendingItemKey.itemID == itemID then
			self:SetItemKey(self.pendingItemKey);
		end
	end
end

-- Set and cleared dynamically in OnEnter and OnLeave
function AuctionHouseItemDisplayMixin:OnUpdate()
	if IsModifiedClick("DRESSUP") then
		ShowInspectCursor();
	else
		ResetCursor();
	end
end

function AuctionHouseItemDisplayMixin:OnEnter()
	self:SetScript("OnUpdate", AuctionHouseItemDisplayMixin.OnUpdate);

	if IsModifiedClick("DRESSUP") then
		ShowInspectCursor();
	end

	if self:IsPet() then
		if self.itemKey then
			local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(self.itemKey);
			if itemKeyInfo and itemKeyInfo.battlePetLink then
				GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
				BattlePetToolTip_ShowLink(itemKeyInfo.battlePetLink);
				AuctionHouseUtil.AppendBattlePetVariationLines(BattlePetTooltip);
			else
				BattlePetTooltip:Hide();
				GameTooltip:Hide();
			end
		else
			local itemLocation = self:GetItemLocation();
			if itemLocation then
				local bagID, slotIndex = itemLocation:GetBagAndSlot();
				if bagID and slotIndex then
					GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
					GameTooltip:SetBagItem(bagID, slotIndex);
				end
			end
		end
	else
		BattlePetTooltip:Hide();

		local itemLocation = self:GetItemLocation();
		if itemLocation then
			GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
			GameTooltip:SetHyperlink(C_Item.GetItemLink(itemLocation));
			GameTooltip:Show();
		else
			local itemKey = self:GetItemKey();
			if itemKey then
				GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
				GameTooltip:SetItemKey(itemKey.itemID, itemKey.itemLevel, itemKey.itemSuffix, C_AuctionHouse.GetItemKeyRequiredLevel(itemKey));
				GameTooltip:Show();
			else
				local itemLink = self:GetItemLink();
				if itemLink then
					GameTooltip:SetOwner(self.ItemButton, "ANCHOR_RIGHT");
					GameTooltip:SetHyperlink(itemLink);
					GameTooltip:Show();
				end
			end
		end

		self.ItemButton.UpdateTooltip = self.ItemButton:GetScript("OnEnter");
	end
end

function AuctionHouseItemDisplayMixin:OnLeave()
	self:SetScript("OnUpdate", nil);

	ResetCursor();
	GameTooltip:Hide();

	if(BattlePetTooltip) then
		BattlePetTooltip:Hide();
	end
end

function AuctionHouseItemDisplayMixin:OnClick(button)
	local itemKey = self:GetItemKey();
	if itemKey then
		if button == "RightButton" then
			AuctionHouseFavoriteContextMenu(self, itemKey);
		elseif button == "LeftButton" then
			if IsModifiedClick("DRESSUP") then
				local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(itemKey);
				if itemKeyInfo and itemKeyInfo.battlePetLink then
					DressUpBattlePetLink(itemKeyInfo.battlePetLink);
				else
					if itemKeyInfo.appearanceLink then
						local _, _, hyperlinkString = ExtractHyperlinkString(itemKeyInfo.appearanceLink);
						DressUpTransmogLink(hyperlinkString);
					else
						DressUpLink(self:GetItemLink());
					end
				end
			elseif IsModifiedClick("CHATLINK") then
				local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(itemKey);
				if itemKeyInfo and itemKeyInfo.battlePetLink then
					ChatEdit_InsertLink(itemKeyInfo.battlePetLink);
				else
					ChatEdit_InsertLink(self:GetItemLink());
				end
			end
		end
	end
end

function AuctionHouseItemDisplayMixin:Reset()
	SetItemButtonCount(self.ItemButton, nil);
	SetItemButtonTexture(self.ItemButton, nil);
	SetItemButtonQuality(self.ItemButton, nil, nil);
	self.Name:SetText("");

	self.itemKey = nil;
	self.itemLocation = nil;
	self.itemLink = nil;
end

function AuctionHouseItemDisplayMixin:SetAuctionHouseFrame(auctionHouseFrame)
	self.auctionHouseFrame = auctionHouseFrame;
end

function AuctionHouseItemDisplayMixin:SetItemLevelShown(shown)
	self.itemLevelShown = shown;
end

function AuctionHouseItemDisplayMixin:SetItemSource(itemKey, itemLocation)
	self.itemKey = itemKey;
	self.itemLocation = itemLocation;
end

function AuctionHouseItemDisplayMixin:GetItemSource()
	return self.itemKey, self.itemLocation;
end

function AuctionHouseItemDisplayMixin:SetItemKey(itemKey)
	if itemKey == nil then
		self:SetItemInternal(nil);
		return true;
	end

	local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(itemKey);
	if not itemKeyInfo then
		self.pendingItemKey = itemKey;
		self:RegisterEvent("ITEM_KEY_ITEM_INFO_RECEIVED");
		return false;
	end

	if self.pendingItemKey ~= nil then
		self:UnregisterEvent("ITEM_KEY_ITEM_INFO_RECEIVED");
	end

	self.pendingItemKey = nil;

	self:SetItemSource(itemKey, nil);

	local successful = self:SetItemInternal(itemKey.itemID);
	if successful then
		self.Name:SetText(AuctionHouseUtil.GetItemDisplayTextFromItemKey(itemKey, itemKeyInfo));
		SetItemButtonTexture(self.ItemButton, itemKeyInfo.iconFileID);
		SetItemButtonQuality(self.ItemButton, itemKeyInfo.quality);
		
		self.FavoriteButton:SetItemKey(itemKey);
	end

	return successful;
end

function AuctionHouseItemDisplayMixin:SetItemLocation(itemLocation)
	local originalItemKey, originalItemLocation = self:GetItemSource();
	self:SetItemSource(nil, itemLocation);

	if itemLocation == nil or not C_Item.DoesItemExist(itemLocation) then
		self:SetItemInternal(nil);

		local successful = (itemLocation == nil);
		if successful then
			return true;
		end

		self:SetItemSource(originalItemKey, originalItemLocation);
		return false;
	end

	if self:SetItemInternal(C_Item.GetItemLink(itemLocation)) then
		return true;
	end

	self:SetItemSource(originalItemKey, originalItemLocation);
	return false;
end

-- item must be an itemID, item link or an item name.
function AuctionHouseItemDisplayMixin:SetItem(item)
	self:SetItemSource(nil, nil);
	return self:SetItemInternal(item);
end

function AuctionHouseItemDisplayMixin:SetItemInternal(item)
	if self.itemValidationFunc and not self.itemValidationFunc(self) then
		return false;
	end

	self.item = item;

	if not item then
		self:Reset();
		return true;
	end

	local itemName, itemLink, itemQuality, itemLevel, itemIcon = self:GetItemInfo();

	self.itemLink = itemLink;
	if self.itemLink == nil then
		self.pendingInfo = {item = self.item, itemKey = self.itemKey, itemLocation = self.itemLocation};
		self:RegisterEvent("GET_ITEM_INFO_RECEIVED");
		self:Reset();
		return true;
	end

	self.pendingItem = nil;
	self:UnregisterEvent("GET_ITEM_INFO_RECEIVED");

	local isPet = self:IsPet();

	local itemCount = self.getItemCount and self.getItemCount(self) or nil;
	SetItemButtonCount(self.ItemButton, itemCount);
	SetItemButtonTexture(self.ItemButton, itemIcon);

	local itemLinkForQuality = not isPet and itemLink or nil;
	SetItemButtonQuality(self.ItemButton, itemQuality, itemLinkForQuality);

	local displayText = self:GetItemDisplayText(itemName, itemLevel, isPet);

	local nameText = displayText;
	local colorData = ColorManager.GetColorDataForItemQuality(itemQuality);
	if colorData then
		nameText = colorData.color:WrapTextInColorCode(displayText);
	end

	self.Name:SetText(nameText);

	self.ItemButton:UnlockHighlight();

	return true;
end

function AuctionHouseItemDisplayMixin:IsPet()
	if self.itemKey then
		local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(self.itemKey);
		return itemKeyInfo and itemKeyInfo.isPet;
	end

	local itemLink = self:GetItemLink();
	if itemLink == nil then
		return false;
	end

	return LinkUtil.IsLinkType(itemLink, "battlepet");
end

function AuctionHouseItemDisplayMixin:GetItemDisplayText(itemName, itemLevel, isPet)
	if isPet then
		return itemName;
	end

	if (C_TradeSkillUI.GetItemReagentQualityByItemInfo) then
		local craftingQuality = C_TradeSkillUI.GetItemReagentQualityByItemInfo(self.item);
	else
		local craftingQuality = nil;
	end
	
	return AuctionHouseUtil.GetItemDisplayText(itemName, self.itemLevelShown and itemLevel or nil, craftingQuality);
end

function AuctionHouseItemDisplayMixin:GetItemInfo()
	local itemLocation = self:GetItemLocation();
	if itemLocation then
		local itemName = C_Item.GetItemName(itemLocation);
		local itemLink = C_Item.GetItemLink(itemLocation);
		local itemQuality = C_Item.GetItemQuality(itemLocation);
		local itemLevel = C_Item.GetCurrentItemLevel(itemLocation);
		local itemIcon = C_Item.GetItemIcon(itemLocation);
		return itemName, itemLink, itemQuality, itemLevel, itemIcon;
	else
		local itemName, itemLink, itemQuality, itemLevel, itemMinLevel, itemType, itemSubType, itemStackCount, itemEquipLoc, itemIcon = C_Item.GetItemInfo(self:GetItem());
		return itemName, itemLink, itemQuality, itemLevel, itemIcon;
	end
end

function AuctionHouseItemDisplayMixin:GetItemID()
	local itemLink = self:GetItemLink();
	if not itemLink then
		return nil;
	end

	-- Storing in a local for clarity, and to avoid additional returns.
	local itemID = C_Item.GetItemInfoInstant(itemLink);
	return itemID;
end

function AuctionHouseItemDisplayMixin:GetItem()
	return self.item;
end

function AuctionHouseItemDisplayMixin:GetItemLink()
	return self.itemLink;
end

function AuctionHouseItemDisplayMixin:GetItemKey()
	if self.itemKey then
		return self.itemKey;
	elseif self.itemLocation then
		return C_AuctionHouse.GetItemKeyFromItem(self.itemLocation);
	else
		local itemID = self:GetItemID();
		if itemID then
			return C_AuctionHouse.MakeItemKey(itemID);
		end
	end

	return nil;
end

function AuctionHouseItemDisplayMixin:GetItemLocation()
	return self.itemLocation;
end

function AuctionHouseItemDisplayMixin:GetItemCount()
	return GetItemButtonCount(self.ItemButton);
end

function AuctionHouseItemDisplayMixin:SetHighlightLocked(locked)
	if locked then
		self.ItemButton:LockHighlight();
	else
		self.ItemButton:UnlockHighlight();
	end
end


AuctionHouseItemDisplayItemButtonMixin = {};

function AuctionHouseItemDisplayItemButtonMixin:OnLoad()
	self:ClearHighlightTexture();
end

function AuctionHouseItemDisplayItemButtonMixin:OnClick(...)
	self:GetParent():OnClick(...);
end

function AuctionHouseItemDisplayItemButtonMixin:OnEnter()
	self:GetParent():OnEnter();
end

function AuctionHouseItemDisplayItemButtonMixin:OnLeave()
	self:GetParent():OnLeave();
end


AuctionHouseInteractableItemDisplayItemButtonMixin = CreateFromMixins(AuctionHouseItemDisplayItemButtonMixin);

function AuctionHouseInteractableItemDisplayItemButtonMixin:OnLoad()
	-- Intentional override.
end

function AuctionHouseInteractableItemDisplayItemButtonMixin:OnEnter()
	self:GetParent():OnEnter();
end

function AuctionHouseInteractableItemDisplayItemButtonMixin:OnLeave()
	self:GetParent():OnLeave();
end

function AuctionHouseInteractableItemDisplayItemButtonMixin:Init()
	self:RegisterForDrag("LeftButton");
end

function AuctionHouseInteractableItemDisplayItemButtonMixin:GetItemLocation()
	local itemDisplay = self:GetParent();
	return itemDisplay:GetItemLocation();
end

function AuctionHouseInteractableItemDisplayItemButtonMixin:SetItemLocation(itemLocation)
	local itemDisplay = self:GetParent();
	return itemDisplay:SetItemLocation(itemLocation);
end

function AuctionHouseInteractableItemDisplayItemButtonMixin:SwitchItemWithCursor()
	local itemDisplay = self:GetParent();
	itemDisplay:SwitchItemWithCursor();
end

function AuctionHouseInteractableItemDisplayItemButtonMixin:OnClick(button, ...)
	if button == "RightButton" then
		self:SetItemLocation(nil);
	else
		self:GetParent():OnClick(button, ...);
	end
end

function AuctionHouseInteractableItemDisplayItemButtonMixin:OnDragStart()
	local currentItemLocation = self:GetItemLocation();
	self:SetItemLocation(nil);
	if currentItemLocation ~= nil then
		ItemUtil.PickupBagItem(currentItemLocation);
	end
end

function AuctionHouseInteractableItemDisplayItemButtonMixin:OnReceiveDrag()
	self:SwitchItemWithCursor();
end


AuctionHouseInteractableItemDisplayMixin = CreateFromMixins(AuctionHouseItemDisplayMixin);

local InteractableItemButtonScripts = {
	"OnClick",
	"OnDragStart",
	"OnReceiveDrag",
};

function AuctionHouseInteractableItemDisplayMixin:OnLoad()
	AuctionHouseItemDisplayMixin.OnLoad(self);

	self.ItemButton:Init();
	for i, scriptName in ipairs(InteractableItemButtonScripts) do
		self.ItemButton:SetScript(scriptName, self.ItemButton[scriptName]);
	end
end

function AuctionHouseInteractableItemDisplayMixin:OnEnter()
	AuctionHouseItemDisplayMixin.OnEnter(self);

	local item = C_Cursor.GetCursorItem();
	if item then
		self:SetHighlightLocked(true);
	end
end

function AuctionHouseInteractableItemDisplayMixin:OnLeave()
	AuctionHouseItemDisplayMixin.OnLeave(self);

	self:SetHighlightLocked(false);
end

function AuctionHouseInteractableItemDisplayMixin:OnClick(button, ...)
	AuctionHouseItemDisplayMixin.OnClick(self, button, ...);

	if button == "LeftButton" and not IsModifiedClick("DRESSUP") then
		self:SwitchItemWithCursor();
		if self:GetItemLocation() or self:GetItemLink() then
			self:OnEnter();
		else
			self:OnLeave();
		end
	end
end

function AuctionHouseInteractableItemDisplayMixin:OnReceiveDrag()
	self:OnClick("LeftButton");

	if self:GetItemLocation() or self:GetItemLink() then
		self:OnEnter();
	end
end

function AuctionHouseInteractableItemDisplayMixin:SetOnItemChangedCallback(callback)
	self.onItemChangedCallback = callback;
end

function AuctionHouseInteractableItemDisplayMixin:SetItemLocation(itemLocation, skipCallback)
	local currentItemLocation = self:GetItemLocation();

	local successful = AuctionHouseItemDisplayMixin.SetItemLocation(self, itemLocation);
	if not successful then
		return false;
	end

	if currentItemLocation and C_Item.DoesItemExist(currentItemLocation) then
		C_Item.UnlockItem(currentItemLocation);
	end

	if itemLocation then
		if C_Item.DoesItemExist(itemLocation) then
			C_Item.LockItem(itemLocation);
		end
	end

	if not skipCallback and self.onItemChangedCallback then
		self.onItemChangedCallback(itemLocation);
	end

	return true;
end

function AuctionHouseInteractableItemDisplayMixin:SwitchItemWithCursor(skipCallback)
	local cursorItem = C_Cursor.GetCursorItem();
	local currentItemLocation = self:GetItemLocation();
	if (cursorItem or currentItemLocation) and (self:SetItemLocation(cursorItem, skipCallback) or cursorItem == nil) then
		ClearCursor();

		ItemUtil.PickupBagItem(currentItemLocation or cursorItem);
	end
end

function AuctionHouseInteractableItemDisplayMixin:GetItemDisplayText(itemName, itemLevel, isPet)
	if isPet then
		return AuctionHouseItemDisplayMixin.GetItemDisplayText(self, itemName, itemLevel, isPet);
	end

	-- Never display crafting quality in the item text since it will display as an overlay on top of the icon.
	local craftingQuality = nil;
	return AuctionHouseUtil.GetItemDisplayText(itemName, self.itemLevelShown and itemLevel or nil, craftingQuality);
end


AuctionHouseQuantityInputBoxMixin = {};

function AuctionHouseQuantityInputBoxMixin:OnLoad()
	self:SetFontObject("PriceFont");
end

function AuctionHouseQuantityInputBoxMixin:SetInputChangedCallback(callback)
	self.inputChangedCallback = callback;
end

function AuctionHouseQuantityInputBoxMixin:GetInputChangedCallback()
	return self.inputChangedCallback;
end

function AuctionHouseQuantityInputBoxMixin:OnTextChanged(userInput)
	if self:GetNumber() == 0 then
		self:SetText("");
	end

	if userInput and self.inputChangedCallback then
		self.inputChangedCallback();
	end
end

function AuctionHouseQuantityInputBoxMixin:Reset()
	self:SetNumber(1);
end


AuctionHousePriceDisplayFrameMixin = {};

function AuctionHousePriceDisplayFrameMixin:OnLoad()
	self.Label:SetText(self.labelText or "");
end

function AuctionHousePriceDisplayFrameMixin:SetAmount(amount)
	self.MoneyDisplayFrame:SetAmount(amount);
end

function AuctionHousePriceDisplayFrameMixin:GetAmount()
	return self.MoneyDisplayFrame:GetAmount();
end


AuctionHouseRefreshFrameMixin = {};

function AuctionHouseRefreshFrameMixin:SetQuantity(totalQuantity)
	self.RefreshButton:SetEnabledState(true);

	local hasResults = totalQuantity ~= 0;
	self.TotalQuantity:SetText(hasResults and AUCTION_HOUSE_QUANTITY_AVAILABLE_FORMAT:format(totalQuantity) or "");
end

function AuctionHouseRefreshFrameMixin:Deactivate()
	self.RefreshButton:SetEnabledState(false);
	self.TotalQuantity:SetText("");
end

function AuctionHouseRefreshFrameMixin:SetRefreshCallback(refreshCallback)
	self.RefreshButton:SetOnClickHandler(refreshCallback);
end


AuctionHouseRefreshButtonMixin = {};

function AuctionHouseRefreshButtonMixin:OnLoad()
	SquareIconButtonMixin.OnLoad(self);

	self:SetTooltipInfo(AUCTION_HOUSE_REFRESH_BUTTON_TOOLTIP);
end


AuctionHouseBidFrameMixin = {};

function AuctionHouseBidFrameMixin:SetBidCallback(bidCallback)
	self.bidCallback = bidCallback;
end

function AuctionHouseBidFrameMixin:OnLoad()
	local displayCopper = C_AuctionHouse.SupportsCopperValues();
	MoneyInputFrame_SetCopperShown(self.BidAmount, displayCopper);
end

function AuctionHouseBidFrameMixin:SetPrice(minBid, isOwnerItem, isPlayerHighBid)
	MoneyInputFrame_SetCopper(self.BidAmount, minBid);

	if isPlayerHighBid or minBid == 0 then
		MoneyInputFrame_SetEnabled(self.BidAmount, false);
		self.BidButton:SetDisableTooltip("");
	elseif minBid > GetMoney() then
		MoneyInputFrame_SetEnabled(self.BidAmount, false);
		self.BidButton:SetDisableTooltip(AUCTION_HOUSE_TOOLTIP_TITLE_NOT_ENOUGH_MONEY);
	elseif isOwnerItem then
		MoneyInputFrame_SetEnabled(self.BidAmount, false);
		self.BidButton:SetDisableTooltip(AUCTION_HOUSE_TOOLTIP_TITLE_OWN_AUCTION);
	else
		MoneyInputFrame_SetEnabled(self.BidAmount, true);
		self.BidButton:SetDisableTooltip(nil);
	end
end

function AuctionHouseBidFrameMixin:GetPrice()
	return MoneyInputFrame_GetCopper(self.BidAmount);
end

function AuctionHouseBidFrameMixin:PlaceBid()
	if self.bidCallback then
		self.bidCallback();
	end
end


AuctionHouseBuyoutFrameMixin = {};

function AuctionHouseBuyoutFrameMixin:SetBuyoutCallback(buyoutCallback)
	self.buyoutCallback = buyoutCallback;
end

function AuctionHouseBuyoutFrameMixin:SetPrice(price, isOwnerItem)
	self.price = price;

	if isOwnerItem then
		self.BuyoutButton:SetDisableTooltip(AUCTION_HOUSE_TOOLTIP_TITLE_OWN_AUCTION);
	elseif price > GetMoney() then
		self.BuyoutButton:SetDisableTooltip(AUCTION_HOUSE_TOOLTIP_TITLE_NOT_ENOUGH_MONEY);
	elseif price <= 0 then
		self.BuyoutButton:SetDisableTooltip("");
	else
		self.BuyoutButton:SetDisableTooltip(nil);
	end
end

function AuctionHouseBuyoutFrameMixin:GetPrice()
	return self.price;
end

function AuctionHouseBuyoutFrameMixin:BuyoutItem()
	if self.buyoutCallback then
		self.buyoutCallback();
	end
end


AuctionHouseBidButtonMixin = {};

function AuctionHouseBidButtonMixin:OnClick()
	self:GetParent():PlaceBid();
end


AuctionHouseBuyoutButtonMixin = {};

function AuctionHouseBuyoutButtonMixin:OnClick()
	self:GetParent():BuyoutItem();
end

AuctionHouseFavoriteButtonBaseMixin = {};

function AuctionHouseFavoriteButtonBaseMixin:OnEnter()
	if not self:IsInteractionAvailable() then
		self:ShowMaxedFavoritesTooltip();
	end
end

function AuctionHouseFavoriteButtonBaseMixin:ShowMaxedFavoritesTooltip()
	GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
	GameTooltip_AddErrorLine(GameTooltip, AUCTION_HOUSE_FAVORITES_MAXED_TOOLTIP);
	GameTooltip:Show();
end

function AuctionHouseFavoriteButtonBaseMixin:OnLeave()
	GameTooltip_Hide();
end

function AuctionHouseFavoriteButtonBaseMixin:OnClick()
	if not self:IsInteractionAvailable() then
		return;
	end
	
	local setToFavorite = not self:IsFavorite();
	C_AuctionHouse.SetFavoriteItem(self.itemKey, setToFavorite);
	self:UpdateFavoriteState();
end

function AuctionHouseFavoriteButtonBaseMixin:IsInteractionAvailable()
	return C_AuctionHouse.FavoritesAreAvailable() and (self:IsFavorite() or not C_AuctionHouse.HasMaxFavorites());
end

function AuctionHouseFavoriteButtonBaseMixin:SetItemKey(itemKey)
	self.itemKey = itemKey;
	self:UpdateFavoriteState();
end

function AuctionHouseFavoriteButtonBaseMixin:UpdateFavoriteState()
	local isFavorite = self:IsFavorite();
	local currAtlas = isFavorite and "auctionhouse-icon-favorite" or "auctionhouse-icon-favorite-off";
	self.NormalTexture:SetAtlas(currAtlas);

	self.HighlightTexture:SetAtlas(currAtlas);
	self.HighlightTexture:SetAlpha(isFavorite and 0.2 or 0.4);
end

function AuctionHouseFavoriteButtonBaseMixin:IsFavorite()
	return self.itemKey and C_AuctionHouse.IsFavoriteItem(self.itemKey);
end

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSharedTemplates.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSharedTemplates.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	<Frame name="AuctionHouseBackgroundTemplate" mixin="AuctionHouseBackgroundMixin" virtual="true">
		<KeyValues>
			<KeyValue key="layoutType" value="InsetFrameTemplate" type="string"/>

			<!--
			backgroundAtlas: atlas to be set in OnLoad.
			backgroundXOffset: X offset for the background image and nine slice.
			backgroundYOffset: Y offset for the background image and nine slice.

			<KeyValue key="backgroundAtlas" value="auctionhouse-background-sell-left" type="string"/>
			<KeyValue key="backgroundXOffset" value="0" type="string"/>
			<KeyValue key="backgroundYOffset" value="0" type="string"/>
			-->
		</KeyValues>
		<Layers>
			<Layer>
				<Texture parentKey="Background">
					<Anchors>
						<Anchor point="TOPLEFT" x="3" y="-3"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
		<Frames>
			<Frame parentKey="NineSlice" useParentLevel="true" inherits="NineSlicePanelTemplate"/>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
		</Scripts>
	</Frame>

	<Button name="AuctionHouseItemDisplayBaseTemplate" mixin="AuctionHouseItemDisplayMixin" inherits="AuctionHouseBackgroundTemplate" useParentLevel="false" registerForClicks="RightButtonUp, LeftButtonUp" virtual="true">
		<KeyValues>
			<!--
			itemButtonXOffset: X Offset for the item button relative to the background's left.
			itemButtonYOffset: Y Offset for the item button relative to the background's left.
			-->
			<KeyValue key="itemButtonXOffset" value="8" type="number"/>
			<KeyValue key="itemButtonYOffset" value="0" type="number"/>
		</KeyValues>
		<Size x="340" y="70"/>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnEvent method="OnEvent"/>
			<OnEnter method="OnEnter"/>
			<OnLeave method="OnLeave"/>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>

	<Button name="AuctionHouseInteractableItemDisplayTemplate" mixin="AuctionHouseInteractableItemDisplayMixin" inherits="AuctionHouseItemDisplayBaseTemplate" registerForClicks="LeftButtonUp, RightButtonUp" enableMouse="true" virtual="true">
		<KeyValues>
			<KeyValue key="itemButtonXOffset" value="10" type="number"/>
			<KeyValue key="itemButtonYOffset" value="0" type="number"/>
		</KeyValues>
		<Frames>
			<Button parentKey="ItemButton" mixin="AuctionHouseInteractableItemDisplayItemButtonMixin" inherits="GiantItemButtonTemplate">
				<Anchors>
					<Anchor point="LEFT" x="12" y="0"/>
				</Anchors>
				<Scripts>
					<OnEnter method="OnEnter"/>
					<OnLeave method="OnLeave"/>
				</Scripts>
			</Button>
		</Frames>
		<Layers>
			<Layer level="ARTWORK">
				<FontString parentKey="Name" inherits="SystemFont_Shadow_Large" justifyH="LEFT">
					<Size x="0" y="64"/>
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.ItemButton" relativePoint="RIGHT" x="12" y="0"/>
						<Anchor point="RIGHT" relativeKey="$parent" relativePoint="RIGHT" x="-12" y="0"/>
					</Anchors>
				</FontString>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnEnter method="OnEnter"/>
			<OnLeave method="OnLeave"/>
			<OnClick method="OnClick"/>
			<OnReceiveDrag method="OnReceiveDrag"/>
		</Scripts>
	</Button>

	<EditBox name="AuctionHouseQuantityInputEditBoxTemplate" letters="8" numeric="true" autoFocus="false" mixin="AuctionHouseQuantityInputBoxMixin" inherits="LargeInputBoxTemplate" virtual="true">
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnTextChanged method="OnTextChanged"/>
			<OnEnterPressed function="EditBox_ClearFocus"/>
		</Scripts>
	</EditBox>

	<Frame name="AuctionHouseRefreshFrameTemplate" mixin="AuctionHouseRefreshFrameMixin" virtual="true">
		<Size x="200" y="20"/>
		<Frames>
			<Button parentKey="RefreshButton" mixin="AuctionHouseRefreshButtonMixin" inherits="RefreshButtonTemplate">
				<Anchors>
					<Anchor point="RIGHT"/>
				</Anchors>
			</Button>
		</Frames>
		<Layers>
			<Layer level="ARTWORK">
				<FontString parentKey="TotalQuantity" justifyH="RIGHT" inherits="GameFontNormalSmall">
					<Anchors>
						<Anchor point="RIGHT" relativeKey="$parent.RefreshButton" relativePoint="LEFT" x="-3" y="0"/>
						<Anchor point="LEFT"/>
						<Anchor point="TOP"/>
						<Anchor point="BOTTOM"/>
					</Anchors>
					<Color r="1.0" g="0.82" b="0"/>
					<Shadow>
						<Offset>
							<AbsDimension x="1" y="-1"/>
						</Offset>
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
			</Layer>
		</Layers>
	</Frame>

	<Frame name="AuctionHouseBidFrameTemplate" mixin="AuctionHouseBidFrameMixin" virtual="true">
		<Size x="240" y="22"/>
		<Frames>
			<Frame name ="BidAmount" parentKey="BidAmount" inherits="MoneyInputFrameTemplate">
				<Anchors>
					<Anchor point="LEFT"/>
				</Anchors>
			</Frame>
			<Button parentKey="BidButton" mixin="AuctionHouseBidButtonMixin" inherits="UIPanelButtonTemplate, ButtonWithDisableTooltipTemplate" text="AUCTION_HOUSE_BID_BUTTON">
				<Size x="110" y="22"/>
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.BidAmount" relativePoint="RIGHT" x="0" y="0"/>
				</Anchors>
				<Scripts>
					<OnClick method="OnClick"/>
				</Scripts>
			</Button>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseBuyoutFrameTemplate" mixin="AuctionHouseBuyoutFrameMixin" virtual="true">
		<Size x="110" y="22"/>
		<Frames>
			<Button parentKey="BuyoutButton" mixin="AuctionHouseBuyoutButtonMixin" inherits="UIPanelButtonTemplate, ButtonWithDisableTooltipTemplate" text="AUCTION_HOUSE_BUYOUT_BUTTON">
				<Size x="110" y="22"/>
				<Anchors>
					<Anchor point="RIGHT"/>
				</Anchors>
				<Scripts>
					<OnClick method="OnClick"/>
				</Scripts>
			</Button>
		</Frames>
	</Frame>

	<Button name="AuctionHouseFavoriteButtonBaseTemplate" mixin="AuctionHouseFavoriteButtonBaseMixin" frameStrata="HIGH" virtual="true">
		<Size x="20" y="18"/>
		<Scripts>
			<OnClick method="OnClick"/>
			<OnEnter method="OnEnter"/>
			<OnLeave method="OnLeave"/>
		</Scripts>
		<NormalTexture parentKey="NormalTexture" atlas="auctionhouse-icon-favorite"/>
		<HighlightTexture parentKey="HighlightTexture" atlas="auctionhouse-icon-favorite-off" alphaMode="ADD"/>
	</Button>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseSharedTemplates.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseTab.lua ---


local MIN_TAB_WIDTH = 70;
local TAB_PADDING = 20;


AuctionHouseFrameTabMixin = {};

function AuctionHouseFrameTabMixin:OnShow()
	local absoluteSize = nil;
	PanelTemplates_TabResize(self, TAB_PADDING, absoluteSize, MIN_TAB_WIDTH);
end


AuctionHouseFrameTopTabMixin = CreateFromMixins(AuctionHouseFrameTabMixin);

function AuctionHouseFrameTopTabMixin:OnClick()
	PlaySound(SOUNDKIT.IG_CHARACTER_INFO_TAB);
end


AuctionHouseFrameDisplayModeTabMixin = {};

function AuctionHouseFrameDisplayModeTabMixin:OnClick()
	CallMethodOnNearestAncestor(self, "SetDisplayMode", self.displayMode);
	PlaySound(SOUNDKIT.IG_CHARACTER_INFO_TAB);
end

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseTab.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseTableBuilder.lua ---

local PRICE_DISPLAY_PADDING = 0;
local BUYOUT_DISPLAY_PADDING = 0;
local STANDARD_PADDING = 10;


AuctionHouseTableCellMixin = CreateFromMixins(TableBuilderCellMixin);

function AuctionHouseTableCellMixin:Init(owner)
	self.owner = owner;
end

function AuctionHouseTableCellMixin:GetOwner()
	return self.owner;
end

function AuctionHouseTableCellMixin:GetAuctionHouseFrame()
	return self:GetOwner():GetAuctionHouseFrame();
end


AuctionHouseTableCellItemKeyMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellItemKeyMixin:Init(owner, restrictQualityToFilter)
	AuctionHouseTableCellMixin.Init(owner, restrictQualityToFilter);
	self.restrictQualityToFilter = restrictQualityToFilter;
end

function AuctionHouseTableCellItemKeyMixin:OnEvent(event, ...)
	if event == "ITEM_KEY_ITEM_INFO_RECEIVED" then
		local itemID = ...;
		if itemID == self.pendingItemID then
			self:TryUpdateDisplay();
		end
	end
end

function AuctionHouseTableCellItemKeyMixin:OnHide()
	self:UnregisterEvent("ITEM_KEY_ITEM_INFO_RECEIVED");
	self.pendingItemID = nil;
end

function AuctionHouseTableCellItemKeyMixin:Populate(rowData, dataIndex)
	self.rowData = rowData;
	self:TryUpdateDisplay();
end

function AuctionHouseTableCellItemKeyMixin:TryUpdateDisplay()
	local itemKey = self.rowData.itemKey;
	local itemKeyInfo = itemKey and C_AuctionHouse.GetItemKeyInfo(itemKey, self.restrictQualityToFilter) or nil;
	if not itemKeyInfo then
		self.pendingItemID = itemKey.itemID;
		self:RegisterEvent("ITEM_KEY_ITEM_INFO_RECEIVED");
		self.Text:SetText("");
		return;
	end

	if self.pendingItemID ~= nil then
		self:UnregisterEvent("ITEM_KEY_ITEM_INFO_RECEIVED");
		self.pendingItemID = nil;
	end

	self:UpdateDisplay(itemKey, itemKeyInfo);
end

function AuctionHouseTableCellItemKeyMixin:ClearDisplay()
	-- Implement in your derived mixin.
end

function AuctionHouseTableCellItemKeyMixin:UpdateDisplay(itemKey, itemKeyInfo)
	-- Implement in your derived mixin.
end


AuctionHouseTableCellTooltipMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellTooltipMixin:OnEnter()
	ExecuteFrameScript(self:GetParent(), "OnEnter");
	
	self:ShowTooltip(GameTooltip);
end

function AuctionHouseTableCellTooltipMixin:OnLeave()
	ExecuteFrameScript(self:GetParent(), "OnLeave");

	GameTooltip_Hide();
end

function AuctionHouseTableCellTooltipMixin:ShowTooltip(tooltip)
	-- Implement in your derived mixin.
end


AuctionHouseTableCellTextTooltipMixin = CreateFromMixins(AuctionHouseTableCellTooltipMixin);

function AuctionHouseTableCellTextTooltipMixin:UpdateText(newText)
	self.Text:SetText(newText);
	self:UpdateHitRect();
end

function AuctionHouseTableCellTextTooltipMixin:UpdateHitRect()
	local hitRectInset = self:GetWidth() - self.Text:GetStringWidth();
	if self.Text:GetJustifyH() == "LEFT" then
		self:SetHitRectInsets(0, hitRectInset, 0, 0);
	else
		self:SetHitRectInsets(hitRectInset, 0, 0, 0);
	end
end


AuctionHouseTableCellVirtualTextMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellVirtualTextMixin:Populate(rowData, dataIndex)
	self.Text:SetShown(rowData.isVirtualEntry);
	if rowData.isVirtualEntry then
		self.Text:SetText(rowData.virtualEntryText);
		self.Text:SetFontObject(rowData.isSelectedVirtualEntry and Number13FontWhite or Number13FontGray);
	end
end


AuctionHouseTablePriceDisplayMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTablePriceDisplayMixin:Init(owner)
	AuctionHouseTableCellMixin.Init(self, owner);

	self.MoneyDisplay:ClearAllPoints();
	self.MoneyDisplay:SetPoint("LEFT");
end

function AuctionHouseTablePriceDisplayMixin:UpdateWidth(rowData, dataIndex)
	-- Implement in derived mixin.
end


AuctionHouseTableCellAuctionsMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellAuctionsMixin:ShouldShowHighlighted(rowData)
	return self:IsDisplayingBids() and (self:GetAuctionHouseFrame():GetBidStatus(rowData) == AuctionHouseBidStatus.PlayerBid) or rowData.containsOwnerItem;
end

function AuctionHouseTableCellAuctionsMixin:IsDisplayingBids()
	return self:GetOwner():IsDisplayingBids();
end


AuctionHouseTableCellAuctionsTextMixin = CreateFromMixins(AuctionHouseTableCellAuctionsMixin);

function AuctionHouseTableCellAuctionsTextMixin:Populate(rowData, dataIndex)
	self.Text:SetFontObject(self:ShouldShowHighlighted(rowData) and Number13FontWhite or Number13FontGray);
end


AuctionHouseTableCellAuctionsPriceMixin = CreateFromMixins(AuctionHouseTableCellAuctionsMixin, AuctionHouseTablePriceDisplayMixin);

function AuctionHouseTableCellAuctionsPriceMixin:Populate(rowData, dataIndex)
	self.MoneyDisplay:SetFontAndIconDisabled(not self:ShouldShowHighlighted(rowData));
end


AuctionHouseTableCellUnitPriceMixin = CreateFromMixins(AuctionHouseTablePriceDisplayMixin);

function AuctionHouseTableCellUnitPriceMixin:Populate(rowData, dataIndex)
	self.MoneyDisplay:SetAmount(rowData.unitPrice);
	self:UpdateWidth(rowData, dataIndex);

	self.Checkmark:SetShown(rowData.containsOwnerItem);
end

function AuctionHouseTableCellUnitPriceMixin:UpdateWidth(rowData, dataIndex)
	self.MoneyDisplay:SetWidth(self:GetAuctionHouseFrame():GetMaxUnitPriceWidth(rowData.itemID, self.MoneyDisplay:GetFontObject()));
end


AuctionHouseTableCellCommoditiesQuantityMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellCommoditiesQuantityMixin:Init(...)
	AuctionHouseTableCellMixin.Init(self, ...);

	self.Text:SetJustifyH("RIGHT");
	self.Text:SetFontObject(PriceFontWhite);
end

function AuctionHouseTableCellCommoditiesQuantityMixin:Populate(rowData, dataIndex)
	local rowQuantity = rowData.quantity or 0;
	self.Text:SetText(BreakUpLargeNumbers(rowQuantity));
end


AuctionHouseTableCellFavoriteMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellFavoriteMixin:Populate(rowData, dataIndex)
	self.FavoriteButton:SetItemKey(rowData.itemKey);
end

function AuctionHouseTableCellFavoriteMixin:OnShow()
	self:RegisterEvent("AUCTION_HOUSE_FAVORITES_UPDATED");
end

function AuctionHouseTableCellFavoriteMixin:OnHide()
	self:UnregisterEvent("AUCTION_HOUSE_FAVORITES_UPDATED");
end

function AuctionHouseTableCellFavoriteMixin:OnEvent()
	self.FavoriteButton:UpdateState();
end

function AuctionHouseTableCellFavoriteMixin:OnLineEnter()
	self.FavoriteButton:LockTexture();
end

function AuctionHouseTableCellFavoriteMixin:OnLineLeave()
	self.FavoriteButton:UnlockTexture();
end


AuctionHouseTableCellFavoriteButtonMixin = CreateFromMixins(AuctionHouseTableCellMixin, AuctionHouseFavoriteButtonBaseMixin);

function AuctionHouseTableCellFavoriteButtonMixin:OnEnter()
	if not self:IsInteractionAvailable() then
		self:ShowMaxedFavoritesTooltip();
		self:LockTexture();
	else
		local row = self:GetParent():GetParent();
		ExecuteFrameScript(row, "OnEnter");
	end
end

function AuctionHouseTableCellFavoriteButtonMixin:OnLeave()
	GameTooltip_Hide();
	self:UnlockTexture();

	local row = self:GetParent():GetParent();
	ExecuteFrameScript(row, "OnLeave");
end

function AuctionHouseTableCellFavoriteButtonMixin:UpdateFavoriteState()
	local isFavorite = self:IsFavorite();
	local defaultTexture = self.textureLocked and "auctionhouse-icon-favorite-off" or nil;
	self.NormalTexture:SetAtlas(isFavorite and "auctionhouse-icon-favorite" or defaultTexture);
	self.HighlightTexture:SetAtlas(isFavorite and "auctionhouse-icon-favorite" or "auctionhouse-icon-favorite-off");
	self.HighlightTexture:SetAlpha(isFavorite and 0.2 or 0.4);
end

function AuctionHouseTableCellFavoriteButtonMixin:UpdateState()
	self:UpdateFavoriteState();
end

function AuctionHouseTableCellFavoriteButtonMixin:LockTexture()
	self.textureLocked = true;

	if not self:IsFavorite() then
		self.NormalTexture:SetAtlas("auctionhouse-icon-favorite-off");
	end
end

function AuctionHouseTableCellFavoriteButtonMixin:UnlockTexture()
	self.textureLocked = false;

	if not self:IsFavorite() then
		self.NormalTexture:SetAtlas(nil);
	end
end

AuctionHouseTableCellBidMixin = CreateFromMixins(AuctionHouseTablePriceDisplayMixin);

function AuctionHouseTableCellBidMixin:Init(owner)
	AuctionHouseTablePriceDisplayMixin.Init(self, owner);

	self.MoneyDisplay:SetFontAndIconDisabled(true);
end

function AuctionHouseTableCellBidMixin:Populate(rowData, dataIndex)
	local hasBid = rowData.bidAmount ~= nil;
	self.MoneyDisplay:SetShown(hasBid);
	if hasBid then
		self.MoneyDisplay:SetAmount(rowData.bidAmount);
		self:UpdateWidth(rowData, dataIndex);
		self:UpdateTextColor(rowData, dataIndex);
	end

	local hasBuyout = rowData.buyoutAmount ~= nil;
	self.Checkmark:SetShown(not hasBuyout and rowData.containsOwnerItem);
end

function AuctionHouseTableCellBidMixin:UpdateTextColor(rowData, dataIndex)
	AuctionHouseUtil.SetBidsFrameBidTextColor(self.MoneyDisplay, self:GetAuctionHouseFrame():GetBidStatus(rowData));
end

function AuctionHouseTableCellBidMixin:UpdateWidth(rowData, dataIndex)
	self.MoneyDisplay:SetWidth(self:GetAuctionHouseFrame():GetMaxBidWidth(rowData.itemKey, self.MoneyDisplay:GetFontObject()));
end


AuctionHouseTableCellBuyoutMixin = CreateFromMixins(AuctionHouseTablePriceDisplayMixin);

function AuctionHouseTableCellBuyoutMixin:Populate(rowData, dataIndex)
	self.MoneyDisplay:SetShown(not rowData.isVirtualEntry);
	if rowData.isVirtualEntry then
		self.Checkmark:Hide();
		return;
	end

	local hasBuyout = rowData.buyoutAmount ~= nil;
	self.MoneyDisplay:SetShown(hasBuyout);
	if hasBuyout then
		self.MoneyDisplay:SetAmount(rowData.buyoutAmount);
		self:UpdateWidth(rowData, dataIndex);
	end

	self.Checkmark:SetShown(hasBuyout and rowData.containsOwnerItem);
end

function AuctionHouseTableCellBuyoutMixin:UpdateWidth(rowData, dataIndex)
	self.MoneyDisplay:SetWidth(self:GetAuctionHouseFrame():GetMaxBuyoutWidth(rowData.itemKey, self.MoneyDisplay:GetFontObject()));
end


AuctionHouseTableCellOwnedCheckmarkMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellOwnedCheckmarkMixin:Init(owner)
	AuctionHouseTableCellMixin.Init(self, owner);

	self.Icon:SetAtlas("auctionhouse-icon-checkmark", true);
end

function AuctionHouseTableCellOwnedCheckmarkMixin:Populate(rowData, dataIndex)
	self.Icon:SetShown(rowData.containsOwnerItem);
end


AuctionHouseTableExtraInfoMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableExtraInfoMixin:Init()
	AuctionHouseTableCellMixin.Init(self, owner);

	self.Icon:SetAtlas("auctionhouse-icon-socket", true);
	self.Text:SetFontObject(Number13FontWhite);
end

function AuctionHouseTableExtraInfoMixin:Populate(rowData, dataIndex)
	self.Icon:SetShown(rowData.containsSocketedItem);

	self.Text:Hide();
	if not rowData.containsSocketedItem and rowData.itemLink then
		local linkType, linkOptions, name = LinkUtil.ExtractLink(rowData.itemLink);
		if linkType == "battlepet" then
			local speciesID, level, breedQuality = strsplit(":", linkOptions);
			local qualityColor = ColorManager.GetColorDataForBagItemQuality(tonumber(breedQuality));
			if qualityColor and qualityColor.wrapTextInColorCode then
				self.Text:SetText(qualityColor and qualityColor:WrapTextInColorCode(level) or level);
			else
				self.Text:SetText(level);
				if qualityColor then
					self.Text:SetTextColor(qualityColor.r, qualityColor.g, qualityColor.b);
				end
			end
			self.Text:Show();
		end
	end
end


AuctionHouseTableCellOwnersMixin = CreateFromMixins(AuctionHouseTableCellTextTooltipMixin);

function AuctionHouseTableCellOwnersMixin:Init(owner)
	AuctionHouseTableCellMixin.Init(self, owner);

	self.Text:SetFontObject(Number13FontGray);
end

function AuctionHouseTableCellOwnersMixin:Populate(rowData, dataIndex)
	if rowData.owners then
		self:UpdateText(AuctionHouseUtil.GetSellersString(rowData));
	end
end

function AuctionHouseTableCellOwnersMixin:ShowTooltip(tooltip)
	local owners = self.rowData.owners;
	if owners and #owners > 1 then
		tooltip:SetOwner(self:GetParent(), "ANCHOR_RIGHT");
		AuctionHouseUtil.AddSellersToTooltip(tooltip, owners, self.rowData.totalNumberOfOwners);
		tooltip:Show();
	end
end


AuctionHouseTableCellTimeLeftMixin = CreateFromMixins(AuctionHouseTableCellTextTooltipMixin);

function AuctionHouseTableCellTimeLeftMixin:Init(owner)
	AuctionHouseTableCellMixin.Init(self, owner);
	self.Text:SetJustifyH("RIGHT");
	self.Text:SetFontObject(Number13FontGray);
end

function AuctionHouseTableCellTimeLeftMixin:Populate(rowData, dataIndex)
	local timeLeftSeconds = self:GetTimeLeftSeconds();
	local hasExplicitTimeLeft = timeLeftSeconds ~= nil;
	self.Text:SetShown(hasExplicitTimeLeft);

	if hasExplicitTimeLeft then
		self:UpdateText(AuctionHouseUtil.FormatTimeLeft(timeLeftSeconds, rowData));
	end
end

function AuctionHouseTableCellTimeLeftMixin:GetTimeLeftSeconds()
	if not self.rowData then
		return nil;
	end

	if self.rowData.timeLeftSeconds then
		return self.rowData.timeLeftSeconds;
	elseif self.rowData.timeLeft then
		local timeLeftMin, timeLeftMax = C_AuctionHouse.GetTimeLeftBandInfo(self.rowData.timeLeft);
		return timeLeftMax;
	end

	return nil;
end

function AuctionHouseTableCellTimeLeftMixin:GetTooltipText()
	local timeLeftSeconds = self.rowData.timeLeftSeconds;
	if timeLeftSeconds ~= nil then
		return AuctionHouseUtil.FormatTimeLeftTooltip(timeLeftSeconds, self.rowData);
	else
		local timeLeft = self.rowData.timeLeft;
		if timeLeft ~= nil then
			return AuctionHouseUtil.GetTooltipTimeLeftBandText(self.rowData);
		end
	end

	return nil;
end

function AuctionHouseTableCellTimeLeftMixin:ShowTooltip(tooltip)
	local tooltipText = self:GetTooltipText();
	if tooltipText then
		local owner = self:GetParent();
		owner.UpdateTooltip = nil;
		tooltip:SetOwner(owner, "ANCHOR_RIGHT");

		local wrap = true;
		GameTooltip_AddNormalLine(tooltip, tooltipText, wrap);

		tooltip:Show();
	end
end


AuctionHouseTableCellTimeLeftBandMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellTimeLeftBandMixin:Init(owner)
	AuctionHouseTableCellMixin.Init(self, owner);
	self.Text:SetFontObject(Number13FontGray);
	self.Text:SetJustifyH("RIGHT");
end

function AuctionHouseTableCellTimeLeftBandMixin:Populate(rowData, dataIndex)
	local hasExplicitTimeLeft = rowData.timeLeft ~= nil;
	self.Text:SetShown(hasExplicitTimeLeft);

	if hasExplicitTimeLeft then
		self.Text:SetText(AuctionHouseUtil.GetTimeLeftBandText(rowData.timeLeft));
	end
end


AuctionHouseTableCellAuctionsBidMixin = CreateFromMixins(AuctionHouseTableCellAuctionsPriceMixin, AuctionHouseTableCellBidMixin);

function AuctionHouseTableCellAuctionsBidMixin:Init(...)
	AuctionHouseTableCellAuctionsPriceMixin.Init(self, ...);
	AuctionHouseTableCellBidMixin.Init(self, ...);

	self.Text:SetFontObject("Number14FontGray");
end

function AuctionHouseTableCellAuctionsBidMixin:Populate(rowData, dataIndex)
	if self:IsDisplayingBids() then
		self.MoneyDisplay:Show();

		AuctionHouseTableCellBidMixin.Populate(self, rowData, dataIndex);
	else
		self.MoneyDisplay:SetFontAndIconDisabled(true);

		local sold = rowData.status == Enum.AuctionStatus.Sold;
		self.Text:SetShown(sold);
		self.MoneyDisplay:SetShown(not sold);
		if sold then
			self.Text:SetText(AUCTION_HOUSE_INCOMING_AMOUNT);
			self.Checkmark:Hide();
		else
			AuctionHouseTableCellBidMixin.Populate(self, rowData, dataIndex);
		end
	end
end

function AuctionHouseTableCellAuctionsBidMixin:UpdateTextColor(rowData, dataIndex)
	if self:IsDisplayingBids() then
		AuctionHouseTableCellBidMixin.UpdateTextColor(self, rowData, dataIndex);
	else
		AuctionHouseUtil.SetOwnedAuctionBidTextColor(self.MoneyDisplay, rowData);
	end
end


AuctionHouseTableCellAllAuctionsPriceMixin = CreateFromMixins(AuctionHouseTableCellTooltipMixin);

function AuctionHouseTableCellAllAuctionsPriceMixin:Populate(rowData, dataIndex)
	self:UpdateBidder();
end

function AuctionHouseTableCellAllAuctionsPriceMixin:OnEvent(event, ...)
	if event == "OWNED_AUCTION_BIDDER_INFO_RECEIVED" then
		local auctionID, bidderName = ...;
		if auctionID == self.rowData.auctionID then
			self.rowData.bidder = bidderName;
			self:UnregisterEvent("OWNED_AUCTION_BIDDER_INFO_RECEIVED");
			
			if GameTooltip:GetOwner() == self then
				self:ShowTooltip(GameTooltip);
			end
		end
	end
end

function AuctionHouseTableCellAllAuctionsPriceMixin:UpdateBidder()
	local rowData = self.rowData;
	if rowData.bidder then
		if rowData.bidder == "" then
			local updatedName = C_AuctionHouse.RequestOwnedAuctionBidderInfo(rowData.auctionID);
			if updatedName then
				rowData.bidder = updatedName;
			else
				self:RegisterEvent("OWNED_AUCTION_BIDDER_INFO_RECEIVED");
			end
		end
	end
end


AuctionHouseTableCellAllAuctionsBidMixin = CreateFromMixins(AuctionHouseTableCellAllAuctionsPriceMixin, AuctionHouseTableCellAuctionsBidMixin);

function AuctionHouseTableCellAllAuctionsBidMixin:Populate(rowData, dataIndex)
	AuctionHouseTableCellAllAuctionsPriceMixin.Populate(self, rowData, dataIndex);
	AuctionHouseTableCellAuctionsBidMixin.Populate(self, rowData, dataIndex);
end

function AuctionHouseTableCellAllAuctionsBidMixin:UpdateWidth(rowData, dataIndex)
	local maxWidth = self:IsDisplayingBids() and self:GetAuctionHouseFrame():GetMaxBidPriceWidthForAllBids(self.MoneyDisplay:GetFontObject()) or self:GetAuctionHouseFrame():GetMaxBidPriceWidthForAllAuctions(self.MoneyDisplay:GetFontObject());
	self.MoneyDisplay:SetWidth(maxWidth);
end

function AuctionHouseTableCellAllAuctionsBidMixin:ShowTooltip(tooltip)
	self:UpdateBidder();

	local rowData = self.rowData;
	local bidder = rowData.bidder;
	if bidder then
		tooltip:SetOwner(self, "ANCHOR_RIGHT");

		local wrap = true;
		if rowData.status == Enum.AuctionStatus.Sold then
			GameTooltip_AddNormalLine(tooltip, AUCTION_HOUSE_BUYER_FORMAT:format(bidder), wrap);
		else
			GameTooltip_AddNormalLine(tooltip, AUCTION_HOUSE_HIGH_BIDDER_FORMAT:format(bidder), wrap);
		end

		tooltip:Show();
	end
end


AuctionHouseTableCellAuctionsBuyoutMixin = CreateFromMixins(AuctionHouseTableCellAllAuctionsPriceMixin, AuctionHouseTableCellAuctionsPriceMixin, AuctionHouseTableCellBuyoutMixin);

function AuctionHouseTableCellAuctionsBuyoutMixin:Init(...)
	AuctionHouseTableCellAuctionsPriceMixin.Init(self, ...);
	AuctionHouseTableCellBuyoutMixin.Init(self, ...);
end

function AuctionHouseTableCellAuctionsBuyoutMixin:Populate(rowData, dataIndex)
	AuctionHouseTableCellAllAuctionsPriceMixin.Populate(self, rowData, dataIndex);
	AuctionHouseTableCellAuctionsPriceMixin.Populate(self, rowData, dataIndex);
	AuctionHouseTableCellBuyoutMixin.Populate(self, rowData, dataIndex);
end

function AuctionHouseTableCellAuctionsBuyoutMixin:ShowTooltip(tooltip)
	self:UpdateBidder();

	local rowData = self.rowData;
	local bidder = rowData.bidder;
	if bidder and rowData.status == Enum.AuctionStatus.Sold then
		tooltip:SetOwner(self, "ANCHOR_RIGHT");

		local wrap = true;
		GameTooltip_AddNormalLine(tooltip, AUCTION_HOUSE_BUYER_FORMAT:format(bidder), wrap);

		tooltip:Show();
	end
end


AuctionHouseTableCellAllAuctionsBuyoutMixin = CreateFromMixins(AuctionHouseTableCellAuctionsBuyoutMixin);

function AuctionHouseTableCellAllAuctionsBuyoutMixin:UpdateWidth(rowData, dataIndex)
	local maxWidth = self:IsDisplayingBids() and self:GetAuctionHouseFrame():GetMaxBuyoutPriceWidthForAllBids(self.MoneyDisplay:GetFontObject()) or self:GetAuctionHouseFrame():GetMaxBuyoutPriceWidthForAllAuctions(self.MoneyDisplay:GetFontObject());
	self.MoneyDisplay:SetWidth(maxWidth);
end

function AuctionHouseTableCellAllAuctionsBuyoutMixin:ShouldShowHighlighted()
	return self.rowData.status ~= Enum.AuctionStatus.Sold;
end


AuctionHouseTableCellAuctionsOwnersMixin = CreateFromMixins(AuctionHouseTableCellAuctionsTextMixin);

function AuctionHouseTableCellAuctionsOwnersMixin:Init(owner, disableTooltip)
	AuctionHouseTableCellAuctionsTextMixin.Init(self, owner);
	self.disableTooltip = disableTooltip;
end

function AuctionHouseTableCellAuctionsOwnersMixin:Populate(rowData, dataIndex)
	AuctionHouseTableCellOwnersMixin.Populate(self, rowData, dataIndex);
	AuctionHouseTableCellAuctionsTextMixin.Populate(self, rowData, dataIndex);
end

function AuctionHouseTableCellAuctionsOwnersMixin:ShowTooltip(tooltip)
	if not self.disableTooltip then
		AuctionHouseTableCellOwnersMixin.ShowTooltip(self, tooltip);
	end
end


AuctionHouseTableCellAuctionsItemLevelMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellAuctionsItemLevelMixin:Init(...)
	AuctionHouseTableCellMixin.Init(self, ...);
	self.Text:SetJustifyH("LEFT");
end

function AuctionHouseTableCellAuctionsItemLevelMixin:Populate(rowData, dataIndex)
	if rowData.isVirtualEntry then
		self.Text:SetText("");
		return;
	end

	local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(rowData.itemKey);
	if itemKeyInfo then
		local colorData = ColorManager.GetColorDataForItemQuality(itemKeyInfo.quality);
		if colorData then
			self.Text:SetTextColor(colorData.color:GetRGB());
		end
	end

	self.Text:SetText(rowData.itemKey.itemLevel);
end


AuctionHouseTableCellAuctionsCommoditiesQuantityMixin = CreateFromMixins(AuctionHouseTableCellAuctionsTextMixin);

function AuctionHouseTableCellAuctionsCommoditiesQuantityMixin:Populate(rowData, dataIndex)
	AuctionHouseTableCellCommoditiesQuantityMixin.Populate(self, rowData, dataIndex);
	AuctionHouseTableCellAuctionsTextMixin.Populate(self, rowData, dataIndex);
	self.Text:SetJustifyH("RIGHT");
	self.Text:SetFontObject(PriceFontWhite);
end


AuctionHouseTableCellAuctionsUnitPriceMixin = CreateFromMixins(AuctionHouseTableCellAuctionsPriceMixin, AuctionHouseTableCellUnitPriceMixin);

function AuctionHouseTableCellAuctionsUnitPriceMixin:Init(...)
	AuctionHouseTableCellAuctionsPriceMixin.Init(self, ...);
	AuctionHouseTableCellUnitPriceMixin.Init(self, ...);
end

function AuctionHouseTableCellAuctionsUnitPriceMixin:Populate(rowData, dataIndex)
	AuctionHouseTableCellAuctionsPriceMixin.Populate(self, rowData, dataIndex);
	AuctionHouseTableCellUnitPriceMixin.Populate(self, rowData, dataIndex);
end

function AuctionHouseTableCellAuctionsUnitPriceMixin:UpdateWidth(rowData, dataIndex)
	self.MoneyDisplay:SetWidth(self:GetAuctionHouseFrame():GetMaxUnitPriceWidth(rowData.itemID, self.MoneyDisplay:GetFontObject()));
end


AuctionHouseTableCellItemDisplayMixin = CreateFromMixins(AuctionHouseTableCellItemKeyMixin);

function AuctionHouseTableCellItemDisplayMixin:Init(owner, restrictQualityToFilter, hideItemLevel)
	AuctionHouseTableCellItemKeyMixin.Init(self, owner, restrictQualityToFilter);

	self.hideItemLevel = hideItemLevel;
end

function AuctionHouseTableCellItemDisplayMixin:ClearDisplay()
	self.Text:SetText("");
	self.ExtraInfo:SetText("");
	self.ExtraInfo:Hide();
	self.Icon:Hide();
end

function AuctionHouseTableCellItemDisplayMixin:UpdateDisplay(itemKey, itemKeyInfo)
	local rowData = self.rowData;
	local itemName = AuctionHouseUtil.GetItemDisplayTextFromItemKey(itemKey, itemKeyInfo, self.hideItemLevel);
	local craftingQualityIcon = AuctionHouseUtil.GetItemDisplayCraftingQualityIconFromItemKey(itemKey);

	if craftingQualityIcon then
		self.Text:SetText(itemName .. " " .. craftingQualityIcon);
		self.ExtraInfo:SetText(craftingQualityIcon);
	else
		self.Text:SetText(itemName);
		self.ExtraInfo:SetText("");
	end

	self.Text:SetPoint("RIGHT", self, nil, 1);

	self.Icon:SetTexture(itemKeyInfo.iconFileID);
	self.Icon:Show();

	local noneAvailable = rowData.totalQuantity == 0;
	self.Icon:SetAlpha(noneAvailable and 0.5 or 1.0);
	self:HandleItemNameTruncation();
end

function AuctionHouseTableCellItemDisplayMixin:HandleItemNameTruncation()
	if (self:GetWidth() ~= 0 and self.Text:IsTruncated()) then
		self.Text:SetPoint("RIGHT", self.ExtraInfo, "LEFT");
		self.ExtraInfo:Show();
	else
		self.ExtraInfo:Hide();
	end
end

AuctionHouseTableCellAuctionsItemDisplayMixin = CreateFromMixins(AuctionHouseTableCellAuctionsMixin, AuctionHouseTableCellItemDisplayMixin);

function AuctionHouseTableCellAuctionsItemDisplayMixin:Init(...)
	AuctionHouseTableCellAuctionsMixin.Init(self, ...);
	AuctionHouseTableCellItemDisplayMixin.Init(self, ...);

	self.Prefix:SetText(AUCTION_HOUSE_AUCTION_SOLD_PREFIX);
end

function AuctionHouseTableCellAuctionsItemDisplayMixin:UpdateDisplay(itemKey, itemKeyInfo)
	AuctionHouseTableCellItemDisplayMixin.UpdateDisplay(self, itemKey, itemKeyInfo);

	local itemName = AuctionHouseUtil.GetDisplayTextFromOwnedAuctionData(self.rowData, itemKeyInfo, self.hideItemLevel);
	local craftingQualityIcon = AuctionHouseUtil.GetItemDisplayCraftingQualityIconFromItemKey(itemKey);
	local quantity = AuctionHouseUtil.GetQuantityDisplayTextFromOwnedAuctionData(self.rowData);
	local extraInfo = quantity or "";

	if craftingQualityIcon then
		extraInfo = extraInfo .. " " .. craftingQualityIcon;
	end

	if not self:IsDisplayingBids() then
		self.Text:SetText(itemName .. " " .. extraInfo);
		self.ExtraInfo:SetText(extraInfo);
	end

	local sold = self.rowData.status == Enum.AuctionStatus.Sold;
	self.Prefix:SetShown(sold);
	self.Icon:ClearAllPoints();
	self.Icon:SetAlpha(sold and 0.5 or 1.0);
	self.IconBorder:SetAlpha(sold and 0.5 or 1.0);
	if sold then
		self.Icon:SetPoint("LEFT", self.Prefix, "RIGHT");
	else
		self.Icon:SetPoint("LEFT");
	end
end


AuctionHouseTableCellMinPriceMixin = CreateFromMixins(AuctionHouseTablePriceDisplayMixin);

function AuctionHouseTableCellMinPriceMixin:Init(rowData, dataIndex)
	AuctionHouseTableCellMixin.Init(self, owner);

	self.Checkmark:ClearAllPoints();
	self.Checkmark:SetPoint("RIGHT");

	self.MoneyDisplay:ClearAllPoints();
	self.MoneyDisplay:SetPoint("RIGHT", self.Checkmark, "LEFT", -6, 0);

	self.Text:SetText(AUCTION_HOUSE_NONE_AVAILABLE);
	self.Text:SetFontObject(Number14FontGray);
	self.Text:SetJustifyH("RIGHT");
end

function AuctionHouseTableCellMinPriceMixin:Populate(rowData, dataIndex)
	local noneAvailable = self.rowData.totalQuantity == 0;
	self.Text:SetShown(noneAvailable);
	self.MoneyDisplay:SetShown(not noneAvailable);
	self.MoneyDisplay:SetAmount(rowData.minPrice);
	self.Checkmark:SetShown(rowData.containsOwnerItem);
end


AuctionHouseTableCellQuantityMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellQuantityMixin:Populate(rowData, dataIndex)
	local noneAvailable = self.rowData.totalQuantity == 0;
	self.Text:SetFontObject(noneAvailable and PriceFontGray or PriceFontWhite);
	self.Text:SetText(BreakUpLargeNumbers(rowData.totalQuantity));
end


AuctionHouseTableCellLevelMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellLevelMixin:Populate(rowData, dataIndex)
	self.rowData = rowData;
	self:UpdateDisplay();
end

function AuctionHouseTableCellLevelMixin:UpdateDisplay()
	local extraInfo, quality = C_AuctionHouse.GetExtraBrowseInfo(self.rowData.itemKey);
	if not extraInfo then
		self.Text:SetText("");
		self:RegisterEvent("EXTRA_BROWSE_INFO_RECEIVED");
		return;
	end

	self:UnregisterEvent("EXTRA_BROWSE_INFO_RECEIVED");

	self.Text:SetText(extraInfo);
end

function AuctionHouseTableCellLevelMixin:OnEvent(event, ...)
	if event == "EXTRA_BROWSE_INFO_RECEIVED" then
		local itemID = ...;
		if self.rowData and self.rowData.itemKey and itemID == self.rowData.itemKey.itemID then
			self:UpdateDisplay();
		end
	end
end

function AuctionHouseTableCellLevelMixin:OnHide(event, ...)
	self:UnregisterEvent("EXTRA_BROWSE_INFO_RECEIVED");
end


AuctionHouseTableCellItemSellBuyoutMixin = CreateFromMixins(AuctionHouseTableCellVirtualTextMixin, AuctionHouseTableCellBuyoutMixin);

function AuctionHouseTableCellItemSellBuyoutMixin:Populate(rowData, dataIndex)
	AuctionHouseTableCellVirtualTextMixin.Populate(self, rowData, dataIndex);
	AuctionHouseTableCellBuyoutMixin.Populate(self, rowData, dataIndex);
end


AuctionHouseTableCellItemQuantityMixin = CreateFromMixins(AuctionHouseTableCellMixin);

function AuctionHouseTableCellItemQuantityMixin:Init(owner, hideBidStatus)
	AuctionHouseTableCellMixin.Init(self, owner);
	
	self.hideBidStatus = hideBidStatus;
	self.Text:SetJustifyH(self.justificationH or "LEFT");
end

function AuctionHouseTableCellItemQuantityMixin:Populate(rowData, dataIndex)
	local bidStatus = self:GetAuctionHouseFrame():GetBidStatus(rowData);
	local hasPlayerBid = bidStatus == AuctionHouseBidStatus.PlayerBid or bidStatus == AuctionHouseBidStatus.PlayerOutbid;
	local showPlayerBid = hasPlayerBid and not self.hideBidStatus;

	local rowQuantity = rowData.quantity or 0;
	self.Text:SetShown(showPlayerBid or (rowQuantity > 1));

	if showPlayerBid then
		self.Text:SetText(AuctionHouseUtil.GetBidTextFromStatus(bidStatus));
		self.Text:SetFontObject(Number13FontGray);
	else
		self.Text:SetText(BreakUpLargeNumbers(rowQuantity));
		self.Text:SetFontObject(PriceFontWhite);
	end
end


AuctionHouseTableHeaderStringMixin = CreateFromMixins(TableBuilderElementMixin);

function AuctionHouseTableHeaderStringMixin:OnClick()
	self.owner:SetSortOrder(self.sortOrder);
	self:UpdateArrow();
end

function AuctionHouseTableHeaderStringMixin:Init(owner, headerText, sortOrder)
	self:SetText(headerText);

	local interactiveHeader = owner.RegisterHeader and sortOrder ~= nil;
	self:SetEnabled(interactiveHeader);
	self.owner = owner;
	self.sortOrder = sortOrder;

	if interactiveHeader then
		owner:RegisterHeader(self);
		self:UpdateArrow();
	else
		self.Arrow:Hide();
	end
end

function AuctionHouseTableHeaderStringMixin:UpdateArrow()
	local sortOrderState = self.owner:GetSortOrderState(self.sortOrder);
	self:SetArrowState(sortOrderState);
end

function AuctionHouseTableHeaderStringMixin:SetArrowState(sortOrderState)
	self.Arrow:SetShown(sortOrderState == AuctionHouseSortOrderState.PrimarySorted or sortOrderState == AuctionHouseSortOrderState.PrimaryReversed);
	if sortOrderState == AuctionHouseSortOrderState.PrimarySorted then
		self.Arrow:SetTexCoord(0, 1, 1, 0);
	elseif sortOrderState == AuctionHouseSortOrderState.PrimaryReversed then
		self.Arrow:SetTexCoord(0, 1, 0, 1);
	end
end


AuctionHouseTableBuilderMixin = {};

function AuctionHouseTableBuilderMixin:AddColumnInternal(owner, sortOrder, cellTemplate, ...)
	local column = self:AddColumn();

	if sortOrder then
		local headerName = AuctionHouseUtil.GetHeaderNameFromSortOrder(sortOrder);
		column:ConstructHeader("BUTTON", "AuctionHouseTableHeaderStringTemplate", owner, headerName, sortOrder);
	end

	column:ConstructCells("FRAME", cellTemplate, owner, ...);

	return column;
end

function AuctionHouseTableBuilderMixin:AddUnsortableColumnInternal(owner, headerText, cellTemplate, ...)
	local column = self:AddColumn();
	local sortOrder = nil;
	column:ConstructHeader("BUTTON", "AuctionHouseTableHeaderStringTemplate", owner, headerText, sortOrder);
	column:ConstructCells("FRAME", cellTemplate, owner, ...);
	return column;
end

function AuctionHouseTableBuilderMixin:AddFixedWidthColumn(owner, padding, width, leftCellPadding, rightCellPadding, sortOrder, cellTemplate, ...)
	local column = self:AddColumnInternal(owner, sortOrder, cellTemplate, ...);
	column:SetFixedConstraints(width, padding);
	column:SetCellPadding(leftCellPadding, rightCellPadding);
	return column;
end

function AuctionHouseTableBuilderMixin:AddFillColumn(owner, padding, fillCoefficient, leftCellPadding, rightCellPadding, sortOrder, cellTemplate, ...)
	local column = self:AddColumnInternal(owner, sortOrder, cellTemplate, ...);
	column:SetFillConstraints(fillCoefficient, padding);
	column:SetCellPadding(leftCellPadding, rightCellPadding);
	return column;
end

function AuctionHouseTableBuilderMixin:AddUnsortableFixedWidthColumn(owner, padding, width, leftCellPadding, rightCellPadding, headerText, cellTemplate, ...)
	local column = self:AddUnsortableColumnInternal(owner, headerText, cellTemplate, ...);
	column:SetFixedConstraints(width, padding);
	column:SetCellPadding(leftCellPadding, rightCellPadding);
	return column;
end

function AuctionHouseTableBuilderMixin:AddUnsortableFillColumn(owner, padding, fillCoefficient, leftCellPadding, rightCellPadding, headerText, cellTemplate, ...)
	local column = self:AddUnsortableColumnInternal(owner, headerText, cellTemplate, ...);
	column:SetFillConstraints(fillCoefficient, padding);
	column:SetCellPadding(leftCellPadding, rightCellPadding);
	return column;
end


AuctionHouseTableBuilder = {};

function AuctionHouseTableBuilder.GetAllAuctionsLayout(owner, itemList)
	local function LayoutAllAuctionsTableBuilder(tableBuilder)
		tableBuilder:SetColumnHeaderOverlap(2);
		tableBuilder:SetHeaderContainer(itemList:GetHeaderContainer());

		tableBuilder:AddFillColumn(owner, 0, 1.0, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Name, "AuctionHouseTableCellAuctionsItemDisplayTemplate");
		tableBuilder:AddFixedWidthColumn(owner, PRICE_DISPLAY_PADDING, PRICE_DISPLAY_WIDTH, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Bid, "AuctionHouseTableCellAllAuctionsBidTemplate");
		tableBuilder:AddFixedWidthColumn(owner, BUYOUT_DISPLAY_PADDING, PRICE_DISPLAY_WIDTH, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Buyout, "AuctionHouseTableCellAllAuctionsBuyoutTemplate");
		tableBuilder:AddFixedWidthColumn(owner, 0, 50, 0, STANDARD_PADDING, Enum.AuctionHouseSortOrder.TimeRemaining, "AuctionHouseTableCellTimeLeftTemplate");
	end

	return LayoutAllAuctionsTableBuilder;
end

function AuctionHouseTableBuilder.GetBidsListLayout(owner, itemList)
	local function LayoutBidsListTableBuilder(tableBuilder)
		tableBuilder:SetColumnHeaderOverlap(2);
		tableBuilder:SetHeaderContainer(itemList:GetHeaderContainer());

		tableBuilder:AddFillColumn(owner, 0, 1.0, 10, 0, Enum.AuctionHouseSortOrder.Name, "AuctionHouseTableCellAuctionsItemDisplayTemplate");
		tableBuilder:AddFixedWidthColumn(owner, PRICE_DISPLAY_PADDING, PRICE_DISPLAY_WIDTH, 10, 0, Enum.AuctionHouseSortOrder.Bid, "AuctionHouseTableCellAllAuctionsBidTemplate");
		tableBuilder:AddFixedWidthColumn(owner, BUYOUT_DISPLAY_PADDING, PRICE_DISPLAY_WIDTH, 10, 0, Enum.AuctionHouseSortOrder.Buyout, "AuctionHouseTableCellAllAuctionsBuyoutTemplate");
		tableBuilder:AddFixedWidthColumn(owner, 0, 140, 0, 10, nil, "AuctionHouseTableCellTimeLeftBandTemplate");
	end

	return LayoutBidsListTableBuilder;
end

function AuctionHouseTableBuilder.GetAuctionsItemListLayout(owner, itemList)
	local function LayoutAuctionsItemListTableBuilder(tableBuilder)
		tableBuilder:SetColumnHeaderOverlap(2);
		tableBuilder:SetHeaderContainer(itemList:GetHeaderContainer());

		tableBuilder:AddFixedWidthColumn(owner, PRICE_DISPLAY_PADDING, PRICE_DISPLAY_WIDTH, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Bid, "AuctionHouseTableCellAuctionsBidTemplate");
		tableBuilder:AddFixedWidthColumn(owner, BUYOUT_DISPLAY_PADDING, PRICE_DISPLAY_WITH_CHECKMARK_WIDTH, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Buyout, "AuctionHouseTableCellItemBuyoutTemplate");

		tableBuilder:AddFillColumn(owner, 1.0, 40, STANDARD_PADDING, 0, nil, "AuctionHouseTableCellItemQuantityLeftTemplate");
		tableBuilder:AddFixedWidthColumn(owner, 0, 24, 0, 0, nil, "AuctionHouseTableCellExtraInfoTemplate");

		local disableTooltip = true;
		tableBuilder:AddFixedWidthColumn(owner, 0, 90, STANDARD_PADDING, 0, nil, "AuctionHouseTableCellAuctionsOwnersTemplate", disableTooltip);
		
		tableBuilder:AddFixedWidthColumn(owner, 0, 60, 0, 10, nil, "AuctionHouseTableCellTimeLeftTemplate");
	end

	return LayoutAuctionsItemListTableBuilder;
end

function AuctionHouseTableBuilder.GetCommoditiesAuctionsListLayout(owner, itemList)
	local function LayoutCommoditiesAuctionsListTableBuilder(tableBuilder)
		tableBuilder:SetColumnHeaderOverlap(2);
		tableBuilder:SetHeaderContainer(itemList:GetHeaderContainer());

		tableBuilder:AddUnsortableFixedWidthColumn(owner, PRICE_DISPLAY_PADDING, PRICE_DISPLAY_WITH_CHECKMARK_WIDTH, 10, 0, AUCTION_HOUSE_HEADER_UNIT_PRICE, "AuctionHouseTableCellAuctionsUnitPriceTemplate");

		tableBuilder:AddFixedWidthColumn(owner, 0, 60, 0, 0, nil, "AuctionHouseTableCellAuctionsCommoditiesQuantityTemplate");
		tableBuilder:AddFillColumn(owner, 0, 1.0, 0, 0, nil, "AuctionHouseTableEmptyTemplate");
		tableBuilder:AddFixedWidthColumn(owner, 0, 90, 0, 0, nil, "AuctionHouseTableCellAuctionsOwnersTemplate");
		tableBuilder:AddFixedWidthColumn(owner, 0, 60, 0, 10, nil, "AuctionHouseTableCellTimeLeftTemplate");
	end

	return LayoutCommoditiesAuctionsListTableBuilder;
end

function AuctionHouseTableBuilder.GetBrowseListLayout(owner, itemList, extraInfoColumnText)
	local function LayoutBrowseListTableBuilder(tableBuilder)
		tableBuilder:SetColumnHeaderOverlap(2);
		tableBuilder:SetHeaderContainer(itemList:GetHeaderContainer());
		
		local priceWidth = 146;
		local quantityWidth = 83;

		-- Adjust column sizing when displaying copper values
		if (C_AuctionHouse.SupportsCopperValues()) then
			priceWidth = 168;
			quantityWidth = 60;
		end

		tableBuilder:AddFixedWidthColumn(owner, PRICE_DISPLAY_PADDING, priceWidth, 0, 14, Enum.AuctionHouseSortOrder.Price, "AuctionHouseTableCellMinPriceTemplate");

		local restrictQualityToFilter = true;
		local hideItemLevel = extraInfoColumnText ~= nil;
		local nameColumn = tableBuilder:AddFillColumn(owner, 0, 1.0, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Name, "AuctionHouseTableCellItemDisplayTemplate", restrictQualityToFilter, hideItemLevel);
		nameColumn:GetHeaderFrame():SetText(AUCTION_HOUSE_BROWSE_HEADER_NAME);

		if extraInfoColumnText then
			local extraInfoColumn = tableBuilder:AddFixedWidthColumn(owner, 0, 55, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Level, "AuctionHouseTableCellLevelTemplate");
			extraInfoColumn:GetHeaderFrame():SetText(extraInfoColumnText);
		end

		local quantityHeaderText = AuctionHouseUtil.GetHeaderNameFromSortOrder(Enum.AuctionHouseSortOrder.Quantity);
		tableBuilder:AddUnsortableFixedWidthColumn(owner, 0, quantityWidth, STANDARD_PADDING, 0, quantityHeaderText, "AuctionHouseTableCellQuantityTemplate");
		tableBuilder:AddFixedWidthColumn(owner, 0, 29, STANDARD_PADDING, 5, nil, "AuctionHouseTableCellFavoriteTemplate");
	end

	return LayoutBrowseListTableBuilder;
end

function AuctionHouseTableBuilder.GetCommoditiesBuyListLayout(owner)
	local function LayoutCommoditiesBuyListTableBuilder(tableBuilder)
		tableBuilder:AddFixedWidthColumn(owner, PRICE_DISPLAY_PADDING, PRICE_DISPLAY_WITH_CHECKMARK_WIDTH, 10, 0, nil, "AuctionHouseTableCellUnitPriceTemplate");

		tableBuilder:AddFillColumn(owner, 0, 1.0, 0, 10, nil, "AuctionHouseTableCellCommoditiesQuantityTemplate");
	end

	return LayoutCommoditiesBuyListTableBuilder;
end

function AuctionHouseTableBuilder.GetCommoditiesSellListLayout(owner, itemList)
	local function LayoutCommoditiesSellListTableBuilder(tableBuilder)
		tableBuilder:SetColumnHeaderOverlap(2);
		tableBuilder:SetHeaderContainer(itemList:GetHeaderContainer());

		local unitPriceColumn = tableBuilder:AddUnsortableFixedWidthColumn(owner, PRICE_DISPLAY_PADDING, PRICE_DISPLAY_WITH_CHECKMARK_WIDTH, STANDARD_PADDING, 0, AUCTION_HOUSE_HEADER_UNIT_PRICE, "AuctionHouseTableCellUnitPriceTemplate");
		unitPriceColumn:GetHeaderFrame():SetArrowState(AuctionHouseSortOrderState.PrimarySorted);

		local quantityColumn = tableBuilder:AddFillColumn(owner, 0, 1.0, 0, 80, nil, "AuctionHouseTableCellCommoditiesQuantityTemplate");
		quantityColumn:SetDisplayUnderPreviousHeader(true);

		tableBuilder:AddUnsortableFixedWidthColumn(owner, 0, 120, STANDARD_PADDING, 0, AUCTION_HOUSE_HEADER_SELLER, "AuctionHouseTableCellOwnersTemplate");
	end

	return LayoutCommoditiesSellListTableBuilder;
end

function AuctionHouseTableBuilder.GetItemBuyListLayout(owner, itemList)
	local function LayoutItemBuyListTableBuilder(tableBuilder)
		tableBuilder:SetColumnHeaderOverlap(2);
		tableBuilder:SetHeaderContainer(itemList:GetHeaderContainer());

		local bidColumn = tableBuilder:AddFixedWidthColumn(owner, PRICE_DISPLAY_PADDING, PRICE_DISPLAY_WIDTH, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Bid, "AuctionHouseTableCellBidTemplate");
		bidColumn:GetHeaderFrame():SetText(AUCTION_HOUSE_HEADER_CURRENT_BID);

		tableBuilder:AddFixedWidthColumn(owner, BUYOUT_DISPLAY_PADDING, PRICE_DISPLAY_WITH_CHECKMARK_WIDTH, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Buyout, "AuctionHouseTableCellBuyoutTemplate");

		tableBuilder:AddFillColumn(owner, 0, 1.0, STANDARD_PADDING, 0, nil, "AuctionHouseTableCellItemQuantityLeftTemplate");
		tableBuilder:AddFixedWidthColumn(owner, 0, 24, 0, 0, nil, "AuctionHouseTableCellExtraInfoTemplate");
		tableBuilder:AddFixedWidthColumn(owner, 0, 140, STANDARD_PADDING, STANDARD_PADDING, nil, "AuctionHouseTableCellTimeLeftBandTemplate");
	end

	return LayoutItemBuyListTableBuilder;
end

function AuctionHouseTableBuilder.GetItemSellListLayout(owner, itemList, isEquipment, isPet)
	local function LayoutItemSellListTableBuilder(tableBuilder)
		tableBuilder:SetHeaderContainer(itemList:GetHeaderContainer());
		tableBuilder:SetColumnHeaderOverlap(2);

		local buyoutLeftPadding = 0;

		-- Adjust column padding when displaying copper values
		if (C_AuctionHouse.SupportsCopperValues()) then
			buyoutLeftPadding = 20;
		end

		tableBuilder:AddFixedWidthColumn(owner, PRICE_DISPLAY_PADDING, PRICE_DISPLAY_WIDTH, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Bid, "AuctionHouseTableCellBidTemplate");
		tableBuilder:AddFillColumn(owner, BUYOUT_DISPLAY_PADDING, 1.0, buyoutLeftPadding, 0, Enum.AuctionHouseSortOrder.Buyout, "AuctionHouseTableCellItemSellBuyoutTemplate");

		if isEquipment then
			local socketColumn = tableBuilder:AddFixedWidthColumn(owner, 0, 24, 0, STANDARD_PADDING, nil, "AuctionHouseTableCellExtraInfoTemplate");
			socketColumn:SetDisplayUnderPreviousHeader(true);

			local itemLevelColumn = tableBuilder:AddFixedWidthColumn(owner, 0, 50, STANDARD_PADDING, 0, Enum.AuctionHouseSortOrder.Level, "AuctionHouseTableCellAuctionsItemLevelTemplate");
			itemLevelColumn:GetHeaderFrame():SetText(ITEM_LEVEL_ABBR);
		elseif isPet then
			tableBuilder:AddFixedWidthColumn(owner, 0, 90, 0, STANDARD_PADDING, nil, "AuctionHouseTableCellOwnersTemplate");
		else
			local hideBidStatus = true;
			local quantityColumn = tableBuilder:AddFixedWidthColumn(owner, 0, 60, 0, STANDARD_PADDING, nil, "AuctionHouseTableCellItemQuantityRightTemplate", hideBidStatus);
			quantityColumn:SetDisplayUnderPreviousHeader(true);
		end
	end

	return LayoutItemSellListTableBuilder;
end


--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseTableBuilder.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseTableBuilder.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">

	<Frame name="AuctionHouseTableEmptyTemplate" mixin="TableBuilderCellMixin" virtual="true"/>

	<Frame name="AuctionHouseTableImageTemplate" virtual="true">
		<Size x="16" y="16"/>
		<Layers>
			<Layer level="BACKGROUND">
				<Texture parentKey="Icon">
					<Size x="16" y="16"/>
					<Anchors>
						<Anchor point="LEFT"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
	</Frame>

	<Frame name="AuctionHouseTableCellTextTemplate" virtual="true">
		<Size x="0" y="16"/>
		<Layers>
			<Layer level="BACKGROUND">
				<FontString parentKey="Text" inherits="Number14FontWhite" justifyH="LEFT" setAllPoints="true"/>
			</Layer>
		</Layers>
	</Frame>

	<Frame name="AuctionHouseTableCellTextTooltipTemplate" mixin="AuctionHouseTableCellTextTooltipMixin" inherits="AuctionHouseTableCellTextTemplate" virtual="true">
		<Scripts>
			<OnEnter method="OnEnter"/>
			<OnLeave method="OnLeave"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseTableMoneyDisplayTemplate" mixin="AuctionHouseTablePriceDisplayMixin" virtual="true">
		<Size x="0" y="16"/>
		<Frames>
			<Frame parentKey="MoneyDisplay" inherits="MoneyDisplayFrameTemplate" setAllPoints="true">
				<KeyValues>
					<KeyValue key="useAuctionHouseCopperValue" value="true" type="boolean"/>
					<KeyValue key="useAuctionHouseIcons" value="true" type="boolean"/>
				</KeyValues>
			</Frame>
		</Frames>
	</Frame>

	<Frame name="AuctionHouseTableMoneyDisplayCheckmarkTemplate" inherits="AuctionHouseTableMoneyDisplayTemplate" virtual="true">
		<Size x="0" y="16"/>
		<Layers>
			<Layer level="BACKGROUND">
				<Texture parentKey="Checkmark" atlas="auctionhouse-icon-checkmark" useAtlasSize="true">
					<Size x="16" y="16"/>
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.MoneyDisplay" relativePoint="RIGHT" x="6" y="0"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
	</Frame>

	<Frame name="AuctionHouseTableCellUnitPriceTemplate" mixin="AuctionHouseTableCellUnitPriceMixin" inherits="AuctionHouseTableMoneyDisplayCheckmarkTemplate" virtual="true">
		<KeyValues>
			<KeyValue key="leftAlign" value="true" type="boolean"/>
		</KeyValues>
	</Frame>

	<Frame name="AuctionHouseTableCellCommoditiesQuantityTemplate" mixin="AuctionHouseTableCellCommoditiesQuantityMixin" inherits="AuctionHouseTableCellTextTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellFavoriteTemplate" mixin="AuctionHouseTableCellFavoriteMixin" virtual="true">
		<Frames>
			<Button parentKey="FavoriteButton" mixin="AuctionHouseTableCellFavoriteButtonMixin" inherits="AuctionHouseFavoriteButtonBaseTemplate">
				<Size x="13" y="12"/>
				<Anchors>
					<Anchor point="CENTER" relativePoint="CENTER" y="1"/>
				</Anchors>
			</Button>
		</Frames>
		<Scripts>
			<OnShow method="OnShow"/>
			<OnHide method="OnHide"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseTableCellBidTemplate" mixin="AuctionHouseTableCellBidMixin" inherits="AuctionHouseTableMoneyDisplayCheckmarkTemplate" virtual="true"/>
	
	<Frame name="AuctionHouseTableCellBuyoutTemplate" mixin="AuctionHouseTableCellBuyoutMixin" inherits="AuctionHouseTableMoneyDisplayCheckmarkTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellOwnedCheckmarkTemplate" mixin="AuctionHouseTableCellOwnedCheckmarkMixin" inherits="AuctionHouseTableImageTemplate" virtual="true"/>
	
	<Frame name="AuctionHouseTableCellExtraInfoTemplate" mixin="AuctionHouseTableExtraInfoMixin" inherits="AuctionHouseTableCellTextTemplate, AuctionHouseTableImageTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellOwnersTemplate" mixin="AuctionHouseTableCellOwnersMixin" inherits="AuctionHouseTableCellTextTooltipTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellTimeLeftTemplate" mixin="AuctionHouseTableCellTimeLeftMixin" inherits="AuctionHouseTableCellTextTooltipTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellTimeLeftBandTemplate" mixin="AuctionHouseTableCellTimeLeftBandMixin" inherits="AuctionHouseTableCellTextTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellAuctionsBuyoutTemplate" mixin="AuctionHouseTableCellAuctionsBuyoutMixin" inherits="AuctionHouseTableCellBuyoutTemplate" virtual="true"/>
	
	<Frame name="AuctionHouseTableCellAllAuctionsPriceTemplate" mixin="AuctionHouseTableCellAllAuctionsPriceMixin" virtual="true">
		<Scripts>
			<OnEnter method="OnEnter"/>
			<OnLeave method="OnLeave"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseTableCellAllAuctionsBuyoutTemplate" mixin="AuctionHouseTableCellAllAuctionsBuyoutMixin" inherits="AuctionHouseTableCellBuyoutTemplate, AuctionHouseTableCellAllAuctionsPriceTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellAuctionsBidTemplate" mixin="AuctionHouseTableCellAuctionsBidMixin" inherits="AuctionHouseTableCellBidTemplate, AuctionHouseTableCellTextTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellAllAuctionsBidTemplate" mixin="AuctionHouseTableCellAllAuctionsBidMixin" inherits="AuctionHouseTableCellBidTemplate, AuctionHouseTableCellTextTemplate, AuctionHouseTableCellAllAuctionsPriceTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellAuctionsOwnersTemplate" mixin="AuctionHouseTableCellAuctionsOwnersMixin" inherits="AuctionHouseTableCellOwnersTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellAuctionsItemLevelTemplate" mixin="AuctionHouseTableCellAuctionsItemLevelMixin" inherits="AuctionHouseTableCellTextTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellAuctionsCommoditiesQuantityTemplate" mixin="AuctionHouseTableCellAuctionsCommoditiesQuantityMixin" inherits="AuctionHouseTableCellCommoditiesQuantityTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellAuctionsUnitPriceTemplate" mixin="AuctionHouseTableCellAuctionsUnitPriceMixin" inherits="AuctionHouseTableCellUnitPriceTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellItemDisplayTemplate" mixin="AuctionHouseTableCellItemDisplayMixin" virtual="true">
		<Size x="0" y="16"/>
		<Layers>
			<Layer level="BACKGROUND" textureSubLevel="1">
				<Texture parentKey="Icon">
					<Size x="14" y="14"/>
					<Anchors>
						<Anchor point="LEFT"/>
					</Anchors>
				</Texture>
			</Layer>
			<Layer level="BACKGROUND" textureSubLevel="2">
				<Texture parentKey="IconBorder" atlas="auctionhouse-itemicon-small-border" useAtlasSize="false">
					<Size x="16" y="16"/>
					<Anchors>
						<Anchor point="CENTER" relativeKey="$parent.Icon"/>
					</Anchors>
				</Texture>

				<FontString parentKey="Text" inherits="Number14FontWhite" justifyH="LEFT" maxLines="1">
					<Size x="0" y="1"/>
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.Icon" relativePoint="RIGHT" x="4" y="-1"/>
						<Anchor point="RIGHT" x="1"/>
					</Anchors>
				</FontString>

				<!-- Will contain text that should be always displayed, if/when Text truncates -->
				<FontString parentKey="ExtraInfo" inherits="Number14FontWhite" justifyH="LEFT" maxLines="1" hidden="true">
					<Size x="0" y="1"/>
					<Anchors>
						<Anchor point="RIGHT" x="1"/>
					</Anchors>
				</FontString>
			</Layer>
		</Layers>
		<Scripts>
			<OnEvent method="OnEvent"/>
			<OnShow method="HandleItemNameTruncation"/>
			<OnHide method="OnHide"/>
			<OnSizeChanged method="HandleItemNameTruncation"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseTableCellAuctionsItemDisplayTemplate" inherits="AuctionHouseTableCellItemDisplayTemplate" mixin="AuctionHouseTableCellAuctionsItemDisplayMixin" virtual="true">
		<Layers>
			<Layer level="BACKGROUND">
				<FontString parentKey="Prefix" inherits="Number14FontWhite" justifyH="LEFT">
					<Anchors>
						<Anchor point="LEFT"/>
					</Anchors>
				</FontString>
			</Layer>
		</Layers>
	</Frame>

	<Frame name="AuctionHouseTableCellMinPriceTemplate" mixin="AuctionHouseTableCellMinPriceMixin" inherits="AuctionHouseTableCellTextTemplate, AuctionHouseTableMoneyDisplayCheckmarkTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellQuantityTemplate" mixin="AuctionHouseTableCellQuantityMixin" inherits="AuctionHouseTableCellTextTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellLevelTemplate" mixin="AuctionHouseTableCellLevelMixin" inherits="AuctionHouseTableCellTextTemplate" virtual="true">
		<Scripts>
			<OnEvent method="OnEvent"/>
			<OnHide method="OnHide"/>
		</Scripts>
	</Frame>

	<Frame name="AuctionHouseTableCellItemBuyoutTemplate" inherits="AuctionHouseTableCellBuyoutTemplate" virtual="true"/>
	
	<Frame name="AuctionHouseTableCellItemSellBuyoutTemplate" mixin="AuctionHouseTableCellItemSellBuyoutMixin" inherits="AuctionHouseTableCellTextTemplate, AuctionHouseTableCellBuyoutTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellItemQuantityLeftTemplate" mixin="AuctionHouseTableCellItemQuantityMixin" inherits="AuctionHouseTableCellTextTemplate" virtual="true"/>

	<Frame name="AuctionHouseTableCellItemQuantityRightTemplate" inherits="AuctionHouseTableCellItemQuantityLeftTemplate" virtual="true">
		<KeyValues>
			<KeyValue key="justificationH" value="RIGHT" type="string"/>
		</KeyValues>
	</Frame>

	<Button name="AuctionHouseTableHeaderStringTemplate" mixin="AuctionHouseTableHeaderStringMixin" inherits="ColumnDisplayButtonShortTemplate" virtual="true">
		<Size x="0" y="19"/>
		<Layers>
			<Layer level="OVERLAY">
				<Texture parentKey="Arrow" atlas="auctionhouse-ui-sortarrow" useAtlasSize="true">
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.Text" relativePoint="RIGHT" x="3" y="0"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
		<Scripts>
			<OnClick method="OnClick"/>
		</Scripts>
	</Button>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseTableBuilder.xml ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseUtil.lua ---


local AUCTIONABLE_TOKEN_ITEM_ID = 122270;

local WOW_TOKEN_TIME_LEFT_TOOLTIP_FORMAT = WHITE_FONT_COLOR:WrapTextInColorCode(ESTIMATED_TIME_TO_SELL_LABEL).."%s";

local RED_TEXT_MINUTES_THRESHOLD = 60;

local TIME_LEFT_ATLAS_MARKUP = CreateAtlasMarkup("auctionhouse-icon-clock", 16, 16, 2, -2);

function GetAHFilterName(filter)
	return AUCTION_HOUSE_FILTER_STRINGS[filter] or "";
end

AuctionHouseSearchContext = tInvert({
	"BrowseAll",
	"BrowseTradeGoods",
	"BrowseArmor",
	"BrowseWeapons",
	"BrowseConsumables",
	"BrowseItemEnhancements",
	"BrowseGems",
	"BrowseBattlePets",
	"BrowseRecipes",
	"BrowseQuestItems",
	"BrowseContainers",
	"BrowseGlpyhs",
	"BrowseMiscellaneous",

	"BuyItems",
	"BuyCommodities",
	"SellItems",
	"SellCommodities",
	"AuctionsItems",
	"AuctionsCommodities",
	"BidItems",

	"AllFavorites",
	"AllAuctions",
	"AllBids",
});


AuctionHouseBidStatus = {
	NoBid = 1,
	PlayerBid = 2,
	PlayerOutbid = 3,
	OtherBid = 4,
};


AuctionHouseSystemMixin = {};

function AuctionHouseSystemMixin:GetAuctionHouseFrame()
	return self:GetParent();
end


AuctionHouseSortOrderSystemMixin = CreateFromMixins(AuctionHouseSystemMixin);

function AuctionHouseSortOrderSystemMixin:OnLoad()
	self.headers = {};
end

function AuctionHouseSortOrderSystemMixin:GetSortOrderState(sortOrder)
	local searchContext = self:GetSearchContext();
	if not searchContext then
		return;
	end

	return self:GetAuctionHouseFrame():GetSortOrderState(searchContext, sortOrder);
end

function AuctionHouseSortOrderSystemMixin:SetSortOrder(sortOrder)
	local searchContext = self:GetSearchContext();
	if not searchContext then
		return;
	end

	self:GetAuctionHouseFrame():SetSortOrder(searchContext, sortOrder);

	self:UpdateHeaders();
end

function AuctionHouseSortOrderSystemMixin:UpdateHeaders()
	for i, header in ipairs(self.headers) do
		header:UpdateArrow();
	end
end

function AuctionHouseSortOrderSystemMixin:RegisterHeader(header)
	table.insert(self.headers, header);
end

function AuctionHouseSortOrderSystemMixin:SetSearchContext(searchContext)
	self.searchContext = searchContext;
end

function AuctionHouseSortOrderSystemMixin:GetSearchContext()
	return self.searchContext;
end


AuctionHouseBuySystemMixin = CreateFromMixins(AuctionHouseSystemMixin);

function AuctionHouseBuySystemMixin:OnLoad()
	assert(self.BidFrame and self.BuyoutFrame, "This mixin requires both a BidFrame and a BuyoutFrame.");
	self.BidFrame:SetBidCallback(function ()
		self:PlaceBid();
	end);


	self.BuyoutFrame:SetBuyoutCallback(function ()
		self:BuyoutItem();
	end);
end

function AuctionHouseBuySystemMixin:PlaceBid()
	if not self.auctionID then
		return;
	end

	local bidAmount = self.BidFrame:GetPrice();
	if self:GetBuyoutAmount() ~= 0 and bidAmount >= self:GetBuyoutAmount() then
		self:BuyoutItem();
	elseif bidAmount < self.minBid then
		UIErrorsFrame:AddExternalErrorMessage(AUCTION_HOUSE_BID_AMOUNT_IS_TOO_LOW);
	else
		self:GetAuctionHouseFrame():StartItemBid(self.auctionID, bidAmount);
	end
end

function AuctionHouseBuySystemMixin:BuyoutItem()
	if self.auctionID then
		self:GetAuctionHouseFrame():StartItemBuyout(self.auctionID, self:GetBuyoutAmount());
	end
end

function AuctionHouseBuySystemMixin:SetAuctionID(auctionID)
	self.auctionID = auctionID;
end

function AuctionHouseBuySystemMixin:SetPrice(minBid, buyoutPrice, isOwnerItem, isPlayerHighBid)
	minBid = minBid or 0;
	buyoutPrice = buyoutPrice or 0;

	self.minBid = minBid;
	self.BidFrame:SetPrice(minBid, isOwnerItem, isPlayerHighBid);
	self.BuyoutFrame:SetPrice(buyoutPrice, isOwnerItem);
end

function AuctionHouseBuySystemMixin:SetAuction(auctionID, minBid, buyoutPrice, isOwnerItem, bidder)
	local isPlayerHighBid = bidder == UnitGUID("player");
	self:SetAuctionID(auctionID);
	self:SetPrice(minBid, buyoutPrice, isOwnerItem, isPlayerHighBid);
end

function AuctionHouseBuySystemMixin:ResetPrice()
	self:SetPrice(0);
end

function AuctionHouseBuySystemMixin:GetBidAmount()
	return self.BidFrame:GetPrice()
end

function AuctionHouseBuySystemMixin:GetBuyoutAmount()
	return self.BuyoutFrame:GetPrice()
end


AuctionHouseUtil = {};

function AuctionHouseUtil.ConvertCategoryToSearchContext(selectedCategoryIndex)
	if selectedCategoryIndex == nil then
		return AuctionHouseSearchContext.BrowseAll;
	end

	local categoryName = AuctionCategories[selectedCategoryIndex].name;
	if categoryName == AUCTION_CATEGORY_WEAPONS then
		return AuctionHouseSearchContext.BrowseWeapons;
	elseif categoryName == AUCTION_CATEGORY_ARMOR then
		return AuctionHouseSearchContext.BrowseArmor;
	elseif categoryName == AUCTION_CATEGORY_CONTAINERS then
		return AuctionHouseSearchContext.BrowseContainers;
	elseif categoryName == AUCTION_CATEGORY_GEMS then
		return AuctionHouseSearchContext.BrowseGems;
	elseif categoryName == AUCTION_CATEGORY_ITEM_ENHANCEMENT then
		return AuctionHouseSearchContext.BrowseItemEnhancements;
	elseif categoryName == AUCTION_CATEGORY_CONSUMABLES then
		return AuctionHouseSearchContext.BrowseConsumables;
	elseif categoryName == AUCTION_CATEGORY_GLYPHS then
		return AuctionHouseSearchContext.BrowseGlpyhs;
	elseif categoryName == AUCTION_CATEGORY_TRADE_GOODS then
		return AuctionHouseSearchContext.BrowseTradeGoods;
	elseif categoryName == AUCTION_CATEGORY_RECIPES then
		return AuctionHouseSearchContext.BrowseRecipes;
	elseif categoryName == AUCTION_CATEGORY_BATTLE_PETS then
		return AuctionHouseSearchContext.BrowseBattlePets;
	elseif categoryName == AUCTION_CATEGORY_QUEST_ITEMS then
		return AuctionHouseSearchContext.BrowseQuestItems;
	elseif categoryName == AUCTION_CATEGORY_MISCELLANEOUS then
		return AuctionHouseSearchContext.BrowseMiscellaneous;
	end

	return AuctionHouseSearchContext.BrowseAll;
end

function AuctionHouseUtil.AggregateSearchResultsByQuantity(itemID, quantity)
	local remainingQuantity = quantity;
	local totalQuantity = 0;
	local totalPrice = 0;
	local numResultsAggregated = 0;
	local partiallyPurchased = false;
	for searchResultIndex = 1, C_AuctionHouse.GetNumCommoditySearchResults(itemID) do
		numResultsAggregated = numResultsAggregated + 1;
		local searchResult = C_AuctionHouse.GetCommoditySearchResultInfo(itemID, searchResultIndex);
		if searchResult then
			local quantityAvailable = searchResult.quantity - searchResult.numOwnerItems;
			local quantityToBuy = math.min(quantityAvailable, remainingQuantity);
			totalPrice = totalPrice + (searchResult.unitPrice * quantityToBuy);
			totalQuantity = totalQuantity + quantityToBuy;
			remainingQuantity = remainingQuantity - quantityToBuy;
			if remainingQuantity <= 0 then
				partiallyPurchased = quantityToBuy ~= quantityAvailable;
				break;
			end
		end
	end
	
	return totalQuantity, totalPrice, numResultsAggregated, partiallyPurchased;
end

function AuctionHouseUtil.AggregateCommoditySearchResultsByMaxPrice(itemID, maxPrice)
	local totalQuantity = 0;
	local totalPrice = 0;
	for searchResultIndex = 1, C_AuctionHouse.GetNumCommoditySearchResults(itemID) do
		local searchResult = C_AuctionHouse.GetCommoditySearchResultInfo(itemID, searchResultIndex);
		if not searchResult or searchResult.unitPrice > maxPrice then
			break;
		end

		local quantityAvailable = searchResult.quantity - searchResult.numOwnerItems;
		totalPrice = totalPrice + (searchResult.unitPrice * quantityAvailable);
		totalQuantity = totalQuantity + quantityAvailable;
	end
	
	return totalQuantity, totalPrice;
end

function AuctionHouseUtil.GetTimeLeftBandText(timeLeftBand)
	if timeLeftBand == Enum.AuctionHouseTimeLeftBand.Short then
		return RED_FONT_COLOR:WrapTextInColorCode(TIME_LEFT_SHORT);
	elseif timeLeftBand == Enum.AuctionHouseTimeLeftBand.Medium then
		return GRAY_FONT_COLOR:WrapTextInColorCode(TIME_LEFT_MEDIUM);
	elseif timeLeftBand == Enum.AuctionHouseTimeLeftBand.Long then
		return GRAY_FONT_COLOR:WrapTextInColorCode(TIME_LEFT_LONG);
	elseif timeLeftBand == Enum.AuctionHouseTimeLeftBand.VeryLong then
		return GRAY_FONT_COLOR:WrapTextInColorCode(TIME_LEFT_VERY_LONG);
	end

	return "";
end

function AuctionHouseUtil.GetTooltipTimeLeftBandText(rowData)
	local isToken = AuctionHouseUtil.RowDataIsWoWToken(rowData);
	local timeLeftFormat = isToken and WOW_TOKEN_TIME_LEFT_TOOLTIP_FORMAT or "%s";

	local timeLeftBand = rowData.timeLeft;
	if timeLeftBand == Enum.AuctionHouseTimeLeftBand.Short then
		return timeLeftFormat:format(AUCTION_HOUSE_TOOLTIP_TIME_LEFT_SHORT);
	elseif timeLeftBand == Enum.AuctionHouseTimeLeftBand.Medium then
		return timeLeftFormat:format(AUCTION_HOUSE_TOOLTIP_TIME_LEFT_MEDIUM);
	elseif timeLeftBand == Enum.AuctionHouseTimeLeftBand.Long then
		return timeLeftFormat:format(AUCTION_HOUSE_TOOLTIP_TIME_LEFT_LONG);
	elseif timeLeftBand == Enum.AuctionHouseTimeLeftBand.VeryLong then
		return timeLeftFormat:format(AUCTION_HOUSE_TOOLTIP_TIME_LEFT_VERY_LONG);
	end

	return "";
end

function AuctionHouseUtil.AddSellersToTooltip(tooltip, sellers, totalNumberOfSellers)
	local sellersString = sellers[1] == "player" and GREEN_FONT_COLOR:WrapTextInColorCode(AUCTION_HOUSE_SELLER_YOU) or sellers[1];
	local numSellers = #sellers;
	if numSellers > 1 then
		for i = 2, numSellers do
			sellersString = sellersString..PLAYER_LIST_DELIMITER..sellers[i];
		end

		local wrap = true;
		if totalNumberOfSellers > numSellers then
			GameTooltip_AddNormalLine(tooltip, AUCTION_HOUSE_TOOLTIP_OVERFLOW_SELLERS_FORMAT:format(sellersString, totalNumberOfSellers - numSellers), wrap);
		else
			GameTooltip_AddNormalLine(tooltip, AUCTION_HOUSE_TOOLTIP_MULTIPLE_SELLERS_FORMAT:format(sellersString), wrap);
		end
	elseif numSellers > 0 then
		local wrap = true;
		GameTooltip_AddNormalLine(tooltip, AUCTION_HOUSE_TOOLTIP_SELLER_FORMAT:format(sellersString), wrap);
	end
end

function AuctionHouseUtil.AddAuctionHouseTooltipInfo(tooltip, rowData, bidStatus)
	GameTooltip_AddBlankLineToTooltip(tooltip);

	AuctionHouseUtil.AddSellersToTooltip(tooltip, rowData.owners, rowData.totalNumberOfOwners);

	tooltip:AddLine(AUCTION_HOUSE_TOOLTIP_DURATION_FORMAT:format(AuctionHouseUtil.GetTooltipTimeLeftBandText(rowData)));

	if bidStatus and (bidStatus == AuctionHouseBidStatus.PlayerBid or bidStatus == AuctionHouseBidStatus.PlayerOutbid) then
		tooltip:AddLine(AuctionHouseUtil.GetBidTextFromStatus(bidStatus));
	end
end

function AuctionHouseUtil.GetItemDisplayText(itemName, itemLevel)
	if itemLevel then
		return AUCTION_HOUSE_EQUIPMENT_RESULT_FORMAT:format(itemName, itemLevel);
	end

	return itemName;
end

function AuctionHouseUtil.GetItemDisplayTextFromItemKey(itemKey, itemKeyInfo, hideItemLevel)
	local shouldDisplayItemLevel = itemKeyInfo.isEquipment and itemKey.itemLevel and not hideItemLevel;
	local itemDisplayText = AuctionHouseUtil.GetItemDisplayText(itemKeyInfo.itemName, shouldDisplayItemLevel and itemKey.itemLevel or nil);
	local itemQuality = itemKeyInfo.quality;

	local colorData = ColorManager.GetColorDataForItemQuality(itemQuality);
	if colorData then
		return colorData.color:WrapTextInColorCode(itemDisplayText);
	end

	return itemDisplayText;
end

function AuctionHouseUtil.GetItemQualityColorFromOwnedAuctionData(ownedAuctionData, itemKeyInfo)
	if ownedAuctionData.status == Enum.AuctionStatus.Sold then
		return GRAY_FONT_COLOR;
	end

	local itemQuality = itemKeyInfo.quality;
	local itemLink = ownedAuctionData.itemLink;
	if itemLink ~= nil then
		if LinkUtil.IsLinkType(itemLink, "battlepet") then
			itemQuality = select(3, BattlePetToolTip_UnpackBattlePetLink(itemLink)) or itemQuality;
		else
			itemQuality = select(3, C_Item.GetItemInfo(itemLink)) or itemQuality;
		end
	end

	local colorData = ColorManager.GetColorDataForItemQuality(itemQuality);
	if colorData then
		return colorData.color;
	end

	return WHITE_FONT_COLOR;
end

function AuctionHouseUtil.GetQuantityDisplayTextFromOwnedAuctionData(ownedAuctionData)
	local quantityDisplayText = nil;

	if ownedAuctionData.quantity and ownedAuctionData.quantity > 1 then
		quantityDisplayText = AUCTION_HOUSE_ITEM_QUANTITY_FORMAT:format(BreakUpLargeNumbers(ownedAuctionData.quantity));
	end
	
	return quantityDisplayText;
end

function AuctionHouseUtil.GetDisplayTextFromOwnedAuctionData(ownedAuctionData, itemKeyInfo, hideItemLevel)
	local itemKey = ownedAuctionData.itemKey;
	local shouldDisplayItemLevel = itemKeyInfo.isEquipment and itemKey.itemLevel and not hideItemLevel;
	local itemDisplayText = AuctionHouseUtil.GetItemDisplayText(itemKeyInfo.itemName, shouldDisplayItemLevel and itemKey.itemLevel or nil);

	local itemQualityColor = AuctionHouseUtil.GetItemQualityColorFromOwnedAuctionData(ownedAuctionData, itemKeyInfo);
	return itemQualityColor:WrapTextInColorCode(itemDisplayText);
end

function AuctionHouseUtil.GetSellersString(rowData)
	local sellers = rowData.owners;
	if #sellers == 0 then
		return "";
	elseif #sellers == 1 then
		return rowData.containsOwnerItem and WHITE_FONT_COLOR:WrapTextInColorCode(AUCTION_HOUSE_SELLER_YOU) or sellers[1];
	else
		return AUCTION_HOUSE_NUM_SELLERS:format(rowData.totalNumberOfOwners);
	end
end

AuctionHouseUtil.TimeLeftTooltipFormatter = CreateFromMixins(SecondsFormatterMixin);
AuctionHouseUtil.TimeLeftTooltipFormatter:Init(0, SecondsFormatter.Abbreviation.Truncate, true);

function AuctionHouseUtil.FormatTimeLeftTooltip(timeLeftSeconds, rowData)
	local useNormalFontColor = (rowData.status == Enum.AuctionStatus.Sold) or AuctionHouseUtil.RowDataIsWoWToken(rowData);
	local timeLeftMinutes = math.ceil(timeLeftSeconds / 60);
	local color = (useNormalFontColor or timeLeftMinutes >= RED_TEXT_MINUTES_THRESHOLD) and WHITE_FONT_COLOR or RED_FONT_COLOR;
	local text = color:WrapTextInColorCode(AuctionHouseUtil.TimeLeftTooltipFormatter:Format(timeLeftSeconds));
	return sold and AUCTION_HOUSE_TIME_LEFT_FORMAT_SOLD:format(text) or AUCTION_HOUSE_TIME_LEFT_FORMAT_ACTIVE:format(text);
end

AuctionHouseUtil.TimeLeftFormatter = CreateFromMixins(SecondsFormatterMixin);
AuctionHouseUtil.TimeLeftFormatter:Init(0, SecondsFormatter.Abbreviation.OneLetter, true);
AuctionHouseUtil.TimeLeftFormatter:SetStripIntervalWhitespace(true);

function AuctionHouseUtil.TimeLeftFormatter:GetDesiredUnitCount(seconds)
	return 1;
end

function AuctionHouseUtil.TimeLeftFormatter:GetMinInterval(seconds)
	return SecondsFormatter.Interval.Minutes;
end

function AuctionHouseUtil.FormatTimeLeft(timeLeftSeconds, rowData)
	local useNormalFontColor = (rowData.status == Enum.AuctionStatus.Sold) or AuctionHouseUtil.RowDataIsWoWToken(rowData);
	local timeLeftMinutes = math.ceil(timeLeftSeconds / 60);
	local color = (useNormalFontColor or timeLeftMinutes >= RED_TEXT_MINUTES_THRESHOLD) and GRAY_FONT_COLOR or RED_FONT_COLOR;
	local text = AuctionHouseUtil.TimeLeftFormatter:Format(timeLeftSeconds);
	return color:WrapTextInColorCode(text);
end

function AuctionHouseUtil.SetBidsFrameBidTextColor(moneyFrame, bidStatus)
	if bidStatus == AuctionHouseBidStatus.PlayerBid then
		moneyFrame:SetFontObject(PriceFontGreen);
	elseif bidStatus == AuctionHouseBidStatus.PlayerOutbid then
		moneyFrame:SetFontObject(PriceFontRed);
	else
		moneyFrame:SetFontObject(PriceFontGray);
	end
end

function AuctionHouseUtil.SetOwnedAuctionBidTextColor(moneyFrame, ownedAuctionInfo)
	moneyFrame:SetFontObject(ownedAuctionInfo.bidder and PriceFontGreen or PriceFontGray);
end

function AuctionHouseUtil.ConvertBidStatusToText(bidStatus)
	if bidStatus == AuctionHouseBidStatus.PlayerBid then
		return AUCTION_HOUSE_HIGHEST_BIDDER;
	elseif bidStatus == AuctionHouseBidStatus.PlayerOutbid then
		return AUCTION_HOUSE_OUTBID;
	else
		return "";
	end
end

function AuctionHouseUtil.GetBidTextFromStatus(bidStatus)
	local highestBidder = bidStatus == AuctionHouseBidStatus.PlayerBid;
	local color = highestBidder and GREEN_FONT_COLOR or RED_FONT_COLOR;
	local text = AuctionHouseUtil.ConvertBidStatusToText(bidStatus);
	return color:WrapTextInColorCode(text);
end

function AuctionHouseUtil.GetHeaderNameFromSortOrder(sortOrder)
	if sortOrder == Enum.AuctionHouseSortOrder.Price then
		return AUCTION_HOUSE_BROWSE_HEADER_PRICE;
	elseif sortOrder == Enum.AuctionHouseSortOrder.Name then
		return AUCTION_HOUSE_HEADER_ITEM;
	elseif sortOrder == Enum.AuctionHouseSortOrder.Quantity then
		return AUCTION_HOUSE_BROWSE_HEADER_QUANTITY;
	elseif sortOrder == Enum.AuctionHouseSortOrder.Bid then
		return AUCTION_HOUSE_HEADER_BID_PRICE;
	elseif sortOrder == Enum.AuctionHouseSortOrder.Buyout then
		return AUCTION_HOUSE_HEADER_BUYOUT_PRICE;
	elseif sortOrder == Enum.AuctionHouseSortOrder.TimeRemaining then
		return TIME_LEFT_ATLAS_MARKUP;
	-- Note: Level is contextual and must be set manually.
	-- elseif sortOrder == Enum.AuctionHouseSortOrder.Level then
	end

	return "";
end

function AuctionHouseUtil.ConvertItemSellItemKey(itemKey)
	if itemKey == nil then
		return itemKey;
	end

	local itemKeyInfo = C_AuctionHouse.GetItemKeyInfo(itemKey);
	if itemKeyInfo and itemKeyInfo.isEquipment then
		-- Item keys for equipment you're selling have no item level or suffix so you can compare to similar items.
		itemKey.itemLevel = 0;
		itemKey.itemSuffix = 0;
		return itemKey;
	end

	return itemKey;
end

function AuctionHouseUtil.AppendBattlePetVariationLines(tooltip)
	GameTooltip_AddBlankLineToTooltip(tooltip);

	local wrap = true;
	GameTooltip_AddNormalLine(tooltip, AUCTION_HOUSE_BUCKET_VARIATION_PET_TOOLTIP, wrap);
end

function AuctionHouseUtil.LineOnUpdate(line)
	if IsModifiedClick("DRESSUP") then
		ShowInspectCursor();
	else
		ResetCursor();
	end
end

function AuctionHouseUtil.LineOnEnterCallback(line, rowData)
	line:SetScript("OnUpdate", AuctionHouseUtil.LineOnUpdate);

	AuctionHouseUtil.SetAuctionHouseTooltip(line, rowData);

	if IsModifiedClick("DRESSUP") then
		ShowInspectCursor();
	end

	line.UpdateTooltip = function(self)
		AuctionHouseUtil.LineOnEnterCallback(self, rowData);
	end;
end

function AuctionHouseUtil.LineOnLeaveCallback(line, rowData)
	line:SetScript("OnUpdate", nil);

	ResetCursor();
	GameTooltip_Hide();
end

function AuctionHouseUtil.GetItemLinkFromRowData(rowData)
	if rowData.itemLink then
		return rowData.itemLink;
	else
		local itemID = rowData.itemID or rowData.itemKey.itemID;
		if itemID ~= nil then
			local itemLink = select(2, C_Item.GetItemInfo(itemID));
			return itemLink;
		end
	end

	return nil;
end

function AuctionHouseUtil.GenerateRowSelectedCallbackWithInspect(self, selectionCallback)
	local function RowSelectedCallback(rowData)
		if rowData and IsModifiedClick("DRESSUP") then
			local itemLink = AuctionHouseUtil.GetItemLinkFromRowData(rowData);
			if itemLink ~= nil then
				DressUpLink(itemLink);
				return false;
			end
		elseif rowData and IsModifiedClick("CHATLINK") then
			local itemLink = AuctionHouseUtil.GetItemLinkFromRowData(rowData);
			if itemLink ~= nil then
				ChatEdit_InsertLink(itemLink);
				return false;
			end
		end

		selectionCallback(self, rowData);
		return true;
	end

	return RowSelectedCallback;
end

function AuctionHouseUtil.GenerateRowSelectedCallbackWithLink(self, selectionCallback)
	local function RowSelectedCallback(rowData)
		if rowData and IsModifiedClick("CHATLINK") then
			ChatEdit_InsertLink(AuctionHouseUtil.GetItemLinkFromRowData(rowData));
			return false;
		end

		selectionCallback(self, rowData);
		return true;
	end

	return RowSelectedCallback;
end

function AuctionHouseUtil.CompareItemKeys(lhsItemKey, rhsItemKey)
	return tCompare(lhsItemKey, rhsItemKey);
end

function AuctionHouseUtil.HasBidType(itemKey)
	for i = 1, C_AuctionHouse.GetNumBidTypes() do
		local bidItemKey = C_AuctionHouse.GetBidType(i);
		if AuctionHouseUtil.CompareItemKeys(bidItemKey, itemKey) then
			return true, i;
		end
	end

	return false;
end

function AuctionHouseUtil.HasOwnedAuctionType(itemKey)
	for i = 1, C_AuctionHouse.GetNumOwnedAuctionTypes() do
		local ownedAuctionItemKey = C_AuctionHouse.GetOwnedAuctionType(i);
		if AuctionHouseUtil.CompareItemKeys(ownedAuctionItemKey, itemKey) then
			return true, i;
		end
	end

	return false;
end

function AuctionHouseUtil.IsOwnedAuction(rowData)
	return (#rowData.owners == 1 and (rowData.containsOwnerItem or rowData.containsAccountItem)) or
			(#rowData.owners == 2 and (rowData.containsOwnerItem and rowData.containsAccountItem));
end

function AuctionHouseUtil.SanitizeAuctionHousePrice(rawPrice)
	if ( not C_AuctionHouse.SupportsCopperValues() ) then
		return math.ceil(rawPrice / COPPER_PER_SILVER) * COPPER_PER_SILVER;
	else
		return math.ceil(rawPrice);
	end	
end

function AuctionHouseUtil.RowDataIsWoWToken(rowData)
	return (rowData.itemID == AUCTIONABLE_TOKEN_ITEM_ID) or (rowData.itemKey and rowData.itemKey.itemID == AUCTIONABLE_TOKEN_ITEM_ID);
end

function AuctionHouseUtil.CreateVirtualRowData(virtualEntryText, isSelectedVirtualEntry)
	return { isVirtualEntry = true, virtualEntryText = virtualEntryText, isSelectedVirtualEntry = isSelectedVirtualEntry, };
end

local AuctionHouseErrorToErrorText = {
	[Enum.AuctionHouseError.NotEnoughMoney] = ERR_NOT_ENOUGH_MONEY,
	[Enum.AuctionHouseError.HigherBid] = ERR_AUCTION_HIGHER_BID,
	[Enum.AuctionHouseError.BidIncrement] = ERR_AUCTION_BID_INCREMENT,
	[Enum.AuctionHouseError.BidOwn] = ERR_AUCTION_BID_OWN,
	[Enum.AuctionHouseError.ItemNotFound] = ERR_ITEM_NOT_FOUND,
	[Enum.AuctionHouseError.RestrictedAccountTrial] = ERR_RESTRICTED_ACCOUNT_TRIAL,
	[Enum.AuctionHouseError.HasRestriction] = ERR_HAS_RESTRICTION,
	[Enum.AuctionHouseError.IsBusy] = ERR_AUCTION_HOUSE_BUSY,
	[Enum.AuctionHouseError.Unavailable] = ERR_AUCTION_HOUSE_UNAVAILABLE,
	[Enum.AuctionHouseError.ItemHasQuote] = ERR_AUCTION_ITEM_HAS_QUOTE,
	[Enum.AuctionHouseError.DatabaseError] = ERR_AUCTION_DATABASE_ERROR,
	[Enum.AuctionHouseError.MinBid] = ERR_AUCTION_MIN_BID,
	[Enum.AuctionHouseError.NotEnoughItems] = ERR_AUCTION_ENOUGH_ITEMS,
	[Enum.AuctionHouseError.RepairItem] = ERR_AUCTION_REPAIR_ITEM,
	[Enum.AuctionHouseError.UsedCharges] = ERR_AUCTION_USED_CHARGES,
	[Enum.AuctionHouseError.QuestItem] = ERR_AUCTION_QUEST_ITEM,
	[Enum.AuctionHouseError.BoundItem] = ERR_AUCTION_BOUND_ITEM,
	[Enum.AuctionHouseError.ConjuredItem] = ERR_AUCTION_CONJURED_ITEM,
	[Enum.AuctionHouseError.LimitedDurationItem] = ERR_AUCTION_LIMITED_DURATION_ITEM,
	[Enum.AuctionHouseError.IsBag] = ERR_AUCTION_BAG,
	[Enum.AuctionHouseError.EquippedBag] = ERR_AUCTION_EQUIPPED_BAG,
	[Enum.AuctionHouseError.WrappedItem] = ERR_AUCTION_WRAPPED_ITEM,
	[Enum.AuctionHouseError.LootItem] = ERR_AUCTION_LOOT_ITEM,
	[Enum.AuctionHouseError.DoubleBid] = ERR_AUCTION_DOUBLE_BID,
	[Enum.AuctionHouseError.ItemBoundToAccountUntilEquip] = ERR_NOT_SAME_ACCOUNT,
};

function AuctionHouseUtil.GetErrorText(auctionHouseError)
	return AuctionHouseErrorToErrorText[auctionHouseError] or "";
end

local UniqueShadowlandsCraftedLimitCategoryID = 481;
function AuctionHouseUtil.IsAuctionIDUniqueShadowlandsCrafted(auctionID)
	local auctionInfo = C_AuctionHouse.GetAuctionInfoByID(auctionID);
	local itemLink = (auctionInfo ~= nil) and auctionInfo.itemLink or nil;
	if itemLink == nil then
		return false;
	end

	local categoryName, categoryCount, uniqueLimitCategory = select(2, C_Item.GetItemUniquenessByID(itemLink));
	categoryName = ((categoryName ~= nil) and (categoryCount ~= nil)) and ITEM_LIMIT_CATEGORY_MULTIPLE:format(categoryName, categoryCount) or categoryName;
	local isUniqueShadowlandsCrafted = uniqueLimitCategory == UniqueShadowlandsCraftedLimitCategoryID;
	return isUniqueShadowlandsCrafted, categoryName;
end

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseUtil.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseWoWTokenFrame.lua ---


StaticPopupDialogs["TOKEN_NONE_FOR_SALE"] = {
	text = TOKEN_NONE_FOR_SALE,
	button1 = OKAY,
	timeout = 0,
	exclusive = 1,
	hideOnEscape = true,
}

StaticPopupDialogs["TOKEN_AUCTIONABLE_TOKEN_OWNED"] = {
	text = TOKEN_AUCTIONABLE_TOKEN_OWNED,
	button1 = OKAY,
	timeout = 0,
	exclusive = 1,
	hideOnEscape = true,
}


function BrowseWowTokenResults_OnLoad(self)
	AuctionHouseBackgroundMixin.OnLoad(self);

	self:RegisterEvent("TOKEN_MARKET_PRICE_UPDATED");
	self:RegisterEvent("TOKEN_STATUS_CHANGED");
	self:RegisterEvent("TOKEN_BUY_RESULT");
	self:RegisterEvent("PLAYER_MONEY");

	self.TokenDisplay:SetItem(WOW_TOKEN_ITEM_ID);
	self.TokenDisplay.NineSlice:Hide();

	self.HelpButton.Ring:Hide();

	self.HelpButton:SetScript("OnEnter", function()
		GameTooltip:SetOwner(self.HelpButton, "ANCHOR_RIGHT",-22,-22);
		GameTooltip:SetText(TUTORIAL_TOKEN_ABOUT_TOKENS);
		GameTooltip:Show();
	end);

	self.HelpButton:SetScript("OnLeave", function()
		GameTooltip_Hide();
	end);

	self.HelpButton:SetScript("OnClick", function()
		local gameTimeTutorial = self.HelpButton:GetParent().GameTimeTutorial;
		gameTimeTutorial:SetShown(not gameTimeTutorial:IsShown());
	end);
end

function BrowseWowTokenResults_OnShow(self)
	self.disabled = not C_WowTokenPublic.GetCommerceSystemStatus();

	AuctionWowToken_UpdateMarketPrice();
	BrowseWowTokenResults_Update(self);
end

function BrowseWowTokenResults_OnHide(self)
	self.GameTimeTutorial:Hide();
end

function BrowseWowTokenResults_OnUpdate(self, elapsed)
	local now = GetTime();

	local remaining = 60 - (now - self.timeStarted);
	if (remaining < 1) then
		GameTooltip:Hide();
		self:SetScript("OnUpdate", nil);
		self.noneForSale = false;
		self.timeStarted = nil;
		self.Buyout.tooltip = nil;
	else
		self.Buyout.tooltip = TOKEN_TRY_AGAIN_LATER:format(INT_SPELL_DURATION_SEC:format(math.floor(remaining)));
		if (GameTooltip:GetOwner() == self.Buyout) then
			GameTooltip:SetText(self.Buyout.tooltip);
		end
	end
	BrowseWowTokenResults_Update(self);
end

function BrowseWowTokenResults_OnEvent(self, event, ...)
	if (event == "TOKEN_MARKET_PRICE_UPDATED") then
		local result = ...;
		if (result == LE_TOKEN_RESULT_ERROR_DISABLED) then
			self.disabled = true;
		end
		BrowseWowTokenResults_Update(self);
	elseif (event == "TOKEN_STATUS_CHANGED") then
		self.disabled = not C_WowTokenPublic.GetCommerceSystemStatus();
		AuctionWowToken_UpdateMarketPrice();
		BrowseWowTokenResults_Update(self);
	elseif (event == "TOKEN_BUY_RESULT") then
		local result = ...;
		if (result == LE_TOKEN_RESULT_ERROR_DISABLED) then
			self.disabled = true;
		elseif (result == LE_TOKEN_RESULT_ERROR_NONE_FOR_SALE) then
			self.noneForSale = true;
			StaticPopup_Show("TOKEN_NONE_FOR_SALE");
			self.timeStarted = GetTime();
			self:SetScript("OnUpdate", BrowseWowTokenResults_OnUpdate);
		elseif (result == LE_TOKEN_RESULT_ERROR_AUCTIONABLE_TOKEN_OWNED) then
			StaticPopup_Show("TOKEN_AUCTIONABLE_TOKEN_OWNED");
		elseif (result == LE_TOKEN_RESULT_ERROR_TOO_MANY_TOKENS) then
			UIErrorsFrame:AddMessage(SPELL_FAILED_TOO_MANY_OF_ITEM, 1.0, 0.1, 0.1, 1.0);
		elseif (result == LE_TOKEN_RESULT_ERROR_TRIAL_RESTRICTED) then
			UIErrorsFrame:AddMessage(ERR_RESTRICTED_ACCOUNT_TRIAL, 1.0, 0.1, 0.1, 1.0);
		elseif (result == LE_TOKEN_RESULT_ERROR_NOT_ENOUGH_PURCHASED_GAME_TIME) then
			UIErrorsFrame:AddMessage(ERR_NOT_ENOUGH_PURCHASED_GAME_TIME, 1.0, 0.1, 0.1, 1.0);
		elseif (result ~= LE_TOKEN_RESULT_SUCCESS) then
			UIErrorsFrame:AddMessage(ERR_AUCTION_DATABASE_ERROR, 1.0, 0.1, 0.1, 1.0);
		else
			local info = ChatTypeInfo["SYSTEM"];
			local itemName = C_Item.GetItemInfo(WOW_TOKEN_ITEM_ID);
			DEFAULT_CHAT_FRAME:AddMessage(ERR_AUCTION_WON_S:format(itemName), info.r, info.g, info.b, info.id);
			C_WowTokenPublic.UpdateTokenCount();
		end
	elseif ( event == "PLAYER_MONEY" ) then
		BrowseWowTokenResults_Update(self);
	end
end

local function GetFormattedWoWTokenPrice(price)
	local gold = price / COPPER_PER_GOLD;
	if ( CVarCallbackRegistry:GetCVarValueBool("colorblindMode") ) then
		return FormatLargeNumber(gold)..GOLD_AMOUNT_SYMBOL;
	else
		local xOffset = 2;
		return FormatLargeNumber(gold)..CreateAtlasMarkup("coin-gold", nil, nil, xOffset);
	end
end

function BrowseWowTokenResults_Update(self)
	if (not GetCVarBitfield("closedInfoFrames", LE_FRAME_TUTORIAL_GAME_TIME_AUCTION_HOUSE) and C_WowTokenPublic.GetCommerceSystemStatus()) then
		self.GameTimeTutorial:Show();
		SetCVarBitfield("closedInfoFrames", LE_FRAME_TUTORIAL_GAME_TIME_AUCTION_HOUSE, true);
	end
	local marketPrice;
	if (WowToken_IsWowTokenAuctionDialogShown()) then
		marketPrice = C_WowTokenPublic.GetGuaranteedPrice();
	else
		marketPrice = C_WowTokenPublic.GetCurrentMarketPrice();
	end

	if (self.disabled) then
		self.BuyoutPrice:SetText(TOKEN_AUCTIONS_UNAVAILABLE);
		self.BuyoutPrice:SetFontObject(GameFontRed);
		self.InvisiblePriceFrame:Hide();
		self.Buyout:SetEnabled(false);
	elseif (not marketPrice) then
		self.BuyoutPrice:SetText(TOKEN_MARKET_PRICE_NOT_AVAILABLE);
		self.BuyoutPrice:SetFontObject(GameFontRed);
		self.InvisiblePriceFrame:Hide();
		self.Buyout:SetEnabled(false);
	elseif (self.noneForSale) then
		self.BuyoutPrice:SetText(GetFormattedWoWTokenPrice(marketPrice));
		self.BuyoutPrice:SetFontObject(PriceFontWhite);
		self.InvisiblePriceFrame:Show();
		self.Buyout:SetEnabled(false);
	else
		self.BuyoutPrice:SetText(GetFormattedWoWTokenPrice(marketPrice));
		self.BuyoutPrice:SetFontObject(PriceFontWhite);
		self.InvisiblePriceFrame:Show();
		if (GetMoney() < marketPrice) then
			self.Buyout:SetEnabled(false);
			self.Buyout.tooltip = ERR_NOT_ENOUGH_GOLD;
		else
			self.Buyout:SetEnabled(true);
			self.Buyout.tooltip = nil;
		end
	end
end

function BrowseWowTokenResultsBuyout_OnClick(self)
	C_WowTokenPublic.BuyToken();
	PlaySound(SOUNDKIT.IG_MAINMENU_OPEN);
end

function BrowseWowTokenResultsBuyout_OnEnter(self)
	if (self.tooltip) then
		GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
		GameTooltip:SetText(self.tooltip);
		GameTooltip:Show();
	end
end


WoWTokenSellFrameMixin = CreateFromMixins(AuctionHouseSystemMixin);

function WoWTokenSellFrameMixin:OnLoad()
	AuctionHouseBackgroundMixin.OnLoad(self);

	self.ItemDisplay:SetOnItemChangedCallback(function(item)
		if item == nil then
			self:GetAuctionHouseFrame():SetDisplayMode(AuctionHouseFrameDisplayMode.ItemSell);
		else
			self:GetAuctionHouseFrame():SetPostItem(item);
		end
	end);

	self:RegisterEvent("TOKEN_MARKET_PRICE_UPDATED");
	self:RegisterEvent("TOKEN_STATUS_CHANGED");
	self:RegisterEvent("TOKEN_SELL_RESULT");
	self:RegisterEvent("TOKEN_AUCTION_SOLD");
	self:RegisterEvent("TOKEN_SELL_CONFIRMED");

	self.DummyRefreshButton:SetEnabledState(false);
end

function WoWTokenSellFrameMixin:OnShow()
	self.disabled = not C_WowTokenPublic.GetCommerceSystemStatus();
	self:Refresh();
end

function WoWTokenSellFrameMixin:OnEvent(event, ...)
	if (event == "TOKEN_MARKET_PRICE_UPDATED") then
		local result = ...;
		if (result == LE_TOKEN_RESULT_ERROR_DISABLED) then
			self.disabled = true;
		end
		self:Refresh();
	elseif (event == "TOKEN_STATUS_CHANGED") then
		AuctionWowToken_UpdateMarketPrice();
		self.disabled = not C_WowTokenPublic.GetCommerceSystemStatus();
		self:Refresh();
	elseif (event == "TOKEN_SELL_RESULT") then
		local result = ...;
		if (result == LE_TOKEN_RESULT_ERROR_DISABLED) then
			UIErrorsFrame:AddMessage(TOKEN_AUCTIONS_UNAVAILABLE, 1.0, 0.1, 0.1, 1.0);
		elseif (result ~= LE_TOKEN_RESULT_SUCCESS) then
			UIErrorsFrame:AddMessage(ERR_AUCTION_DATABASE_ERROR, 1.0, 0.1, 0.1, 1.0);
		else
			C_WowTokenPublic.UpdateListedAuctionableTokens();

			local info = ChatTypeInfo["SYSTEM"];
			DEFAULT_CHAT_FRAME:AddMessage(ERR_AUCTION_STARTED, info.r, info.g, info.b, info.id);
		end
	elseif (event == "TOKEN_AUCTION_SOLD") then
		C_WowTokenPublic.UpdateListedAuctionableTokens();
	elseif (event == "TOKEN_SELL_CONFIRMED") then
		self:SetItem(nil);
	end
end

function WoWTokenSellFrameMixin:SetItem(itemLocation)
	if itemLocation then
		C_WowTokenPublic.UpdateTokenCount();
	end

	local skipCallback = true;
	self.ItemDisplay:SetItemLocation(itemLocation, skipCallback);

	local itemIsValid = itemLocation and C_Item.DoesItemExist(itemLocation);
	self.PostButton:SetEnabled(itemIsValid);
end

function WoWTokenSellFrameMixin:GetItem()
	return self.ItemDisplay:GetItemLocation();
end

function WoWTokenSellFrameMixin:GetSellToken()
	local itemLocation = self.ItemDisplay:GetItemLocation();
	local itemIsValid = itemLocation and C_Item.DoesItemExist(itemLocation);
	return itemIsValid and C_Item.GetItemGUID(itemLocation) or nil;
end

function WoWTokenSellFrameMixin:Refresh()
	local price, duration = C_WowTokenPublic.GetCurrentMarketPrice();
	if (WowToken_IsWowTokenAuctionDialogShown()) then
		price = C_WowTokenPublic.GetGuaranteedPrice();
	end

	local enabled = price and not self.disabled;
	self.InvisiblePriceFrame:SetShown(enabled);
	self.PostButton:SetEnabled(enabled);
	self.MarketPrice:SetFontObject(enabled and PriceFontWhite or GameFontRed);
	if (enabled) then
		self.MarketPrice:SetText(GetMoneyString(price, true));
		local timeToSellString = _G[("AUCTION_TIME_LEFT%d_DETAIL"):format(duration)];
		self.TimeToSell:SetText(timeToSellString);
	else
		self.MarketPrice:SetText(TOKEN_MARKET_PRICE_NOT_AVAILABLE);
		self.TimeToSell:SetText(UNKNOWN);
	end
end

WoWTokenDisplayMixin = CreateFromMixins(AuctionHouseItemDisplayMixin);

function WoWTokenDisplayMixin:OnLoad()
	AuctionHouseItemDisplayMixin.OnLoad(self);

	--Hides the FavoriteButton for this frame since the WoW token can't be favorited
	self.FavoriteButton:Hide();
end

local WowTokenUpdateInfo = {};

function WowTokenUpdateInfo.AreWowTokenResultsVisible()
	return AuctionHouseFrame:GetDisplayMode() == AuctionHouseFrameDisplayMode.WoWTokenBuy;
end

function WowTokenUpdateInfo.IsWowTokenAuctionFrameVisible()
	return AuctionHouseFrame:GetDisplayMode() == AuctionHouseFrameDisplayMode.WoWTokenSell;
end


function AuctionWowToken_UpdateMarketPriceCallback()
	if (C_WowTokenPublic.GetCommerceSystemStatus()
		and ((WowTokenUpdateInfo.AreWowTokenResultsVisible() or WowTokenUpdateInfo.IsWowTokenAuctionFrameVisible()) and not WowToken_IsWowTokenAuctionDialogShown())) then
		WowTokenUpdateInfo.lastMarketPriceUpdate = GetTime();
		C_WowTokenPublic.UpdateMarketPrice();
	elseif (not (WowTokenUpdateInfo.AreWowTokenResultsVisible() or WowTokenUpdateInfo.IsWowTokenAuctionFrameVisible())) then
		AuctionWowToken_CancelUpdateTicker();
	end
end

function AuctionWowToken_ShouldUpdatePrice()
	local now = GetTime();
	local enabled, pollTimeSeconds = C_WowTokenPublic.GetCommerceSystemStatus();
	if (not enabled) then
		return false;
	elseif (not C_WowTokenPublic.GetCurrentMarketPrice()) then
		return true;
	elseif (not WowTokenUpdateInfo.lastMarketPriceUpdate) then
		return true;
	elseif (now - WowTokenUpdateInfo.lastMarketPriceUpdate > pollTimeSeconds) then
		return true;
	end
	return false;
end

function AuctionWowToken_UpdateMarketPrice()
	if (AuctionWowToken_ShouldUpdatePrice()) then
		WowTokenUpdateInfo.lastMarketPriceUpdate = GetTime();
		C_WowTokenPublic.UpdateMarketPrice();
	end
	if ((WowTokenUpdateInfo.AreWowTokenResultsVisible() or WowTokenUpdateInfo.IsWowTokenAuctionFrameVisible()) and not WowToken_IsWowTokenAuctionDialogShown()) then
		local _, pollTimeSeconds = C_WowTokenPublic.GetCommerceSystemStatus();
		if (not WowTokenUpdateInfo.priceUpdateTimer or pollTimeSeconds ~= WowTokenUpdateInfo.priceUpdateTimer.pollTimeSeconds) then
			if (WowTokenUpdateInfo.priceUpdateTimer) then
				WowTokenUpdateInfo.priceUpdateTimer:Cancel();
			end
			WowTokenUpdateInfo.priceUpdateTimer = C_Timer.NewTicker(pollTimeSeconds, AuctionWowToken_UpdateMarketPriceCallback);
			WowTokenUpdateInfo.priceUpdateTimer.pollTimeSeconds = pollTimeSeconds;
		end
	end
end

function AuctionWowToken_CancelUpdateTicker()
	if (WowTokenUpdateInfo.priceUpdateTimer) then
		WowTokenUpdateInfo.priceUpdateTimer:Cancel();
		WowTokenUpdateInfo.priceUpdateTimer = nil;
	end
end

function WoWTokenGameTimeTutorial_OnLoad(self)
	ButtonFrameTemplate_HidePortrait(self);
	ButtonFrameTemplate_HideAttic(self);
	ButtonFrameTemplate_HideButtonBar(self);
	self:SetTitle(TUTORIAL_TOKEN_ABOUT_TOKENS);
end

function WoWTokenGameTimeTutorial_OnShow(self)
	local balanceEnabled = select(3, C_WowTokenPublic.GetCommerceSystemStatus());
	self.LeftDisplay.Tutorial3:SetIndentedWordWrap(true);
	if (balanceEnabled) then
		self.LeftDisplay.Tutorial3:SetText(TUTORIAL_TOKEN_GAME_TIME_STEP_2_BALANCE:format(WowTokenRedemptionFrame_GetBalanceString()));
	else
		self.LeftDisplay.Tutorial3:SetText(TUTORIAL_TOKEN_GAME_TIME_STEP_2);
	end
end

function WowTokenGameTimeTutorialStoreButton_OnEvent(self, event)
	if event == "TRIAL_STATUS_UPDATE" then
		WowTokenGameTimeTutorialStoreButton_UpdateState(self);
	end
end

function WowTokenGameTimeTutorialStoreButton_UpdateState(self)
	if GameLimitedMode_IsActive() then
		self.tooltip = ERR_FEATURE_RESTRICTED_TRIAL;
		self:Disable();
	else
		self.tooltip = nil;
		self:Enable();
	end
end

function WowTokenGameTimeTutorialStoreButton_OnLoad(self)
	local fontString = self:GetFontString();
	fontString:SetPoint("CENTER", 8, 2);
	self.Logo:ClearAllPoints();
	self.Logo:SetPoint("RIGHT", fontString, "LEFT", -2, 0);
	WowTokenGameTimeTutorialStoreButton_UpdateState(self);
	self:RegisterEvent("TRIAL_STATUS_UPDATE");
end



--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseWoWTokenFrame.lua ---

--- START OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseWoWTokenFrame.xml ---

<Ui xmlns="http://www.blizzard.com/wow/ui/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.blizzard.com/wow/ui/
..\..\..\..\..\..\WoW\Data\Interface\AddOns\Blizzard_SharedXML\UI.xsd">
	
	<Frame name="BrowseWowTokenResultsTemplate" inherits="AuctionHouseBackgroundTemplate" virtual="true">
		<KeyValues>
			<KeyValue key="backgroundAtlas" value="auctionhouse-background-index" type="string"/>
			<KeyValue key="backgroundTextureClassic" value="Interface\FrameGeneral\UI-Background-Marble" type="string"/>
			<KeyValue key="textureWidthClassic" value="595" type="number"/>
			<KeyValue key="textureHeightClassic" value="413" type="number"/>
			<KeyValue key="textureXOffsetClassic" value="2" type="number"/>
			<KeyValue key="textureYOffsetClassic" value="-3" type="number"/>
		</KeyValues>
		<Size x="634" y="306"/>
		<Anchors>
			<Anchor point="TOPLEFT" x="188" y="-103"/>
		</Anchors>
		<Layers>
			<Layer level="ARTWORK">
				<FontString parentKey="BuyoutLabel" inherits="GameFontNormal" text="TOKEN_CURRENT_BUYOUT_PRICE" justifyH="RIGHT">
					<Anchors>
						<Anchor point="CENTER" x="0" y="40"/>
					</Anchors>
					<Color color="NORMAL_FONT_COLOR"/>
				</FontString>
				<FontString parentKey="BuyoutPrice" inherits="NumberFont_Normal_Med" justifyH="LEFT">
					<Anchors>
						<Anchor point="TOP" relativeKey="$parent.BuyoutLabel" relativePoint="BOTTOM" x="0" y="-8"/>
					</Anchors>
					<Shadow x="1" y="-1">
						<Color r="0" g="0" b="0"/>
					</Shadow>
				</FontString>
			</Layer>
		</Layers>
		<Frames>
			<Frame parentKey="GameTimeTutorial" name="GameTimeTutorial" inherits="ButtonFrameTemplate" enableMouse="true" frameStrata="DIALOG" hidden="true">
				<Size x="646" y="540"/>
				<Anchors>
					<Anchor point="CENTER" relativeTo="UIParent" relativePoint="CENTER" x="0" y="35"/>
				</Anchors>
				<Layers>
					<Layer level="BACKGROUND">
						<Texture parentKey="Tutorial" atlas="token-info-background" useAtlasSize="true">
							<Anchors>
								<Anchor point="BOTTOM" x="0" y="4"/>
							</Anchors>
						</Texture>
					</Layer>
				</Layers>
				<Frames>
					<Frame parentKey="LeftInset" useParentLevel="true">
						<Size x="317" y="475" />
						<Anchors>
							<Anchor point="TOPLEFT" x="4" y="-22" />
							<Anchor point="BOTTOMLEFT" x="4" y="6" />
						</Anchors>
					</Frame>
					<Frame parentKey="RightInset" useParentLevel="true">
						<Anchors>
							<Anchor point="TOPRIGHT" x="-6" y="-22" />
							<Anchor point="BOTTOMLEFT" relativeKey="$parent.LeftInset" relativePoint="BOTTOMRIGHT" x="2" y="0" />
						</Anchors>
					</Frame>
					<Frame parentKey="LeftDisplay" useParentLevel="true">
						<Anchors>
							<Anchor point="TOPLEFT" relativeKey="$parent.LeftInset" relativePoint="TOPLEFT" x="3" y="-3" />
							<Anchor point="BOTTOMRIGHT" relativeKey="$parent.LeftInset" relativePoint="BOTTOMRIGHT" x="-3" y="3" />
						</Anchors>
						<Layers>
							<Layer level="ARTWORK">
								<FontString parentKey="Label" inherits="GameFontNormalHuge2" text="TUTORIAL_TOKEN_I_NEED_GAME_TIME" justifyH="LEFT">
									<Size x="280" y="0"/>
									<Anchors>
										<Anchor point="TOPLEFT" x="34" y="-38"/>
									</Anchors>
									<Color r="0" g="0" b="0"/>
								</FontString>
								<FontString parentKey="Tutorial1" inherits="GameFontNormal" text="TUTORIAL_TOKEN_PAY_FOR_TIME_WITH_GOLD" justifyH="LEFT">
									<Size x="280" y="0"/>
									<Anchors>
										<Anchor point="TOPLEFT" relativeKey="$parent.Label" relativePoint="BOTTOMLEFT" x="0" y="-9"/>
									</Anchors>
									<Color r=".282" g=".016" b=".016"/>
									<Shadow>
										<Offset>
											<AbsDimension x="0" y="0"/>
										</Offset>
										<Color r="0" g="0" b="0" a="0"/>
									</Shadow>
								</FontString>
								<FontString parentKey="Tutorial2" inherits="GameFontNormalMed1" text="TUTORIAL_TOKEN_GAME_TIME_STEP_1" justifyH="LEFT">
									<Size x="240" y="0"/>
									<Anchors>
										<Anchor point="TOPLEFT" relativeKey="$parent.Tutorial1" relativePoint="BOTTOMLEFT" x="8" y="-49"/>
									</Anchors>
								</FontString>
								<FontString parentKey="Tutorial3" inherits="GameFontNormalMed1" text="TUTORIAL_TOKEN_GAME_TIME_STEP_2" justifyH="LEFT">
									<Size x="240" y="0"/>
									<Anchors>
										<Anchor point="TOPLEFT" relativeKey="$parent.Tutorial2" relativePoint="BOTTOMLEFT" x="0" y="-26"/>
									</Anchors>
								</FontString>
							</Layer>
						</Layers>
					</Frame>
					<Frame parentKey="RightDisplay" useParentLevel="true">
						<Anchors>
							<Anchor point="TOPLEFT" relativeKey="$parent.RightInset" relativePoint="TOPLEFT" x="3" y="-3" />
							<Anchor point="BOTTOMRIGHT" relativeKey="$parent.RightInset" relativePoint="BOTTOMRIGHT" x="-3" y="3" />
						</Anchors>
						<Layers>
							<Layer level="ARTWORK">
								<FontString parentKey="Label" inherits="GameFontNormalHuge2" text="TUTORIAL_TOKEN_I_NEED_GOLD" justifyH="LEFT">
									<Size x="280" y="0"/>
									<Anchors>
										<Anchor point="TOPLEFT" x="26" y="-38"/>
									</Anchors>
									<Color r="0" g="0" b="0"/>
								</FontString>
								<FontString parentKey="Tutorial1" inherits="GameFontNormal" text="TUTORIAL_TOKEN_SELL_FOR_GOLD" justifyH="LEFT">
									<Size x="280" y="0"/>
									<Anchors>
										<Anchor point="TOPLEFT" relativeKey="$parent.Label" relativePoint="BOTTOMLEFT" x="0" y="-9"/>
									</Anchors>
									<Color r=".282" g=".016" b=".016"/>
									<Shadow>
										<Offset>
											<AbsDimension x="0" y="0"/>
										</Offset>
										<Color r="0" g="0" b="0" a="0"/>
									</Shadow>
								</FontString>
								<FontString parentKey="Tutorial2" inherits="GameFontNormalMed1" text="TUTORIAL_TOKEN_GOLD_STEP_1" justifyH="LEFT">
									<Size x="240" y="0"/>
									<Anchors>
										<Anchor point="TOPLEFT" relativeKey="$parent.Tutorial1" relativePoint="BOTTOMLEFT" x="8" y="-49"/>
									</Anchors>
								</FontString>
								<FontString parentKey="Tutorial3" inherits="GameFontNormalMed1" text="TUTORIAL_TOKEN_GOLD_STEP_2" justifyH="LEFT">
									<Size x="240" y="0"/>
									<Anchors>
										<Anchor point="TOPLEFT" relativeKey="$parent.Tutorial2" relativePoint="BOTTOMLEFT" x="0" y="-62"/>
									</Anchors>
								</FontString>
								<Texture parentKey="infoarrow" atlas="token-info-arrow" useAtlasSize="true">
									<Anchors>
										<Anchor point="TOPLEFT" relativeKey="$parent.Tutorial2" relativePoint="BOTTOMLEFT" x="20" y="-11"/>
									</Anchors>
								</Texture>
							</Layer>
						</Layers>
						<Frames>
							<Button parentKey="StoreButton" inherits="UIPanelGoldButtonTemplate" motionScriptsWhileDisabled="true" text="BLIZZARD_STORE">
								<Size x="164" y="32"/>
								<Anchors>
									<Anchor point="TOPLEFT" relativeKey="$parent.Tutorial2" relativePoint="BOTTOMLEFT" x="41" y="-12"/>
								</Anchors>
								<Layers>
									<Layer level="OVERLAY">
										<Texture parentKey="Logo" file="Interface\Store\Store-Main">
											<Size x="21" y="20"/>									
											<TexCoords left="0.97460938" right="0.99511719" top="0.27148438" bottom="0.29101563"/>
										</Texture>
									</Layer>
								</Layers>
								<Scripts>
									<OnLoad function="WowTokenGameTimeTutorialStoreButton_OnLoad"/>
									<OnEvent function="WowTokenGameTimeTutorialStoreButton_OnEvent"/>
									<OnClick>
										ToggleStoreUI();
										StoreFrame_SetTokenCategory();
									</OnClick>
									<OnMouseDown>
										if (self:IsEnabled()) then
											local fontString = self:GetFontString();
											self.Logo:SetPoint("RIGHT", fontString, "LEFT", -1, -2);
										end
									</OnMouseDown>
									<OnMouseUp>
										if (self:IsEnabled()) then
											local fontString = self:GetFontString();
											self.Logo:SetPoint("RIGHT", fontString, "LEFT", -2, 0);
										end
									</OnMouseUp>
									<OnEnable>
										self.Left:SetTexture("Interface\\Buttons\\UI-DialogBox-goldbutton-up-left");
										self.Middle:SetTexture("Interface\\Buttons\\UI-DialogBox-goldbutton-up-middle");
										self.Right:SetTexture("Interface\\Buttons\\UI-DialogBox-goldbutton-up-right");
										self.Logo:SetDesaturated(false);
										self.Logo:SetAlpha(1);
									</OnEnable>
									<OnDisable>
										self.Left:SetTexture("Interface\\Buttons\\UI-DialogBox-goldbutton-disabled-left");
										self.Middle:SetTexture("Interface\\Buttons\\UI-DialogBox-goldbutton-disabled-middle");
										self.Right:SetTexture("Interface\\Buttons\\UI-DialogBox-goldbutton-disabled-right");
										self.Logo:SetDesaturated(true);
										self.Logo:SetAlpha(0.4);
									</OnDisable>
									<OnEnter>
										if (self.tooltip) then
											GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
											GameTooltip:SetText(self.tooltip, RED_FONT_COLOR.r, RED_FONT_COLOR.g, RED_FONT_COLOR.b, true);
											GameTooltip:Show();
										end
									</OnEnter>
									<OnLeave function="GameTooltip_Hide"/>
								</Scripts>
							</Button>
						</Frames>
					</Frame>
				</Frames>
				<Scripts>
					<OnLoad function="WoWTokenGameTimeTutorial_OnLoad"/>
					<OnShow function="WoWTokenGameTimeTutorial_OnShow"/>
				</Scripts>
			</Frame>
			<Button parentKey="HelpButton" inherits="MainHelpPlateButton">
				<Anchors>
					<Anchor point="TOPRIGHT" x="5" y="8" />
				</Anchors>
				<HighlightTexture file="Interface\common\help-i" alphaMode="ADD" hidden="true">
					<Size x="46" y="46"/>
					<Anchors>
						<Anchor point="CENTER"/>
					</Anchors>
					<Color r="1" g="1" b="1" a=".2"/>
				</HighlightTexture>
			</Button>
			<Button parentKey="TokenDisplay" mixin="WoWTokenDisplayMixin" inherits="AuctionHouseItemDisplayTemplate">
				<Anchors>
					<Anchor point="TOP" x="0" y="-63"/>
				</Anchors>
				<Layers>
					<Layer level="ARTWORK">
						<Texture atlas="auctionhouse-itemheaderframe" useAtlasSize="true">
							<Anchors>
								<Anchor point="CENTER"/>
							</Anchors>
						</Texture>
					</Layer>
				</Layers>
			</Button>
			<Button parentKey="Buyout" inherits="UIPanelButtonTemplate" text="BUYOUT" motionScriptsWhileDisabled="true">
				<Size x="194" y="22"/>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.TokenDisplay" relativePoint="BOTTOM" x="0" y="-110"/>
				</Anchors>
				<Scripts>
					<OnClick function="BrowseWowTokenResultsBuyout_OnClick"/>
					<OnEnter function="BrowseWowTokenResultsBuyout_OnEnter"/>
					<OnLeave function="GameTooltip_Hide"/>
				</Scripts>
			</Button>
			<Frame parentKey="InvisiblePriceFrame" enableMouse="true">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.BuyoutLabel" relativePoint="TOPLEFT" x="-20" y="10"/>
					<Anchor point="TOPRIGHT" relativeKey="$parent.BuyoutLabel" relativePoint="TOPRIGHT" x="20" y="10"/>
					<Anchor point="BOTTOM" relativeKey="$parent.BuyoutPrice" relativePoint="BOTTOM" x="0" y="-10"/>
				</Anchors>
				<Scripts>
					<OnEnter>
						GameTooltip:SetOwner(self, "ANCHOR_RIGHT",-20,-10);
						GameTooltip:SetText(TOKEN_BUYOUT_PRICE_UPDATES, nil, nil, nil, nil, true);
						GameTooltip:Show();
					</OnEnter>
					<OnLeave function="GameTooltip_Hide"/>
				</Scripts>
			</Frame>
			<Slider parentKey="DummyScrollBar" inherits="DummyAuctionHouseScrollBarTemplate"/>
		</Frames>
		<Scripts>
			<OnLoad function="BrowseWowTokenResults_OnLoad"/>
			<OnEvent function="BrowseWowTokenResults_OnEvent"/>
			<OnShow function="BrowseWowTokenResults_OnShow"/>
			<OnHide function="BrowseWowTokenResults_OnHide"/>
		</Scripts>
	</Frame>

	<Frame name="WoWTokenSellFrameTemplate" mixin="WoWTokenSellFrameMixin" inherits="AuctionHouseBackgroundTemplate" virtual="true">
		<KeyValues>
			<KeyValue key="backgroundAtlas" value="auctionhouse-background-sell-left" type="string"/>
			<KeyValue key="backgroundTextureClassic" value="Interface\QuestFrame\UI-TextBackground-BackdropBackground" type="string"/>
			<KeyValue key="textureXOffsetClassic" value="3" type="number"/>
			<KeyValue key="textureYOffsetClassic" value="-2" type="number"/>
			<KeyValue key="textureWidthClassic" value="357" type="number"/>
			<KeyValue key="textureHeightClassic" value="438" type="number"/>
		</KeyValues>
		<Layers>
			<Layer level="ARTWORK">
				<FontString parentKey="BuyoutPriceLabel" inherits="GameFontNormal" text="TOKEN_CURRENT_MARKET_PRICE" justifyH="CENTER">
					<Anchors>
						<Anchor point="TOP" x="0" y="-110"/>
					</Anchors>
				</FontString>
				<FontString parentKey="MarketPrice" inherits="Number14FontWhite" justifyH="CENTER">
					<Anchors>
						<Anchor point="TOP" relativeKey="$parent.BuyoutPriceLabel" relativePoint="BOTTOM" x="0" y="-6"/>
					</Anchors>
				</FontString>
				<FontString parentKey="EstimatedTime" inherits="GameFontNormal" text="ESTIMATED_TIME_TO_SELL" justifyH="CENTER">
					<Anchors>
						<Anchor point="TOP" relativeKey="$parent.MarketPrice" relativePoint="BOTTOM" x="0" y="-30"/>
					</Anchors>
				</FontString>
				<FontString parentKey="TimeToSell" inherits="GameFontHighlight" justifyH="CENTER">
					<Size x="160" y="0"/>
					<Anchors>
						<Anchor point="TOP" relativeKey="$parent.EstimatedTime" relativePoint="BOTTOM" x="0" y="-6"/>
					</Anchors>
				</FontString>
				<Texture parentKey="CreateAuctionTabLeft" atlas="auctionhouse-selltab-left" useAtlasSize="true">
					<Anchors>
						<Anchor point="BOTTOMLEFT" relativeKey="$parent" relativePoint="TOPLEFT" x="42" y="-3"/>
					</Anchors>
				</Texture>
				<FontString parentKey="CreateAuctionLabel" inherits="GameFontNormalSmall" justifyH="LEFT" text="CREATE_AUCTION">
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.CreateAuctionTabLeft" relativePoint="RIGHT" x="12"/>
					</Anchors>
				</FontString>
			</Layer>
			<Layer level="BORDER">
				<Texture parentKey="CreateAuctionTabMiddle" atlas="auctionhouse-selltab-middle">
					<Size y="23"/>
					<Anchors>
						<Anchor point="TOPLEFT" relativeKey="$parent.CreateAuctionTabLeft" relativePoint="TOPRIGHT" x="0" y="0"/>
						<Anchor point="RIGHT" relativeKey="$parent.CreateAuctionLabel" relativePoint="RIGHT" x="12" y="0"/>
					</Anchors>
				</Texture>

				<Texture parentKey="CreateAuctionTabRight" atlas="auctionhouse-selltab-right" useAtlasSize="true">
					<Anchors>
						<Anchor point="TOPLEFT" relativeKey="$parent.CreateAuctionTabMiddle" relativePoint="TOPRIGHT"/>
						<Anchor point="BOTTOMLEFT" relativeKey="$parent.CreateAuctionTabMiddle" relativePoint="BOTTOMRIGHT"/>
					</Anchors>
				</Texture>
			</Layer>
		</Layers>
		<Frames>
			<Button parentKey="ItemDisplay" inherits="AuctionHouseInteractableItemDisplayTemplate" mixin="AuctionHouseSellFrameItemDisplayMixin" frameLevel="350">
				<Size x="342" y="72"/>
				<Anchors>
					<Anchor point="TOP" x="0" y="-12"/>
				</Anchors>
				<Layers>
					<Layer level="ARTWORK">
						<Texture atlas="auctionhouse-itemheaderframe" useAtlasSize="true">
							<Anchors>
								<Anchor point="CENTER"/>
							</Anchors>
						</Texture>
					</Layer>
				</Layers>
				<Scripts>
					<OnLoad method="OnLoad"/>
				</Scripts>
			</Button>
			<Frame parentKey="InvisiblePriceFrame" enableMouse="true">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.BuyoutPriceLabel" relativePoint="TOPLEFT" x="-20" y="10"/>
					<Anchor point="TOPRIGHT" relativeKey="$parent.BuyoutPriceLabel" relativePoint="TOPRIGHT" x="20" y="10"/>
					<Anchor point="BOTTOM" relativeKey="$parent.MarketPrice" relativePoint="BOTTOM" x="0" y="-10"/>
				</Anchors>
				<Scripts>
					<OnEnter>
						GameTooltip:SetOwner(self, "ANCHOR_RIGHT", -20, -10);
						GameTooltip:SetText(TOKEN_CREATE_AUCTION_LOCKED_PRICE, nil, nil, nil, nil, true);
						GameTooltip:Show();
					</OnEnter>
					<OnLeave function="GameTooltip_Hide"/>
				</Scripts>
			</Frame>
			<Button parentKey="PostButton" motionScriptsWhileDisabled="true" mixin="AuctionHouseSellFramePostButtonMixin" inherits="UIPanelButtonTemplate" text="AUCTION_HOUSE_POST_BUTTON">
				<Size x="190" y="22"/>
				<Anchors>
					<Anchor point="TOP" relativeKey="$parent.TimeToSell" relativePoint="BOTTOM" x="0" y="-30"/>
				</Anchors>
				<Scripts>
					<OnClick>
						local sellToken = self:GetParent():GetSellToken();
						if sellToken then
							C_WowTokenUI.StartTokenSell(sellToken);
						end
					</OnClick>
				</Scripts>
			</Button>
			<Frame parentKey="DummyItemList" inherits="AuctionHouseBackgroundTemplate">
				<KeyValues>
					<KeyValue key="backgroundAtlas" value="auctionhouse-background-sell-right" type="string"/>
					<KeyValue key="backgroundTextureClassic" value="Interface\FrameGeneral\UI-Background-Marble" type="string"/>
					<KeyValue key="textureWidthClassic" value="399" type="number"/>
					<KeyValue key="textureHeightClassic" value="418" type="number"/>
					<KeyValue key="textureXOffsetClassic" value="2" type="number"/>
					<KeyValue key="textureYOffsetClassic" value="-3" type="number"/>
				</KeyValues>
				<Size x="405" y="0"/>
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent" relativePoint="TOPRIGHT" x="1" y="-19"/>
					<Anchor point="BOTTOMLEFT" relativeKey="$parent" relativePoint="BOTTOMRIGHT" x="1" y="0"/>
				</Anchors>
				<Frames>
					<Slider parentKey="DummyScrollBar" inherits="DummyAuctionHouseScrollBarTemplate"/>
				</Frames>
			</Frame>
			<Button parentKey="DummyRefreshButton" inherits="RefreshButtonTemplate">
				<Anchors>
					<Anchor point="TOPRIGHT" relativeKey="$parent.DummyItemList" relativePoint="TOPRIGHT" x="17" y="55"/>
				</Anchors>
			</Button>
		</Frames>
		<Scripts>
			<OnLoad method="OnLoad"/>
			<OnShow method="OnShow"/>
			<OnEvent method="OnEvent"/>
		</Scripts>
	</Frame>
</Ui>

--- END OF FILE: Blizzard_AuctionHouseUI\Shared\Blizzard_AuctionHouseWoWTokenFrame.xml ---

